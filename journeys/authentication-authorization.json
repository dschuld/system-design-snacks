{
  "id": "authentication-authorization",
  "title": "Authentication & Authorization Mastery",
  "totalLessons": 6,
  "available": true,
  "lessons": [
    {
      "id": 1,
      "title": "Why Do We Need Authentication & Authorization Patterns?",
      "goals": [
        "Understand the fundamental difference between authentication and authorization",
        "Identify security challenges unique to distributed systems and microservices",
        "Recognize why traditional session-based authentication doesn't scale"
      ],
      "content": "<div class=\"concept-section\">\n  <h3>The Two Pillars of Security</h3>\n  <p>Imagine a hotel with hundreds of rooms. When you check in, the front desk verifies your identity by checking your ID‚Äîthat's <strong>authentication</strong>. They then hand you a key card programmed to open only your room and the gym‚Äîthat's <strong>authorization</strong>. You might be authenticated (the hotel knows who you are), but you're not authorized to access the presidential suite or the staff area.</p>\n  <p>In software systems, these concepts are equally distinct but often confused:</p>\n  <ul>\n    <li><strong>Authentication:</strong> Proving who you are (identity verification)</li>\n    <li><strong>Authorization:</strong> Determining what you're allowed to do (permission verification)</li>\n  </ul>\n</div>\n\n<div class=\"concept-section\">\n  <h3>The Monolithic Era: Simple Sessions</h3>\n  <p>In traditional web applications, authentication was straightforward:</p>\n  <ol>\n    <li>User submits username and password</li>\n    <li>Server validates credentials against database</li>\n    <li>Server creates a session, stores it in memory or database</li>\n    <li>Server returns session cookie to browser</li>\n    <li>Browser sends cookie with every subsequent request</li>\n  </ol>\n  <p>This worked beautifully when you had one application server handling all requests. The server maintained session state and could easily check \"Is this user logged in?\" by looking up the session.</p>\n</div>\n\n<div class=\"concept-section\">\n  <h3>The Distributed System Problem</h3>\n  <p>Modern architectures break this simple model in multiple ways:</p>\n  <ul>\n    <li><strong>Multiple services:</strong> Your frontend calls an API gateway, which calls user service, order service, payment service. Which service validates the session?</li>\n    <li><strong>Load balancing:</strong> Request 1 hits server A, request 2 hits server B. Does server B have access to the session created on server A?</li>\n    <li><strong>Stateless scaling:</strong> To scale horizontally, services should be stateless. Session storage creates state that must be shared.</li>\n    <li><strong>Mobile and SPAs:</strong> Not all clients are web browsers that handle cookies automatically</li>\n    <li><strong>Third-party access:</strong> How does a mobile app access your API without sharing user credentials?</li>\n  </ul>\n</div>\n\n<div class=\"concept-section\">\n  <h3>Security Challenges in Microservices</h3>\n  <div style=\"background: #fff3e0; padding: 20px; border-radius: 10px; margin: 20px 0;\">\n    <h4>‚ö†Ô∏è The Trust Boundary Problem</h4>\n    <p>In a microservices architecture, every service call crosses a trust boundary. Consider this flow:</p>\n    <ol>\n      <li>User authenticated at API Gateway</li>\n      <li>Gateway calls Order Service</li>\n      <li>Order Service calls Inventory Service</li>\n      <li>Inventory Service calls Pricing Service</li>\n    </ol>\n    <p><strong>Questions that arise:</strong></p>\n    <ul>\n      <li>Should Inventory Service re-verify the user's identity?</li>\n      <li>How does Pricing Service know which user initiated this request?</li>\n      <li>What if a malicious service impersonates the API Gateway?</li>\n      <li>How do you propagate user context through the entire chain?</li>\n    </ul>\n  </div>\n</div>\n\n<div class=\"concept-section\">\n  <h3>Common Attack Vectors</h3>\n  <ul>\n    <li><strong>Credential stuffing:</strong> Attackers use leaked passwords from other sites to access your system</li>\n    <li><strong>Session hijacking:</strong> Attacker steals session cookie and impersonates user</li>\n    <li><strong>Man-in-the-middle:</strong> Attacker intercepts communication between client and server</li>\n    <li><strong>Token theft:</strong> Stored tokens can be extracted from compromised devices</li>\n    <li><strong>Replay attacks:</strong> Attacker captures and reuses valid authentication requests</li>\n    <li><strong>Privilege escalation:</strong> User gains access to resources beyond their authorization level</li>\n  </ul>\n  <p>These threats drive the need for sophisticated authentication and authorization patterns beyond simple username/password.</p>\n</div>\n\n<div class=\"concept-section\">\n  <h3>Why We Need Standard Protocols</h3>\n  <p>Rather than building custom security solutions (which often have vulnerabilities), the industry has converged on standard protocols:</p>\n  <ul>\n    <li>‚úÖ <strong>Battle-tested:</strong> Security experts have reviewed and improved them over years</li>\n    <li>‚úÖ <strong>Interoperability:</strong> Systems from different vendors can integrate securely</li>\n    <li>‚úÖ <strong>Library support:</strong> Well-maintained implementations in every major language</li>\n    <li>‚úÖ <strong>Common patterns:</strong> Developers can move between projects with familiar approaches</li>\n  </ul>\n  <p>The protocols we'll explore‚ÄîOAuth 2.0, OpenID Connect, and JWT‚Äîaddress these distributed system challenges with proven patterns.</p>\n</div>\n\n<div class=\"exercise\">\n  <h3>üõ†Ô∏è Identify the Security Challenge</h3>\n  <p><strong>Scenario:</strong> You're building a social media platform with these components:</p>\n  <ul>\n    <li>Web frontend (React SPA)</li>\n    <li>Mobile apps (iOS and Android)</li>\n    <li>API Gateway</li>\n    <li>User Service (handles profiles, authentication)</li>\n    <li>Post Service (creates and retrieves posts)</li>\n    <li>Media Service (handles image uploads to S3)</li>\n    <li>Notification Service (sends push notifications)</li>\n  </ul>\n  <p><strong>Your task:</strong> Identify at least 3 specific security challenges this architecture faces that simple session-based authentication cannot solve. For each challenge, describe what could go wrong if not handled properly.</p>\n  <p><strong>Consider:</strong> How does the mobile app authenticate? How does Post Service know which user is creating a post? How do you prevent one user from accessing another user's photos?</p>\n</div>"
    },
    {
      "id": 2,
      "title": "OAuth 2.0 Fundamentals: The Authorization Framework",
      "goals": [
        "Understand what OAuth 2.0 is and, critically, what it is NOT",
        "Master the four core grant types and when to use each one",
        "Learn the roles and responsibilities of OAuth 2.0 components",
        "Recognize common OAuth misconceptions and anti-patterns"
      ],
      "content": "<div class=\"concept-section\">\n  <h3>What OAuth 2.0 Actually Is</h3>\n  <p>OAuth 2.0 is an <strong>authorization framework</strong>, not an authentication protocol. This is the most critical distinction to understand, and where most confusion begins.</p>\n  <p>Think of OAuth 2.0 like a valet parking system: You give the valet your car key (authorization), but you don't give them your house keys, your gym locker combination, or prove your identity. The valet can park your car (limited authorization) but can't do anything else. The valet service doesn't care <em>who you are</em>‚Äîit only cares that you're authorized to grant access to that specific car.</p>\n  <p><strong>OAuth 2.0's purpose:</strong> Allow one application to access resources on behalf of a user <em>without</em> sharing the user's credentials.</p>\n</div>\n\n<div class=\"concept-section\">\n  <h3>The OAuth 2.0 Roles</h3>\n  <p>Every OAuth 2.0 flow involves four key roles:</p>\n  <ul>\n    <li><strong>Resource Owner:</strong> The user who owns the data (e.g., you own your Facebook photos)</li>\n    <li><strong>Client:</strong> The application requesting access (e.g., a photo printing app)</li>\n    <li><strong>Authorization Server:</strong> Issues access tokens after authenticating the resource owner (e.g., Facebook's OAuth server)</li>\n    <li><strong>Resource Server:</strong> Hosts the protected resources and accepts access tokens (e.g., Facebook's API that serves photos)</li>\n  </ul>\n  <p><em>Note: Authorization Server and Resource Server are often the same system, but conceptually separate.</em></p>\n</div>\n\n<div class=\"concept-section\">\n  <h3>The Classic OAuth 2.0 Example</h3>\n  <p>You want to use a third-party service \"PrintMyPhotos.com\" to print your Facebook photos:</p>\n  <ol>\n    <li><strong>Without OAuth:</strong> You'd give PrintMyPhotos your Facebook username and password (terrible idea!)</li>\n    <li><strong>With OAuth:</strong> PrintMyPhotos redirects you to Facebook, you approve access to your photos only, Facebook gives PrintMyPhotos a token, PrintMyPhotos uses that token to fetch your photos</li>\n  </ol>\n  <p>You never shared your Facebook credentials with PrintMyPhotos, and you can revoke their access anytime.</p>\n</div>\n\n<div class=\"concept-section\">\n  <h3>OAuth 2.0 is NOT Authentication</h3>\n  <div style=\"background: #ffebee; padding: 20px; border-radius: 10px; margin: 20px 0;\">\n    <h4>‚ö†Ô∏è Critical Misconception</h4>\n    <p>An access token proves the client is authorized to access resources, but it doesn't prove the user's identity. Here's why:</p>\n    <ul>\n      <li>‚ùå Access tokens don't have a standardized format (could be opaque strings)</li>\n      <li>‚ùå No standard way to get user information from an access token</li>\n      <li>‚ùå Token might represent client credentials, not a user</li>\n      <li>‚ùå No standard claims about who the user is</li>\n    </ul>\n    <p><strong>Bottom line:</strong> If your app needs to know \"who is this user?\", OAuth 2.0 alone is insufficient. You need OpenID Connect (covered in Lesson 3).</p>\n  </div>\n</div>\n\n<div class=\"concept-section\">\n  <h3>The Four Grant Types</h3>\n  <p>OAuth 2.0 defines four ways (grant types) to obtain an access token, each suited to different scenarios:</p>\n</div>\n\n<div class=\"concept-section\">\n  <h4>1. Authorization Code Grant (Most Secure)</h4>\n  <p>The gold standard for web applications and mobile apps. Used when you can keep a client secret secure.</p>\n  <div style=\"background: #e8f5e8; padding: 20px; border-radius: 10px; margin: 10px 0;\">\n    <p><strong>Flow:</strong></p>\n    <ol>\n      <li>User clicks \"Login with Google\" in your app</li>\n      <li>Your app redirects to Google with your client_id and requested scopes</li>\n      <li>User authenticates with Google and approves access</li>\n      <li>Google redirects back to your app with an <strong>authorization code</strong></li>\n      <li>Your backend exchanges the code for an access token (using client_secret)</li>\n      <li>Your backend uses the access token to fetch user data from Google</li>\n    </ol>\n    <p><strong>‚úÖ Use when:</strong> You have a backend server that can securely store client_secret</p>\n    <p><strong>‚úÖ Security benefit:</strong> Access token never exposed to browser or mobile app</p>\n  </div>\n</div>\n\n<div class=\"concept-section\">\n  <h4>2. Client Credentials Grant</h4>\n  <p>Machine-to-machine authentication where no user is involved.</p>\n  <div style=\"background: #e3f2fd; padding: 20px; border-radius: 10px; margin: 10px 0;\">\n    <p><strong>Flow:</strong></p>\n    <ol>\n      <li>Your backend service authenticates directly with authorization server using client_id and client_secret</li>\n      <li>Authorization server returns access token</li>\n      <li>Your service uses token to access protected API</li>\n    </ol>\n    <p><strong>‚úÖ Use when:</strong> Service-to-service communication, scheduled jobs, backend processes</p>\n    <p><strong>Example:</strong> Your order processing service needs to call the inventory API</p>\n  </div>\n</div>\n\n<div class=\"concept-section\">\n  <h4>3. Implicit Grant (Deprecated - Don't Use)</h4>\n  <p>Designed for browser-based apps that couldn't keep secrets secure. Token returned directly in URL fragment.</p>\n  <div style=\"background: #fff3e0; padding: 20px; border-radius: 10px; margin: 10px 0;\">\n    <p><strong>‚ö†Ô∏è Status: Deprecated</strong></p>\n    <ul>\n      <li>‚ùå Token exposed in browser history and URL</li>\n      <li>‚ùå No refresh token support</li>\n      <li>‚ùå Vulnerable to token theft</li>\n    </ul>\n    <p><strong>Modern alternative:</strong> Use Authorization Code Grant with PKCE (Proof Key for Code Exchange) for single-page apps</p>\n  </div>\n</div>\n\n<div class=\"concept-section\">\n  <h4>4. Resource Owner Password Credentials Grant (Use Sparingly)</h4>\n  <p>User provides username and password directly to the client application.</p>\n  <div style=\"background: #fff3e0; padding: 20px; border-radius: 10px; margin: 10px 0;\">\n    <p><strong>Flow:</strong></p>\n    <ol>\n      <li>User enters username and password in your app</li>\n      <li>Your app sends credentials to authorization server</li>\n      <li>Authorization server returns access token</li>\n    </ol>\n    <p><strong>‚ö†Ô∏è Use ONLY when:</strong></p>\n    <ul>\n      <li>High trust between client and authorization server (e.g., mobile app to your own API)</li>\n      <li>Other grant types are not viable</li>\n      <li>Migrating from legacy authentication system</li>\n    </ul>\n    <p><strong>‚ùå Avoid because:</strong> Defeats OAuth's main purpose of not sharing credentials</p>\n  </div>\n</div>\n\n<div class=\"concept-section\">\n  <h3>OAuth 2.0 vs OpenID Connect vs SAML</h3>\n  <div style=\"display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; margin: 20px 0;\">\n    <div style=\"background: #e8f5e8; padding: 15px; border-radius: 10px;\">\n      <h4>OAuth 2.0</h4>\n      <ul>\n        <li><strong>Purpose:</strong> Authorization</li>\n        <li><strong>Question:</strong> \"Can I access this?\"</li>\n        <li><strong>Use case:</strong> Third-party API access</li>\n        <li><strong>Output:</strong> Access token</li>\n      </ul>\n    </div>\n    <div style=\"background: #e3f2fd; padding: 15px; border-radius: 10px;\">\n      <h4>OpenID Connect</h4>\n      <ul>\n        <li><strong>Purpose:</strong> Authentication + Authorization</li>\n        <li><strong>Question:</strong> \"Who are you?\"</li>\n        <li><strong>Use case:</strong> Single sign-on</li>\n        <li><strong>Output:</strong> ID token + Access token</li>\n      </ul>\n    </div>\n    <div style=\"background: #f3e5f5; padding: 15px; border-radius: 10px;\">\n      <h4>SAML</h4>\n      <ul>\n        <li><strong>Purpose:</strong> Enterprise SSO</li>\n        <li><strong>Question:</strong> \"Who are you?\"</li>\n        <li><strong>Use case:</strong> Enterprise federation</li>\n        <li><strong>Output:</strong> XML assertions</li>\n      </ul>\n    </div>\n  </div>\n  <p><strong>Key insight:</strong> OpenID Connect is an authentication layer <em>built on top of</em> OAuth 2.0. It's OAuth 2.0 + standardized authentication.</p>\n</div>\n\n<div class=\"concept-section\">\n  <h3>Authorization Code Flow: Detailed Walkthrough</h3>\n  <p>Let's trace exactly what happens when you click \"Sign in with Google\":</p>\n  <div style=\"background: #f8f9fa; padding: 10px; font-family: monospace; font-size: 14px; margin: 10px 0; line-height: 1.6;\">\n    1. User clicks \"Sign in with Google\"<br>\n    2. App redirects to:<br>\n    &nbsp;&nbsp;https://accounts.google.com/o/oauth2/v2/auth?<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;client_id=YOUR_CLIENT_ID&<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;redirect_uri=https://yourapp.com/callback&<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;response_type=code&<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;scope=email+profile<br>\n    <br>\n    3. User authenticates with Google<br>\n    4. User approves requested permissions<br>\n    5. Google redirects to:<br>\n    &nbsp;&nbsp;https://yourapp.com/callback?code=AUTH_CODE_HERE<br>\n    <br>\n    6. Your backend exchanges code for token:<br>\n    &nbsp;&nbsp;POST https://oauth2.googleapis.com/token<br>\n    &nbsp;&nbsp;client_id=YOUR_CLIENT_ID<br>\n    &nbsp;&nbsp;client_secret=YOUR_CLIENT_SECRET<br>\n    &nbsp;&nbsp;code=AUTH_CODE_HERE<br>\n    &nbsp;&nbsp;grant_type=authorization_code<br>\n    <br>\n    7. Google responds with:<br>\n    &nbsp;&nbsp;{<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;\"access_token\": \"ya29.a0...\",<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;\"expires_in\": 3600,<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;\"token_type\": \"Bearer\"<br>\n    &nbsp;&nbsp;}<br>\n    <br>\n    8. Your backend uses access_token to call Google APIs\n  </div>\n</div>\n\n<div class=\"exercise\">\n  <h3>üõ†Ô∏è Choose the Right Grant Type</h3>\n  <p><strong>Scenario:</strong> You're building different types of applications that need to interact with your company's APIs:</p>\n  <ol>\n    <li><strong>Customer mobile app:</strong> Native iOS/Android app where users log in to view their orders</li>\n    <li><strong>Partner integration:</strong> Third-party vendor needs to import customer data on a schedule</li>\n    <li><strong>Internal admin dashboard:</strong> React SPA used by customer support team</li>\n    <li><strong>Microservice communication:</strong> Order service needs to call inventory service</li>\n  </ol>\n  <p><strong>Your task:</strong> For each scenario, specify:</p>\n  <ul>\n    <li>Which OAuth 2.0 grant type to use</li>\n    <li>Why that grant type is appropriate</li>\n    <li>What security considerations apply</li>\n    <li>Whether OAuth 2.0 alone is sufficient or if OpenID Connect is needed</li>\n  </ul>\n  <p><strong>Consider:</strong> Can the client keep a secret? Is there a user involved? What's the trust relationship?</p>\n</div>"
    },{
      "id": 3,
      "title": "OpenID Connect & JWT: Adding Authentication to OAuth",
      "goals": [
        "Understand how OpenID Connect extends OAuth 2.0 to provide authentication",
        "Master JWT structure and learn to decode and validate tokens",
        "Distinguish between ID tokens, access tokens, and refresh tokens",
        "Learn how JWK and JWKS enable secure token verification"
      ],
      "content": "<div class=\"concept-section\">\n  <h3>The Authentication Gap in OAuth 2.0</h3>\n  <p>Imagine you're at an exclusive event. The bouncer checks your ticket (authorization) and lets you in. But once inside, how do other staff members know who you are? Your ticket doesn't have your name, photo, or any identifying information‚Äîit just proves you're allowed to be there.</p>\n  <p>This is OAuth 2.0's limitation: an access token proves authorization but doesn't reliably communicate identity. Enter <strong>OpenID Connect (OIDC)</strong>.</p>\n  <p><strong>OpenID Connect is an authentication layer built on top of OAuth 2.0.</strong> It extends OAuth 2.0 by adding standardized identity information through ID tokens and standard claims.</p>\n</div>\n\n<div class=\"concept-section\">\n  <h3>What OpenID Connect Adds to OAuth 2.0</h3>\n  <ul>\n    <li>‚úÖ <strong>ID Token:</strong> A new token type containing user identity information</li>\n    <li>‚úÖ <strong>UserInfo endpoint:</strong> Standardized API to get user profile data</li>\n    <li>‚úÖ <strong>Standard scopes:</strong> openid, profile, email for requesting user data</li>\n    <li>‚úÖ <strong>Standard claims:</strong> Agreed-upon fields for user attributes (sub, name, email, etc.)</li>\n  </ul>\n  <p>OpenID Connect uses the same grant types as OAuth 2.0 but adds the <code>openid</code> scope to trigger authentication.</p>\n</div>\n\n<div class=\"concept-section\">\n  <h3>ID Token vs Access Token: The Critical Distinction</h3>\n  <div style=\"display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;\">\n    <div style=\"background: #e3f2fd; padding: 20px; border-radius: 10px;\">\n      <h4>ID Token</h4>\n      <ul>\n        <li><strong>Purpose:</strong> Prove user identity</li>\n        <li><strong>Audience:</strong> Your application (the client)</li>\n        <li><strong>Format:</strong> Always JWT</li>\n        <li><strong>Contains:</strong> User identity claims</li>\n        <li><strong>Usage:</strong> Read once to authenticate user</li>\n        <li><strong>Lifetime:</strong> Short (minutes to hours)</li>\n        <li>‚ö†Ô∏è <strong>Never send to APIs</strong></li>\n      </ul>\n    </div>\n    <div style=\"background: #e8f5e8; padding: 20px; border-radius: 10px;\">\n      <h4>Access Token</h4>\n      <ul>\n        <li><strong>Purpose:</strong> Authorize API access</li>\n        <li><strong>Audience:</strong> Resource servers (APIs)</li>\n        <li><strong>Format:</strong> JWT or opaque string</li>\n        <li><strong>Contains:</strong> Permissions/scopes</li>\n        <li><strong>Usage:</strong> Send with every API request</li>\n        <li><strong>Lifetime:</strong> Short to medium</li>\n        <li>‚úÖ <strong>Include in Authorization header</strong></li>\n      </ul>\n    </div>\n  </div>\n  <p><strong>Key principle:</strong> ID tokens authenticate users to your app. Access tokens authorize your app to call APIs. Never confuse the two!</p>\n</div>\n\n<div class=\"concept-section\">\n  <h3>JWT: JSON Web Token Anatomy</h3>\n  <p>Both ID tokens and many access tokens use JWT format. A JWT has three Base64-encoded parts separated by dots:</p>\n  <div style=\"background: #f8f9fa; padding: 15px; border-radius: 10px; margin: 10px 0;\">\n    <p style=\"font-family: monospace; word-break: break-all; font-size: 12px; margin-bottom: 15px;\">\n      <span style=\"color: #d32f2f;\">eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImFiYzEyMyJ9</span>.<span style=\"color: #7b1fa2;\">eyJpc3MiOiJodHRwczovL2F1dGguZXhhbXBsZS5jb20iLCJzdWIiOiJ1c2VyMTIzIiwiYXVkIjoieW91ci1jbGllbnQtaWQiLCJleHAiOjE3MzU2ODk2MDAsImlhdCI6MTczNTY4NjAwMCwibmFtZSI6IkpvaG4gRG9lIiwiZW1haWwiOiJqb2huQGV4YW1wbGUuY29tIn0</span>.<span style=\"color: #1976d2;\">SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c</span>\n    </p>\n    <p><strong>Decoded structure:</strong></p>\n    <p style=\"font-family: monospace; font-size: 13px; line-height: 1.8;\">\n      <span style=\"color: #d32f2f;\"><strong>Header:</strong></span> { \"alg\": \"RS256\", \"typ\": \"JWT\", \"kid\": \"abc123\" }<br>\n      <span style=\"color: #7b1fa2;\"><strong>Payload:</strong></span> {<br>\n      &nbsp;&nbsp;\"iss\": \"https://auth.example.com\",&nbsp;&nbsp;// Issuer<br>\n      &nbsp;&nbsp;\"sub\": \"user123\",&nbsp;&nbsp;// Subject (user ID)<br>\n      &nbsp;&nbsp;\"aud\": \"your-client-id\",&nbsp;&nbsp;// Audience<br>\n      &nbsp;&nbsp;\"exp\": 1735689600,&nbsp;&nbsp;// Expiration timestamp<br>\n      &nbsp;&nbsp;\"iat\": 1735686000,&nbsp;&nbsp;// Issued at<br>\n      &nbsp;&nbsp;\"name\": \"John Doe\",<br>\n      &nbsp;&nbsp;\"email\": \"john@example.com\"<br>\n      }<br>\n      <span style=\"color: #1976d2;\"><strong>Signature:</strong></span> Cryptographic proof of authenticity\n    </p>\n  </div>\n  <p><strong>Critical point:</strong> The payload is Base64-encoded (readable by anyone), NOT encrypted. The signature ensures it hasn't been tampered with.</p>\n</div>\n\n<div class=\"concept-section\">\n  <h3>JWK and JWKS: Verifying Token Signatures</h3>\n  <p>When your application receives a JWT, you verify the signature using the issuer's public key. This is where JWK (JSON Web Key) and JWKS (JSON Web Key Set) come in.</p>\n  <p><strong>The verification flow:</strong></p>\n  <ol>\n    <li>Decode JWT header to get the <code>kid</code> (key ID)</li>\n    <li>Fetch JWKS from authorization server's <code>/.well-known/jwks.json</code> endpoint</li>\n    <li>Find the JWK with matching <code>kid</code></li>\n    <li>Use that public key to verify the JWT signature</li>\n    <li>If signature is valid, trust the token's claims</li>\n  </ol>\n  <div style=\"background: #f8f9fa; padding: 10px; font-family: monospace; margin: 10px 0; font-size: 13px;\">\n    Example JWKS endpoint response:<br>\n    {<br>\n    &nbsp;&nbsp;\"keys\": [<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;{<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"kty\": \"RSA\",&nbsp;&nbsp;// Key type<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"kid\": \"abc123\",&nbsp;&nbsp;// Key ID (matches JWT header)<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"use\": \"sig\",&nbsp;&nbsp;// Usage: signature verification<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"n\": \"0vx7ago...\",&nbsp;&nbsp;// RSA modulus<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"e\": \"AQAB\"&nbsp;&nbsp;// RSA exponent<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;}<br>\n    &nbsp;&nbsp;]<br>\n    }\n  </div>\n  <p>Authorization servers rotate keys periodically for security, which is why the <code>kid</code> field is crucial.</p>\n</div>\n\n<div class=\"concept-section\">\n  <h3>Token Validation Checklist</h3>\n  <p>When you receive a JWT (especially an ID token), you must validate:</p>\n  <ul>\n    <li>‚úÖ <strong>Signature:</strong> Verify using public key from JWKS</li>\n    <li>‚úÖ <strong>Issuer (iss):</strong> Matches expected authorization server</li>\n    <li>‚úÖ <strong>Audience (aud):</strong> Matches your client_id</li>\n    <li>‚úÖ <strong>Expiration (exp):</strong> Token hasn't expired</li>\n    <li>‚úÖ <strong>Issued at (iat):</strong> Token is reasonably recent</li>\n    <li>‚úÖ <strong>Nonce:</strong> Matches expected value (prevents replay attacks)</li>\n  </ul>\n  <p><strong>Never skip validation!</strong> Libraries like Spring Security, Auth0 SDK, and passport.js handle this automatically.</p>\n</div>\n\n<div class=\"concept-section\">\n  <h3>When You Need OAuth Only vs When You Need OIDC</h3>\n  <div style=\"display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;\">\n    <div style=\"background: #e8f5e8; padding: 20px; border-radius: 10px;\">\n      <h4>Use OAuth 2.0 Only</h4>\n      <ul>\n        <li>Machine-to-machine communication</li>\n        <li>Third-party access to your API</li>\n        <li>You don't care who the user is</li>\n        <li>You only need permissions/scopes</li>\n      </ul>\n      <p><strong>Example:</strong> GitHub app accessing repository data</p>\n    </div>\n    <div style=\"background: #e3f2fd; padding: 20px; border-radius: 10px;\">\n      <h4>Use OpenID Connect</h4>\n      <ul>\n        <li>User login and authentication</li>\n        <li>Single sign-on (SSO)</li>\n        <li>You need to know user identity</li>\n        <li>You need user profile data</li>\n      </ul>\n      <p><strong>Example:</strong> \"Sign in with Google\" on your web app</p>\n    </div>\n  </div>\n</div>\n\n<div class=\"concept-section\">\n  <h3>Common JWT/OIDC Mistakes to Avoid</h3>\n  <div style=\"background: #ffebee; padding: 20px; border-radius: 10px; margin: 20px 0;\">\n    <ul>\n      <li>‚ùå <strong>Storing sensitive data in JWT payload:</strong> It's Base64-encoded, not encrypted‚Äîanyone can read it</li>\n      <li>‚ùå <strong>Using ID token to call APIs:</strong> Always use access tokens for API authorization</li>\n      <li>‚ùå <strong>Skipping signature verification:</strong> Anyone can create a JWT with fake claims if you don't verify</li>\n    </ul>\n  </div>\n</div>\n\n<div class=\"exercise\">\n  <h3>üõ†Ô∏è Decode and Validate a JWT</h3>\n  <p><strong>Scenario:</strong> Your application receives this ID token after a user logs in via OpenID Connect. The current timestamp is 1735686500.</p>\n  <div style=\"background: #f8f9fa; padding: 10px; font-family: monospace; font-size: 12px; margin: 10px 0; word-break: break-all;\">\n    eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImFiYzEyMyJ9.eyJpc3MiOiJodHRwczovL2F1dGguZXhhbXBsZS5jb20iLCJzdWIiOiJ1c2VyMTIzIiwiYXVkIjoieW91ci1jbGllbnQtaWQiLCJleHAiOjE3MzU2ODk2MDAsImlhdCI6MTczNTY4NjAwMCwibm9uY2UiOiJyYW5kb20xMjMiLCJuYW1lIjoiSm9obiBEb2UiLCJlbWFpbCI6ImpvaG5AZXhhbXBsZS5jb20iLCJlbWFpbF92ZXJpZmllZCI6dHJ1ZX0.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\n  </div>\n  <p><strong>Your task:</strong></p>\n  <ol>\n    <li>Use <a href=\"https://jwt.io\" target=\"_blank\" rel=\"noopener noreferrer\">jwt.io</a> to decode the token and examine its parts</li>\n    <li>Identify which claims are standard OIDC claims vs custom claims</li>\n    <li>List all validation checks you would perform and whether this token passes each check</li>\n    <li>Explain what the <code>kid</code> field is used for and why it's important</li>\n    <li>Would you send this token when calling your backend API? Why or why not?</li>\n  </ol>\n  <p><strong>Consider:</strong> What would happen if an attacker modified the email claim in the payload? How would you detect this tampering?</p>\n</div>"
    },
    {
      "id": 4,
      "title": "Token Management: Security, Storage, and Refresh Strategies",
      "goals": [
        "Master the distinction between access tokens and refresh tokens",
        "Learn secure token storage strategies for different client types",
        "Understand token rotation and revocation patterns",
        "Implement the Backend-for-Frontend pattern for enhanced security"
      ],
      "content": "<div class=\"concept-section\">\n  <h3>The Token Lifecycle Problem</h3>\n  <p>Imagine you're issued a driver's license valid for 10 years. If stolen, the thief can impersonate you for a decade. Now imagine instead you carry a temporary daily pass, and you can request a new one from the DMV by showing your long-term credential that stays safely locked at home. If your daily pass is stolen, the damage window is just hours, not years.</p>\n  <p>This is the philosophy behind <strong>access tokens and refresh tokens</strong> in OAuth 2.0/OIDC systems.</p>\n</div>\n\n<div class=\"concept-section\">\n  <h3>Access Token vs Refresh Token</h3>\n  <div style=\"display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;\">\n    <div style=\"background: #e3f2fd; padding: 20px; border-radius: 10px;\">\n      <h4>Access Token</h4>\n      <ul>\n        <li><strong>Purpose:</strong> Short-term API access</li>\n        <li><strong>Lifetime:</strong> 15-60 minutes typically</li>\n        <li><strong>Sent to:</strong> Resource servers with every request</li>\n        <li><strong>Exposure risk:</strong> High (sent frequently)</li>\n        <li><strong>If stolen:</strong> Limited damage window</li>\n        <li><strong>Revocation:</strong> Difficult before expiration</li>\n      </ul>\n    </div>\n    <div style=\"background: #e8f5e8; padding: 20px; border-radius: 10px;\">\n      <h4>Refresh Token</h4>\n      <ul>\n        <li><strong>Purpose:</strong> Obtain new access tokens</li>\n        <li><strong>Lifetime:</strong> Days to months</li>\n        <li><strong>Sent to:</strong> Authorization server only</li>\n        <li><strong>Exposure risk:</strong> Lower (used rarely)</li>\n        <li><strong>If stolen:</strong> Can cause sustained damage</li>\n        <li><strong>Revocation:</strong> Can be revoked immediately</li>\n      </ul>\n    </div>\n  </div>\n  <p><strong>Design principle:</strong> Short-lived access tokens limit damage from theft. Long-lived refresh tokens enable seamless UX without constant re-authentication.</p>\n</div>\n\n<div class=\"concept-section\">\n  <h3>The Refresh Token Flow</h3>\n  <p>When an access token expires, the client uses the refresh token to get a new one without user interaction:</p>\n  <div style=\"background: #f8f9fa; padding: 10px; font-family: monospace; font-size: 14px; margin: 10px 0; line-height: 1.6;\">\n    1. Client calls API with access token<br>\n    2. API returns 401 Unauthorized (token expired)<br>\n    3. Client sends refresh token to auth server:<br>\n    &nbsp;&nbsp;POST /token<br>\n    &nbsp;&nbsp;grant_type=refresh_token<br>\n    &nbsp;&nbsp;refresh_token=REFRESH_TOKEN_HERE<br>\n    <br>\n    4. Auth server validates and returns:<br>\n    &nbsp;&nbsp;{<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;\"access_token\": \"new_token\",<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;\"refresh_token\": \"new_refresh_token\",&nbsp;&nbsp;‚Üê May rotate<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;\"expires_in\": 3600<br>\n    &nbsp;&nbsp;}<br>\n    <br>\n    5. Client retries API call with new access token\n  </div>\n</div>\n\n<div class=\"concept-section\">\n  <h3>Token Storage: Security Trade-offs</h3>\n  <p>Where you store tokens depends on your client type and acceptable risk level.</p>\n  <h4>Web Application Storage Options</h4>\n  <div style=\"display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;\">\n    <div style=\"background: #ffebee; padding: 20px; border-radius: 10px;\">\n      <h5>‚ùå Insecure Storage</h5>\n      <p><strong>localStorage / sessionStorage / Regular Cookies</strong></p>\n      <ul>\n        <li>Vulnerable to XSS attacks</li>\n        <li>Accessible to JavaScript</li>\n        <li>Can be stolen by malicious scripts</li>\n      </ul>\n      <p><strong>Verdict:</strong> Avoid for sensitive tokens</p>\n    </div>\n    <div style=\"background: #e8f5e8; padding: 20px; border-radius: 10px;\">\n      <h5>‚úÖ Secure Storage</h5>\n      <p><strong>HttpOnly + Secure + SameSite Cookies</strong></p>\n      <ul>\n        <li>Not accessible to JavaScript</li>\n        <li>Secure flag ensures HTTPS only</li>\n        <li>SameSite prevents CSRF attacks</li>\n        <li>Requires backend to set cookies</li>\n      </ul>\n      <p><strong>Verdict:</strong> Best practice for web apps</p>\n    </div>\n  </div>\n</div>\n\n<div class=\"concept-section\">\n  <h4>Mobile Application Storage</h4>\n  <ul>\n    <li>‚úÖ <strong>iOS Keychain:</strong> Encrypted, OS-level secure storage (recommended)</li>\n    <li>‚úÖ <strong>Android Keystore:</strong> Hardware-backed encryption (recommended)</li>\n    <li>‚ùå <strong>Plain text storage:</strong> Never store tokens unencrypted</li>\n  </ul>\n</div>\n\n<div class=\"concept-section\">\n  <h3>Understanding XSS vs CSRF Vulnerabilities</h3>\n  <div style=\"background: #f8f9fa; padding: 20px; border-radius: 10px; margin: 20px 0;\">\n    <p><strong>XSS (Cross-Site Scripting):</strong> Attacker injects malicious JavaScript that steals tokens from localStorage or cookies</p>\n    <p><strong>CSRF (Cross-Site Request Forgery):</strong> Attacker tricks browser into sending authenticated requests using your cookies</p>\n    <br>\n    <table style=\"width: 100%; border-collapse: collapse;\">\n      <tr style=\"background: #e0e0e0;\">\n        <th style=\"padding: 10px; text-align: left;\">Storage Method</th>\n        <th style=\"padding: 10px; text-align: center;\">XSS Risk</th>\n        <th style=\"padding: 10px; text-align: center;\">CSRF Risk</th>\n      </tr>\n      <tr>\n        <td style=\"padding: 10px; border-bottom: 1px solid #ccc;\">localStorage</td>\n        <td style=\"padding: 10px; border-bottom: 1px solid #ccc; text-align: center;\">‚ùå High</td>\n        <td style=\"padding: 10px; border-bottom: 1px solid #ccc; text-align: center;\">‚úÖ None</td>\n      </tr>\n      <tr>\n        <td style=\"padding: 10px; border-bottom: 1px solid #ccc;\">Regular Cookie</td>\n        <td style=\"padding: 10px; border-bottom: 1px solid #ccc; text-align: center;\">‚ùå High</td>\n        <td style=\"padding: 10px; border-bottom: 1px solid #ccc; text-align: center;\">‚ùå High</td>\n      </tr>\n      <tr>\n        <td style=\"padding: 10px; border-bottom: 1px solid #ccc;\">HttpOnly Cookie</td>\n        <td style=\"padding: 10px; border-bottom: 1px solid #ccc; text-align: center;\">‚úÖ Protected</td>\n        <td style=\"padding: 10px; border-bottom: 1px solid #ccc; text-align: center;\">‚ö†Ô∏è Medium</td>\n      </tr>\n      <tr>\n        <td style=\"padding: 10px;\">HttpOnly + SameSite Cookie</td>\n        <td style=\"padding: 10px; text-align: center;\">‚úÖ Protected</td>\n        <td style=\"padding: 10px; text-align: center;\">‚úÖ Protected</td>\n      </tr>\n    </table>\n  </div>\n</div>\n\n<div class=\"concept-section\">\n  <h3>Refresh Token Rotation</h3>\n  <p>Modern security best practice: issue a new refresh token every time it's used, and invalidate the old one.</p>\n  <ul>\n    <li>‚úÖ <strong>Limits damage:</strong> Stolen refresh token becomes useless after next legitimate use</li>\n    <li>‚úÖ <strong>Detects theft:</strong> If old refresh token is reused, indicates compromise</li>\n    <li>‚úÖ <strong>Automatic revocation:</strong> System can revoke entire token family on suspicious activity</li>\n  </ul>\n  <p><strong>Implementation:</strong> When rotation is enabled, each refresh request returns both a new access token AND a new refresh token. Store the new refresh token and discard the old one.</p>\n</div>\n\n<div class=\"concept-section\">\n  <h3>Backend-for-Frontend (BFF) Pattern</h3>\n  <p>For maximum security in single-page applications, introduce a lightweight backend proxy that handles all token operations.</p>\n  <div style=\"background: #e3f2fd; padding: 20px; border-radius: 10px; margin: 20px 0;\">\n    <h4>How BFF Works:</h4>\n    <ol>\n      <li>Frontend never sees or stores tokens</li>\n      <li>BFF backend performs OAuth/OIDC flow and gets tokens</li>\n      <li>BFF stores refresh token securely server-side</li>\n      <li>BFF issues session cookie to frontend (HttpOnly, Secure, SameSite)</li>\n      <li>Frontend sends session cookie with API requests</li>\n      <li>BFF validates session, attaches access token to upstream API calls</li>\n      <li>BFF handles token refresh transparently</li>\n    </ol>\n  </div>\n  <p><strong>Benefits:</strong> Tokens never exposed to browser, eliminates XSS risk, simplifies frontend code</p>\n  <p><strong>Trade-off:</strong> Adds infrastructure complexity and a network hop</p>\n</div>\n\n<div class=\"concept-section\">\n  <h3>Token Expiration Strategies</h3>\n  <div style=\"display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;\">\n    <div style=\"background: #fff3e0; padding: 20px; border-radius: 10px;\">\n      <h4>Short-lived Access Tokens</h4>\n      <p><strong>15-60 minutes</strong></p>\n      <ul>\n        <li>‚úÖ Minimizes impact of token theft</li>\n        <li>‚úÖ Limits unauthorized access window</li>\n        <li>‚ö†Ô∏è Requires refresh token handling</li>\n      </ul>\n      <p><strong>Use for:</strong> Most applications with sensitive data</p>\n    </div>\n    <div style=\"background: #e8f5e8; padding: 20px; border-radius: 10px;\">\n      <h4>Long-lived Refresh Tokens</h4>\n      <p><strong>7-90 days or until revoked</strong></p>\n      <ul>\n        <li>‚úÖ Better user experience (stay logged in)</li>\n        <li>‚úÖ Reduces authentication friction</li>\n        <li>‚ö†Ô∏è Must be stored very securely</li>\n      </ul>\n      <p><strong>Use for:</strong> Balancing security with UX, with rotation enabled</p>\n    </div>\n  </div>\n</div>\n\n<div class=\"concept-section\">\n  <h3>Token Revocation</h3>\n  <p>Sometimes you need to immediately invalidate tokens (user logs out, security breach, permission changes):</p>\n  <ul>\n    <li><strong>Refresh token revocation:</strong> Call authorization server's revocation endpoint to invalidate refresh token</li>\n    <li><strong>Access token revocation:</strong> Difficult since they're typically stateless. Options include:\n      <ul>\n        <li>Maintain a deny-list of revoked tokens (adds state)</li>\n        <li>Keep access tokens very short-lived</li>\n        <li>Use opaque tokens that require server lookup</li>\n      </ul>\n    </li>\n    <li><strong>Session revocation:</strong> In BFF pattern, simply delete server-side session</li>\n  </ul>\n</div>\n\n<div class=\"exercise\">\n  <h3>üõ†Ô∏è Design a Secure Token Strategy</h3>\n  <p><strong>Scenario:</strong> You're architecting authentication for three different applications:</p>\n  <ol>\n    <li><strong>Public web app:</strong> E-commerce site accessible to anyone, handles payment information</li>\n    <li><strong>Internal admin dashboard:</strong> React SPA used by 50 employees, manages sensitive customer data</li>\n    <li><strong>Mobile banking app:</strong> Native iOS/Android app with very high security requirements</li>\n  </ol>\n  <p><strong>Your task:</strong> For each application, specify:</p>\n  <ul>\n    <li>Where and how you'd store access tokens and refresh tokens</li>\n    <li>What token expiration times you'd use and why</li>\n    <li>Whether you'd implement token rotation</li>\n    <li>Whether you'd use the BFF pattern</li>\n    <li>Your strategy for handling token revocation</li>\n  </ul>\n  <p><strong>Consider:</strong> How do the security requirements differ between public users, employees, and banking customers? What's the acceptable trade-off between security and user experience for each?</p>\n</div>"
    },
  {
    "id": 5,
    "title": "Real-World Implementations: Security Patterns in Production",
    "goals": [
      "Learn from real-world authentication implementations at major platforms",
      "Understand zero-trust architecture principles in practice",
      "Master API gateway authentication patterns and service-to-service auth",
      "Identify common security vulnerabilities and prevention strategies"
    ],
    "content": "<div class=\"concept-section\">\n  <h3>Real-World Authentication Architectures</h3>\n  <p>Let's examine how companies implement OAuth 2.0 and OpenID Connect in production systems, the challenges they faced, and the patterns that emerged.</p>\n</div>\n\n<div class=\"concept-section\">\n  <h3>Case Study 1: Netflix - Zero Trust and Service Authentication</h3>\n  <p>Netflix operates one of the world's largest microservices architectures with hundreds of services handling billions of requests daily. Their approach demonstrates zero-trust principles at scale.</p>\n  <p><strong>Key architectural decisions:</strong></p>\n  <ul>\n    <li><strong>User authentication:</strong> OAuth 2.0 with device-specific tokens for smart TVs, mobile apps, and web browsers</li>\n    <li><strong>Service-to-service auth:</strong> Mutual TLS (mTLS) where every service authenticates using X.509 certificates</li>\n    <li><strong>Token strategy:</strong> Short-lived access tokens (minutes) with automatic renewal</li>\n    <li><strong>Zero-trust model:</strong> Every service call authenticated‚Äîno trusted internal network</li>\n  </ul>\n  <p><strong>Implementation highlights:</strong></p>\n  <ul>\n    <li>Edge gateway handles user authentication and authorization</li>\n    <li>Services use certificate-based authentication for internal communication</li>\n    <li>Service mesh (Envoy proxy) simplifies mTLS implementation across services</li>\n    <li>Comprehensive audit logging for all authentication events</li>\n  </ul>\n  <p><strong>Key lessons:</strong> Device-specific tokens enable granular revocation, certificate rotation must be automated at scale, service mesh significantly reduces implementation complexity.</p>\n  <p><a href=\"https://netflixtechblog.com/edge-authentication-and-token-agnostic-identity-propagation-514e47e0b602\" target=\"_blank\" rel=\"noopener noreferrer\">Netflix Tech Blog: Edge Authentication and Token-Agnostic Identity Propagation</a></p>\n</div>\n\n<div class=\"concept-section\">\n  <h3>Case Study 2: Spotify - OAuth 2.0 for Third-Party Integration</h3>\n  <p>Spotify provides OAuth 2.0 implementation allowing third-party developers to build apps that access user playlists, playback control, and listening history.</p>\n  <p><strong>Key architectural decisions:</strong></p>\n  <ul>\n    <li><strong>Grant types:</strong> Authorization Code with PKCE for web/mobile apps, Client Credentials for server-to-server</li>\n    <li><strong>Scope design:</strong> Granular scopes (user-read-private, playlist-modify-public) allowing fine-grained permissions</li>\n    <li><strong>Token management:</strong> 1-hour access tokens, refresh tokens valid until revoked with rotation enabled</li>\n    <li><strong>Security measures:</strong> PKCE required for mobile/SPA apps, strict redirect URI validation, state parameter mandatory</li>\n  </ul>\n  <p><strong>Key lessons:</strong> Granular scopes give users confidence and control, clear consent screens reduce friction, PKCE is essential for mobile apps (eliminates client secret requirement).</p>\n  <p><a href=\"https://developer.spotify.com/documentation/web-api/concepts/authorization\" target=\"_blank\" rel=\"noopener noreferrer\">Spotify Developer Documentation: Authorization Guide</a></p>\n</div>\n\n<div class=\"concept-section\">\n  <h3>API Gateway Authentication Patterns</h3>\n  <p>API gateways serve as the authentication enforcement point in microservices architectures:</p>\n  <div style=\"display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;\">\n    <div style=\"background: #fff3e0; padding: 20px; border-radius: 10px;\">\n      <h4>Token Validation at Gateway</h4>\n      <ul>\n        <li>Gateway validates JWT using JWKS</li>\n        <li>Checks expiration and claims</li>\n        <li>Forwards identity in headers to services</li>\n      </ul>\n      <p><strong>Use when:</strong> Services trust the gateway</p>\n    </div>\n    <div style=\"background: #e8f5e8; padding: 20px; border-radius: 10px;\">\n      <h4>Token Propagation</h4>\n      <ul>\n        <li>Gateway validates token</li>\n        <li>Passes original token to services</li>\n        <li>Services independently validate</li>\n      </ul>\n      <p><strong>Use when:</strong> Zero-trust architecture</p>\n    </div>\n  </div>\n</div>\n\n<div class=\"concept-section\">\n  <h3>Service-to-Service Authentication Patterns</h3>\n  <p>Internal service communication requires its own authentication:</p>\n  <ul>\n    <li><strong>OAuth 2.0 Client Credentials:</strong> Service gets token from auth server\n      <ul>\n        <li>‚úÖ Standardized, works across organizations</li>\n        <li>‚ö†Ô∏è Adds latency for token acquisition</li>\n      </ul>\n    </li>\n    <li><strong>Mutual TLS (mTLS):</strong> Services authenticate using certificates\n      <ul>\n        <li>‚úÖ No token acquisition latency, strong cryptographic identity</li>\n        <li>‚ö†Ô∏è Certificate management complexity</li>\n      </ul>\n    </li>\n    <li><strong>Service Mesh:</strong> Sidecar proxies handle authentication transparently\n      <ul>\n        <li>‚úÖ External to application code, automatic mTLS and certificate rotation</li>\n        <li>‚ö†Ô∏è Infrastructure complexity</li>\n      </ul>\n    </li>\n  </ul>\n</div>\n\n<div class=\"concept-section\">\n  <h3>Zero-Trust Architecture Principles</h3>\n  <p>Zero-trust means \"never trust, always verify\"‚Äîno implicit trust based on network location.</p>\n  <p><strong>Core principles:</strong></p>\n  <ol>\n    <li><strong>Verify explicitly:</strong> Always authenticate based on all available data</li>\n    <li><strong>Least privilege:</strong> Limit access with Just-In-Time and Just-Enough-Access</li>\n    <li><strong>Assume breach:</strong> Minimize blast radius, segment access, verify encryption</li>\n  </ol>\n  <p><strong>In practice:</strong> Every service call requires authentication, network location provides no trust, continuous monitoring of authentication events, regular credential rotation.</p>\n</div>\n\n<div class=\"concept-section\">\n  <h3>Common Security Vulnerabilities and Prevention</h3>\n  <div style=\"background: #ffebee; padding: 20px; border-radius: 10px; margin: 20px 0;\">\n    <h4>‚ö†Ô∏è Critical Vulnerabilities to Prevent</h4>\n    <ul>\n      <li><strong>Token leakage in URLs:</strong> Never put tokens in query parameters (appear in logs)\n        <ul><li>‚úÖ Use POST requests, put tokens in headers or body</li></ul>\n      </li>\n      <li><strong>Open redirect vulnerabilities:</strong> Attackers manipulate redirect_uri to steal codes\n        <ul><li>‚úÖ Whitelist exact redirect URIs, never allow wildcards</li></ul>\n      </li>\n      <li><strong>Missing state validation:</strong> CSRF attacks trick users into authorizing attackers\n        <ul><li>‚úÖ Generate cryptographically random state, validate on callback</li></ul>\n      </li>\n      <li><strong>Token replay attacks:</strong> Stolen tokens reused by attackers\n        <ul><li>‚úÖ Short token lifetimes, nonce validation, token binding</li></ul>\n      </li>\n    </ul>\n  </div>\n</div>\n\n<div class=\"concept-section\">\n  <h3>Security Best Practices Checklist</h3>\n  <ul>\n    <li>‚úÖ Always use HTTPS for all authentication endpoints and API calls</li>\n    <li>‚úÖ Implement PKCE for all mobile and single-page applications</li>\n    <li>‚úÖ Use HttpOnly, Secure, SameSite cookies for web applications</li>\n    <li>‚úÖ Validate JWT signatures and all claims (issuer, audience, expiration)</li>\n    <li>‚úÖ Implement refresh token rotation to limit damage from token theft</li>\n    <li>‚úÖ Use granular scopes and request minimum necessary permissions</li>\n    <li>‚úÖ Log authentication events for audit and anomaly detection</li>\n    <li>‚úÖ Implement rate limiting to prevent brute force attacks</li>\n  </ul>\n</div>\n\n<div class=\"exercise\">\n  <h3>üõ†Ô∏è Design a Complete Authentication Architecture</h3>\n  <p><strong>Scenario:</strong> You're designing authentication for a fintech platform with these components:</p>\n  <ul>\n    <li><strong>Public API:</strong> Third-party apps can read transaction history and initiate transfers</li>\n    <li><strong>Web application:</strong> React SPA for account management</li>\n    <li><strong>Mobile apps:</strong> iOS and Android native apps</li>\n    <li><strong>Internal microservices:</strong> 15 services (account, transaction, fraud-detection, notification, etc.)</li>\n    <li><strong>Admin dashboard:</strong> Internal tool for customer support</li>\n  </ul>\n  <p><strong>Your task:</strong> Design a complete authentication architecture specifying:</p>\n  <ol>\n    <li>Which OAuth/OIDC flows to use for each client type</li>\n    <li>Token storage strategies for web and mobile clients</li>\n    <li>Service-to-service authentication approach</li>\n    <li>API gateway authentication pattern</li>\n    <li>Token expiration and rotation policies</li>\n    <li>Security measures to prevent the vulnerabilities discussed</li>\n  </ol>\n  <p><strong>Consider:</strong> What would be your defense-in-depth strategy if one security layer is compromised? How would you handle credential rotation at scale?</p>\n</div>\n\n<div class=\"concept-section\">\n  <h3>üéâ Authentication & Authorization Mastery Complete!</h3>\n  <p>You've now mastered:</p>\n  <ul>\n    <li>‚úÖ The fundamental difference between authentication and authorization</li>\n    <li>‚úÖ OAuth 2.0 grant types and when to use each</li>\n    <li>‚úÖ OpenID Connect and JWT structure, validation, and verification</li>\n    <li>‚úÖ Secure token storage and management strategies</li>\n    <li>‚úÖ Real-world implementation patterns from production systems</li>\n  </ul>\n  <p><strong>Next steps:</strong> Implement OAuth 2.0/OIDC in a sample project, explore authorization frameworks like Keycloak or Auth0, or dive deeper into advanced topics like token introspection, dynamic client registration, and OAuth 2.1 updates.</p>\n</div>"
  },
  {
    "id": 6,
    "title": "Authentication & Authorization Knowledge Check",
    "goals": [
      "Test your understanding of authentication vs authorization fundamentals",
      "Evaluate your knowledge of OAuth 2.0 grant types and OpenID Connect",
      "Assess your grasp of JWT structure, token management, and security practices"
    ],
    "content": "<div class=\"concept-section\">\n  <h3>üß† Test Your Authentication & Authorization Mastery</h3>\n  <p>Time to validate your knowledge! This quiz covers key concepts from all 5 lessons. Select all correct answers for each question, then click \"Reveal Answers\" to see how you did.</p>\n  <p><strong>Instructions:</strong> Multiple answers may be correct for each question. Check all that apply!</p>\n</div>\n\n<div class=\"quiz-container\" style=\"margin: 20px 0;\">\n  <div class=\"quiz-question\" style=\"background: #f8f9fa; padding: 20px; margin: 15px 0; border-radius: 10px; border-left: 4px solid #007bff;\">\n    <h4>Question 1: Authentication vs Authorization (Lesson 1)</h4>\n    <p><strong>Which statements correctly describe the difference between authentication and authorization?</strong></p>\n    <div class=\"quiz-options\">\n      <label><input type=\"checkbox\" data-question=\"1\" data-correct=\"true\"> Authentication proves who you are, authorization determines what you can do</label><br>\n      <label><input type=\"checkbox\" data-question=\"1\" data-correct=\"false\"> Authentication and authorization are the same thing in OAuth 2.0</label><br>\n      <label><input type=\"checkbox\" data-question=\"1\" data-correct=\"true\"> In microservices, every service call crosses a trust boundary requiring authentication</label><br>\n      <label><input type=\"checkbox\" data-question=\"1\" data-correct=\"true\"> Session-based authentication doesn't scale well in distributed systems</label><br>\n      <label><input type=\"checkbox\" data-question=\"1\" data-correct=\"false\"> Authorization happens before authentication in secure systems</label>\n    </div>\n  </div>\n\n  <div class=\"quiz-question\" style=\"background: #f8f9fa; padding: 20px; margin: 15px 0; border-radius: 10px; border-left: 4px solid #28a745;\">\n    <h4>Question 2: OAuth 2.0 Grant Types (Lesson 2)</h4>\n    <p><strong>When should you use the Authorization Code grant type?</strong></p>\n    <div class=\"quiz-options\">\n      <label><input type=\"checkbox\" data-question=\"2\" data-correct=\"true\"> When you have a backend server that can securely store client_secret</label><br>\n      <label><input type=\"checkbox\" data-question=\"2\" data-correct=\"false\"> For machine-to-machine communication with no user involved</label><br>\n      <label><input type=\"checkbox\" data-question=\"2\" data-correct=\"true\"> When building a web application with user login</label><br>\n      <label><input type=\"checkbox\" data-question=\"2\" data-correct=\"true\"> For mobile apps when combined with PKCE</label><br>\n      <label><input type=\"checkbox\" data-question=\"2\" data-correct=\"false\"> When you want the access token exposed in the browser URL</label>\n    </div>\n  </div>\n\n  <div class=\"quiz-question\" style=\"background: #f8f9fa; padding: 20px; margin: 15px 0; border-radius: 10px; border-left: 4px solid #ffc107;\">\n    <h4>Question 3: OAuth 2.0 vs OpenID Connect (Lesson 2 & 3)</h4>\n    <p><strong>What does OpenID Connect add to OAuth 2.0?</strong></p>\n    <div class=\"quiz-options\">\n      <label><input type=\"checkbox\" data-question=\"3\" data-correct=\"true\"> ID token containing user identity information</label><br>\n      <label><input type=\"checkbox\" data-question=\"3\" data-correct=\"true\"> Standardized UserInfo endpoint for getting user profile data</label><br>\n      <label><input type=\"checkbox\" data-question=\"3\" data-correct=\"false\"> New grant types not available in OAuth 2.0</label><br>\n      <label><input type=\"checkbox\" data-question=\"3\" data-correct=\"true\"> Standard claims like sub, name, and email for user attributes</label><br>\n      <label><input type=\"checkbox\" data-question=\"3\" data-correct=\"false\"> Replacement for JWT tokens with a more secure format</label>\n    </div>\n  </div>\n\n  <div class=\"quiz-question\" style=\"background: #f8f9fa; padding: 20px; margin: 15px 0; border-radius: 10px; border-left: 4px solid #dc3545;\">\n    <h4>Question 4: ID Token vs Access Token (Lesson 3)</h4>\n    <p><strong>Which statements correctly describe ID tokens and access tokens?</strong></p>\n    <div class=\"quiz-options\">\n      <label><input type=\"checkbox\" data-question=\"4\" data-correct=\"true\"> ID tokens are meant for the client application to verify user identity</label><br>\n      <label><input type=\"checkbox\" data-question=\"4\" data-correct=\"false\"> ID tokens should be sent with every API request</label><br>\n      <label><input type=\"checkbox\" data-question=\"4\" data-correct=\"true\"> Access tokens are sent to resource servers to authorize API access</label><br>\n      <label><input type=\"checkbox\" data-question=\"4\" data-correct=\"true\"> ID tokens are always JWT format, while access tokens may be opaque</label><br>\n      <label><input type=\"checkbox\" data-question=\"4\" data-correct=\"false\"> You can use either token interchangeably for authentication or authorization</label>\n    </div>\n  </div>\n\n  <div class=\"quiz-question\" style=\"background: #f8f9fa; padding: 20px; margin: 15px 0; border-radius: 10px; border-left: 4px solid #6f42c1;\">\n    <h4>Question 5: JWT Structure and Validation (Lesson 3)</h4>\n    <p><strong>What must you validate when receiving a JWT?</strong></p>\n    <div class=\"quiz-options\">\n      <label><input type=\"checkbox\" data-question=\"5\" data-correct=\"true\"> Signature using public key from JWKS endpoint</label><br>\n      <label><input type=\"checkbox\" data-question=\"5\" data-correct=\"true\"> Issuer (iss) matches expected authorization server</label><br>\n      <label><input type=\"checkbox\" data-question=\"5\" data-correct=\"true\"> Audience (aud) matches your client_id</label><br>\n      <label><input type=\"checkbox\" data-question=\"5\" data-correct=\"true\"> Expiration (exp) to ensure token hasn't expired</label><br>\n      <label><input type=\"checkbox\" data-question=\"5\" data-correct=\"false\"> The payload is encrypted and cannot be read without the private key</label>\n    </div>\n  </div>\n\n  <div class=\"quiz-question\" style=\"background: #f8f9fa; padding: 20px; margin: 15px 0; border-radius: 10px; border-left: 4px solid #20c997;\">\n    <h4>Question 6: Token Storage Security (Lesson 4)</h4>\n    <p><strong>What are secure token storage strategies for web applications?</strong></p>\n    <div class=\"quiz-options\">\n      <label><input type=\"checkbox\" data-question=\"6\" data-correct=\"false\"> Store tokens in localStorage for easy access across tabs</label><br>\n      <label><input type=\"checkbox\" data-question=\"6\" data-correct=\"true\"> Use HttpOnly cookies to prevent JavaScript access</label><br>\n      <label><input type=\"checkbox\" data-question=\"6\" data-correct=\"true\"> Add Secure flag to ensure cookies only sent over HTTPS</label><br>\n      <label><input type=\"checkbox\" data-question=\"6\" data-correct=\"true\"> Use SameSite=Strict to prevent CSRF attacks</label><br>\n      <label><input type=\"checkbox\" data-question=\"6\" data-correct=\"false\"> Store refresh tokens in sessionStorage for automatic cleanup</label>\n    </div>\n  </div>\n\n  <div class=\"quiz-question\" style=\"background: #f8f9fa; padding: 20px; margin: 15px 0; border-radius: 10px; border-left: 4px solid #fd7e14;\">\n    <h4>Question 7: Refresh Token Strategy (Lesson 4)</h4>\n    <p><strong>What are the benefits of refresh token rotation?</strong></p>\n    <div class=\"quiz-options\">\n      <label><input type=\"checkbox\" data-question=\"7\" data-correct=\"true\"> Limits damage window if a refresh token is stolen</label><br>\n      <label><input type=\"checkbox\" data-question=\"7\" data-correct=\"true\"> Helps detect token theft when old refresh token is reused</label><br>\n      <label><input type=\"checkbox\" data-question=\"7\" data-correct=\"false\"> Eliminates the need for access tokens entirely</label><br>\n      <label><input type=\"checkbox\" data-question=\"7\" data-correct=\"true\"> Allows automatic revocation of entire token family on suspicious activity</label><br>\n      <label><input type=\"checkbox\" data-question=\"7\" data-correct=\"false\"> Makes tokens valid indefinitely without expiration</label>\n    </div>\n  </div>\n\n  <div class=\"quiz-question\" style=\"background: #f8f9fa; padding: 20px; margin: 15px 0; border-radius: 10px; border-left: 4px solid #e83e8c;\">\n    <h4>Question 8: Security Best Practices (Lesson 5)</h4>\n    <p><strong>Which security measures help prevent common authentication vulnerabilities?</strong></p>\n    <div class=\"quiz-options\">\n      <label><input type=\"checkbox\" data-question=\"8\" data-correct=\"true\"> Use PKCE for mobile and single-page applications</label><br>\n      <label><input type=\"checkbox\" data-question=\"8\" data-correct=\"true\"> Whitelist exact redirect URIs, never use wildcards</label><br>\n      <label><input type=\"checkbox\" data-question=\"8\" data-correct=\"true\"> Always validate the state parameter to prevent CSRF</label><br>\n      <label><input type=\"checkbox\" data-question=\"8\" data-correct=\"false\"> Put access tokens in URL query parameters for easy debugging</label><br>\n      <label><input type=\"checkbox\" data-question=\"8\" data-correct=\"true\"> Implement short token lifetimes to limit damage from token theft</label>\n    </div>\n  </div>\n\n  <div style=\"text-align: center; margin: 30px 0;\">\n    <button id=\"revealBtn\" onclick=\"revealAnswers()\" style=\"background: #007bff; color: white; padding: 15px 30px; border: none; border-radius: 5px; font-size: 16px; cursor: pointer; box-shadow: 0 2px 4px rgba(0,0,0,0.1);\">üéØ Reveal Answers & Show Score</button>\n  </div>\n\n  <div id=\"results\" style=\"display: none; background: #e8f5e8; padding: 20px; border-radius: 10px; margin: 20px 0;\">\n    <h3>üìä Your Results</h3>\n    <div id=\"score-display\"></div>\n    <div id=\"feedback\"></div>\n    <br>\n    <button onclick=\"retakeQuiz()\" style=\"background: #28a745; color: white; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer;\">üîÑ Retake Quiz</button>\n  </div>\n</div>\n\n<script>\nfunction revealAnswers() {\n  const questions = 8;\n  let correct = 0;\n  let total = 0;\n  \n  for (let q = 1; q <= questions; q++) {\n    const checkboxes = document.querySelectorAll(`input[data-question=\"${q}\"]`);\n    let questionCorrect = true;\n    \n    checkboxes.forEach(checkbox => {\n      total++;\n      const isCorrect = checkbox.getAttribute('data-correct') === 'true';\n      const isChecked = checkbox.checked;\n      \n      if (isCorrect && isChecked) {\n        checkbox.parentElement.style.background = '#c8e6c9';\n        correct++;\n      } else if (isCorrect && !isChecked) {\n        checkbox.parentElement.style.background = '#ffccbc';\n        questionCorrect = false;\n      } else if (!isCorrect && isChecked) {\n        checkbox.parentElement.style.background = '#ffccbc';\n        questionCorrect = false;\n      } else {\n        checkbox.parentElement.style.background = 'transparent';\n        correct++;\n      }\n      \n      checkbox.disabled = true;\n    });\n  }\n  \n  const percentage = Math.round((correct / total) * 100);\n  document.getElementById('score-display').innerHTML = `<h4>Score: ${correct}/${total} (${percentage}%)</h4>`;\n  \n  let feedback = '';\n  if (percentage >= 90) {\n    feedback = '<p><strong>Outstanding! üåü</strong> You have a strong grasp of authentication and authorization concepts. You\\'re ready to implement these patterns in production systems.</p>';\n  } else if (percentage >= 75) {\n    feedback = '<p><strong>Great job! üëç</strong> You understand the core concepts well. Review any questions you missed to strengthen your knowledge.</p>';\n  } else if (percentage >= 60) {\n    feedback = '<p><strong>Good effort! üìö</strong> You have a foundational understanding, but consider reviewing the lessons on topics where you missed questions.</p>';\n  } else {\n    feedback = '<p><strong>Keep learning! üí™</strong> Authentication and authorization are complex topics. Review the lessons and try the quiz again to reinforce your understanding.</p>';\n  }\n  \n  document.getElementById('feedback').innerHTML = feedback;\n  document.getElementById('results').style.display = 'block';\n  document.getElementById('revealBtn').style.display = 'none';\n}\n\nfunction retakeQuiz() {\n  const checkboxes = document.querySelectorAll('input[type=\"checkbox\"]');\n  checkboxes.forEach(checkbox => {\n    checkbox.checked = false;\n    checkbox.disabled = false;\n    checkbox.parentElement.style.background = 'transparent';\n  });\n  \n  document.getElementById('results').style.display = 'none';\n  document.getElementById('revealBtn').style.display = 'inline-block';\n  window.scrollTo({ top: 0, behavior: 'smooth' });\n}\n</script>\n\n<div class\"concept-section\" style=\"margin-top: 40px;\">\n  <h3>üéâ Authentication & Authorization Journey Complete!</h3>\n  <p>Congratulations! You've completed the comprehensive Authentication & Authorization Mastery learning journey. You now have the knowledge to:</p>\n  <ul>\n    <li>‚úÖ Distinguish between authentication and authorization in distributed systems</li>\n    <li>‚úÖ Choose and implement the appropriate OAuth 2.0 grant types for different scenarios</li>\n    <li>‚úÖ Understand OpenID Connect and use JWT tokens correctly and securely</li>\n    <li>‚úÖ Implement secure token storage and management strategies</li>\n    <li>‚úÖ Apply real-world security patterns and prevent common vulnerabilities</li>\n  </ul>\n  <p><strong>Next steps:</strong> Implement OAuth 2.0/OIDC in a sample project using Spring Security OAuth2, explore identity providers like Auth0, Okta, or Keycloak, or dive into advanced topics like token introspection, dynamic client registration, and the OAuth 2.1 specification updates.</p>\n</div>"
  }
  ]
}