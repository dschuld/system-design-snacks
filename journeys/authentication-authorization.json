{
  "id": "authentication-authorization",
  "title": "Authentication & Authorization Mastery",
  "totalLessons": 6,
  "available": true,
  "lessons": [
    {
      "id": 1,
      "title": "Why Do We Need Authentication & Authorization Patterns?",
      "goals": [
        "Understand the fundamental difference between authentication and authorization",
        "Identify security challenges unique to distributed systems and microservices",
        "Recognize why traditional session-based authentication doesn't scale"
      ],
      "content": "<div class=\"concept-section\">\n  <h3>The Two Pillars of Security</h3>\n  <p>Imagine a hotel with hundreds of rooms. When you check in, the front desk verifies your identity by checking your ID‚Äîthat's <strong>authentication</strong>. They then hand you a key card programmed to open only your room and the gym‚Äîthat's <strong>authorization</strong>. You might be authenticated (the hotel knows who you are), but you're not authorized to access the presidential suite or the staff area.</p>\n  <p>In software systems, these concepts are equally distinct but often confused:</p>\n  <ul>\n    <li><strong>Authentication:</strong> Proving who you are (identity verification)</li>\n    <li><strong>Authorization:</strong> Determining what you're allowed to do (permission verification)</li>\n  </ul>\n</div>\n\n<div class=\"concept-section\">\n  <h3>The Monolithic Era: Simple Sessions</h3>\n  <p>In traditional web applications, authentication was straightforward:</p>\n  <ol>\n    <li>User submits username and password</li>\n    <li>Server validates credentials against database</li>\n    <li>Server creates a session, stores it in memory or database</li>\n    <li>Server returns session cookie to browser</li>\n    <li>Browser sends cookie with every subsequent request</li>\n  </ol>\n  <p>This worked beautifully when you had one application server handling all requests. The server maintained session state and could easily check \"Is this user logged in?\" by looking up the session.</p>\n</div>\n\n<div class=\"concept-section\">\n  <h3>The Distributed System Problem</h3>\n  <p>Modern architectures break this simple model in multiple ways:</p>\n  <ul>\n    <li><strong>Multiple services:</strong> Your frontend calls an API gateway, which calls user service, order service, payment service. Which service validates the session?</li>\n    <li><strong>Load balancing:</strong> Request 1 hits server A, request 2 hits server B. Does server B have access to the session created on server A?</li>\n    <li><strong>Stateless scaling:</strong> To scale horizontally, services should be stateless. Session storage creates state that must be shared.</li>\n    <li><strong>Mobile and SPAs:</strong> Not all clients are web browsers that handle cookies automatically</li>\n    <li><strong>Third-party access:</strong> How does a mobile app access your API without sharing user credentials?</li>\n  </ul>\n</div>\n\n<div class=\"concept-section\">\n  <h3>Security Challenges in Microservices</h3>\n  <div style=\"background: #fff3e0; padding: 20px; border-radius: 10px; margin: 20px 0;\">\n    <h4>‚ö†Ô∏è The Trust Boundary Problem</h4>\n    <p>In a microservices architecture, every service call crosses a trust boundary. Consider this flow:</p>\n    <ol>\n      <li>User authenticated at API Gateway</li>\n      <li>Gateway calls Order Service</li>\n      <li>Order Service calls Inventory Service</li>\n      <li>Inventory Service calls Pricing Service</li>\n    </ol>\n    <p><strong>Questions that arise:</strong></p>\n    <ul>\n      <li>Should Inventory Service re-verify the user's identity?</li>\n      <li>How does Pricing Service know which user initiated this request?</li>\n      <li>What if a malicious service impersonates the API Gateway?</li>\n      <li>How do you propagate user context through the entire chain?</li>\n    </ul>\n  </div>\n</div>\n\n<div class=\"concept-section\">\n  <h3>Common Attack Vectors</h3>\n  <ul>\n    <li><strong>Credential stuffing:</strong> Attackers use leaked passwords from other sites to access your system</li>\n    <li><strong>Session hijacking:</strong> Attacker steals session cookie and impersonates user</li>\n    <li><strong>Man-in-the-middle:</strong> Attacker intercepts communication between client and server</li>\n    <li><strong>Token theft:</strong> Stored tokens can be extracted from compromised devices</li>\n    <li><strong>Replay attacks:</strong> Attacker captures and reuses valid authentication requests</li>\n    <li><strong>Privilege escalation:</strong> User gains access to resources beyond their authorization level</li>\n  </ul>\n  <p>These threats drive the need for sophisticated authentication and authorization patterns beyond simple username/password.</p>\n</div>\n\n<div class=\"concept-section\">\n  <h3>Why We Need Standard Protocols</h3>\n  <p>Rather than building custom security solutions (which often have vulnerabilities), the industry has converged on standard protocols:</p>\n  <ul>\n    <li>‚úÖ <strong>Battle-tested:</strong> Security experts have reviewed and improved them over years</li>\n    <li>‚úÖ <strong>Interoperability:</strong> Systems from different vendors can integrate securely</li>\n    <li>‚úÖ <strong>Library support:</strong> Well-maintained implementations in every major language</li>\n    <li>‚úÖ <strong>Common patterns:</strong> Developers can move between projects with familiar approaches</li>\n  </ul>\n  <p>The protocols we'll explore‚ÄîOAuth 2.0, OpenID Connect, and JWT‚Äîaddress these distributed system challenges with proven patterns.</p>\n</div>\n\n<div class=\"exercise\">\n  <h3>üõ†Ô∏è Identify the Security Challenge</h3>\n  <p><strong>Scenario:</strong> You're building a social media platform with these components:</p>\n  <ul>\n    <li>Web frontend (React SPA)</li>\n    <li>Mobile apps (iOS and Android)</li>\n    <li>API Gateway</li>\n    <li>User Service (handles profiles, authentication)</li>\n    <li>Post Service (creates and retrieves posts)</li>\n    <li>Media Service (handles image uploads to S3)</li>\n    <li>Notification Service (sends push notifications)</li>\n  </ul>\n  <p><strong>Your task:</strong> Identify at least 3 specific security challenges this architecture faces that simple session-based authentication cannot solve. For each challenge, describe what could go wrong if not handled properly.</p>\n  <p><strong>Consider:</strong> How does the mobile app authenticate? How does Post Service know which user is creating a post? How do you prevent one user from accessing another user's photos?</p>\n</div>"
    },
    {
      "id": 2,
      "title": "OAuth 2.0 Fundamentals: The Authorization Framework",
      "goals": [
        "Understand what OAuth 2.0 is and, critically, what it is NOT",
        "Master the four core grant types and when to use each one",
        "Learn the roles and responsibilities of OAuth 2.0 components",
        "Recognize common OAuth misconceptions and anti-patterns"
      ],
      "content": "<div class=\"concept-section\">\n  <h3>What OAuth 2.0 Actually Is</h3>\n  <p>OAuth 2.0 is an <strong>authorization framework</strong>, not an authentication protocol. This is the most critical distinction to understand, and where most confusion begins.</p>\n  <p>Think of OAuth 2.0 like a valet parking system: You give the valet your car key (authorization), but you don't give them your house keys, your gym locker combination, or prove your identity. The valet can park your car (limited authorization) but can't do anything else. The valet service doesn't care <em>who you are</em>‚Äîit only cares that you're authorized to grant access to that specific car.</p>\n  <p><strong>OAuth 2.0's purpose:</strong> Allow one application to access resources on behalf of a user <em>without</em> sharing the user's credentials.</p>\n</div>\n\n<div class=\"concept-section\">\n  <h3>The OAuth 2.0 Roles</h3>\n  <p>Every OAuth 2.0 flow involves four key roles:</p>\n  <ul>\n    <li><strong>Resource Owner:</strong> The user who owns the data (e.g., you own your Facebook photos)</li>\n    <li><strong>Client:</strong> The application requesting access (e.g., a photo printing app)</li>\n    <li><strong>Authorization Server:</strong> Issues access tokens after authenticating the resource owner (e.g., Facebook's OAuth server)</li>\n    <li><strong>Resource Server:</strong> Hosts the protected resources and accepts access tokens (e.g., Facebook's API that serves photos)</li>\n  </ul>\n  <p><em>Note: Authorization Server and Resource Server are often the same system, but conceptually separate.</em></p>\n</div>\n\n<div class=\"concept-section\">\n  <h3>The Classic OAuth 2.0 Example</h3>\n  <p>You want to use a third-party service \"PrintMyPhotos.com\" to print your Facebook photos:</p>\n  <ol>\n    <li><strong>Without OAuth:</strong> You'd give PrintMyPhotos your Facebook username and password (terrible idea!)</li>\n    <li><strong>With OAuth:</strong> PrintMyPhotos redirects you to Facebook, you approve access to your photos only, Facebook gives PrintMyPhotos a token, PrintMyPhotos uses that token to fetch your photos</li>\n  </ol>\n  <p>You never shared your Facebook credentials with PrintMyPhotos, and you can revoke their access anytime.</p>\n</div>\n\n<div class=\"concept-section\">\n  <h3>OAuth 2.0 is NOT Authentication</h3>\n  <div style=\"background: #ffebee; padding: 20px; border-radius: 10px; margin: 20px 0;\">\n    <h4>‚ö†Ô∏è Critical Misconception</h4>\n    <p>An access token proves the client is authorized to access resources, but it doesn't prove the user's identity. Here's why:</p>\n    <ul>\n      <li>‚ùå Access tokens don't have a standardized format (could be opaque strings)</li>\n      <li>‚ùå No standard way to get user information from an access token</li>\n      <li>‚ùå Token might represent client credentials, not a user</li>\n      <li>‚ùå No standard claims about who the user is</li>\n    </ul>\n    <p><strong>Bottom line:</strong> If your app needs to know \"who is this user?\", OAuth 2.0 alone is insufficient. You need OpenID Connect (covered in Lesson 3).</p>\n  </div>\n</div>\n\n<div class=\"concept-section\">\n  <h3>The Four Grant Types</h3>\n  <p>OAuth 2.0 defines four ways (grant types) to obtain an access token, each suited to different scenarios:</p>\n</div>\n\n<div class=\"concept-section\">\n  <h4>1. Authorization Code Grant (Most Secure)</h4>\n  <p>The gold standard for web applications and mobile apps. Used when you can keep a client secret secure.</p>\n  <div style=\"background: #e8f5e8; padding: 20px; border-radius: 10px; margin: 10px 0;\">\n    <p><strong>Flow:</strong></p>\n    <ol>\n      <li>User clicks \"Login with Google\" in your app</li>\n      <li>Your app redirects to Google with your client_id and requested scopes</li>\n      <li>User authenticates with Google and approves access</li>\n      <li>Google redirects back to your app with an <strong>authorization code</strong></li>\n      <li>Your backend exchanges the code for an access token (using client_secret)</li>\n      <li>Your backend uses the access token to fetch user data from Google</li>\n    </ol>\n    <p><strong>‚úÖ Use when:</strong> You have a backend server that can securely store client_secret</p>\n    <p><strong>‚úÖ Security benefit:</strong> Access token never exposed to browser or mobile app</p>\n  </div>\n</div>\n\n<div class=\"concept-section\">\n  <h4>2. Client Credentials Grant</h4>\n  <p>Machine-to-machine authentication where no user is involved.</p>\n  <div style=\"background: #e3f2fd; padding: 20px; border-radius: 10px; margin: 10px 0;\">\n    <p><strong>Flow:</strong></p>\n    <ol>\n      <li>Your backend service authenticates directly with authorization server using client_id and client_secret</li>\n      <li>Authorization server returns access token</li>\n      <li>Your service uses token to access protected API</li>\n    </ol>\n    <p><strong>‚úÖ Use when:</strong> Service-to-service communication, scheduled jobs, backend processes</p>\n    <p><strong>Example:</strong> Your order processing service needs to call the inventory API</p>\n  </div>\n</div>\n\n<div class=\"concept-section\">\n  <h4>3. Implicit Grant (Deprecated - Don't Use)</h4>\n  <p>Designed for browser-based apps that couldn't keep secrets secure. Token returned directly in URL fragment.</p>\n  <div style=\"background: #fff3e0; padding: 20px; border-radius: 10px; margin: 10px 0;\">\n    <p><strong>‚ö†Ô∏è Status: Deprecated</strong></p>\n    <ul>\n      <li>‚ùå Token exposed in browser history and URL</li>\n      <li>‚ùå No refresh token support</li>\n      <li>‚ùå Vulnerable to token theft</li>\n    </ul>\n    <p><strong>Modern alternative:</strong> Use Authorization Code Grant with PKCE (Proof Key for Code Exchange) for single-page apps</p>\n  </div>\n</div>\n\n<div class=\"concept-section\">\n  <h4>4. Resource Owner Password Credentials Grant (Use Sparingly)</h4>\n  <p>User provides username and password directly to the client application.</p>\n  <div style=\"background: #fff3e0; padding: 20px; border-radius: 10px; margin: 10px 0;\">\n    <p><strong>Flow:</strong></p>\n    <ol>\n      <li>User enters username and password in your app</li>\n      <li>Your app sends credentials to authorization server</li>\n      <li>Authorization server returns access token</li>\n    </ol>\n    <p><strong>‚ö†Ô∏è Use ONLY when:</strong></p>\n    <ul>\n      <li>High trust between client and authorization server (e.g., mobile app to your own API)</li>\n      <li>Other grant types are not viable</li>\n      <li>Migrating from legacy authentication system</li>\n    </ul>\n    <p><strong>‚ùå Avoid because:</strong> Defeats OAuth's main purpose of not sharing credentials</p>\n  </div>\n</div>\n\n<div class=\"concept-section\">\n  <h3>OAuth 2.0 vs OpenID Connect vs SAML</h3>\n  <div style=\"display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; margin: 20px 0;\">\n    <div style=\"background: #e8f5e8; padding: 15px; border-radius: 10px;\">\n      <h4>OAuth 2.0</h4>\n      <ul>\n        <li><strong>Purpose:</strong> Authorization</li>\n        <li><strong>Question:</strong> \"Can I access this?\"</li>\n        <li><strong>Use case:</strong> Third-party API access</li>\n        <li><strong>Output:</strong> Access token</li>\n      </ul>\n    </div>\n    <div style=\"background: #e3f2fd; padding: 15px; border-radius: 10px;\">\n      <h4>OpenID Connect</h4>\n      <ul>\n        <li><strong>Purpose:</strong> Authentication + Authorization</li>\n        <li><strong>Question:</strong> \"Who are you?\"</li>\n        <li><strong>Use case:</strong> Single sign-on</li>\n        <li><strong>Output:</strong> ID token + Access token</li>\n      </ul>\n    </div>\n    <div style=\"background: #f3e5f5; padding: 15px; border-radius: 10px;\">\n      <h4>SAML</h4>\n      <ul>\n        <li><strong>Purpose:</strong> Enterprise SSO</li>\n        <li><strong>Question:</strong> \"Who are you?\"</li>\n        <li><strong>Use case:</strong> Enterprise federation</li>\n        <li><strong>Output:</strong> XML assertions</li>\n      </ul>\n    </div>\n  </div>\n  <p><strong>Key insight:</strong> OpenID Connect is an authentication layer <em>built on top of</em> OAuth 2.0. It's OAuth 2.0 + standardized authentication.</p>\n</div>\n\n<div class=\"concept-section\">\n  <h3>Authorization Code Flow: Detailed Walkthrough</h3>\n  <p>Let's trace exactly what happens when you click \"Sign in with Google\":</p>\n  <div style=\"background: #f8f9fa; padding: 10px; font-family: monospace; font-size: 14px; margin: 10px 0; line-height: 1.6;\">\n    1. User clicks \"Sign in with Google\"<br>\n    2. App redirects to:<br>\n    &nbsp;&nbsp;https://accounts.google.com/o/oauth2/v2/auth?<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;client_id=YOUR_CLIENT_ID&<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;redirect_uri=https://yourapp.com/callback&<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;response_type=code&<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;scope=email+profile<br>\n    <br>\n    3. User authenticates with Google<br>\n    4. User approves requested permissions<br>\n    5. Google redirects to:<br>\n    &nbsp;&nbsp;https://yourapp.com/callback?code=AUTH_CODE_HERE<br>\n    <br>\n    6. Your backend exchanges code for token:<br>\n    &nbsp;&nbsp;POST https://oauth2.googleapis.com/token<br>\n    &nbsp;&nbsp;client_id=YOUR_CLIENT_ID<br>\n    &nbsp;&nbsp;client_secret=YOUR_CLIENT_SECRET<br>\n    &nbsp;&nbsp;code=AUTH_CODE_HERE<br>\n    &nbsp;&nbsp;grant_type=authorization_code<br>\n    <br>\n    7. Google responds with:<br>\n    &nbsp;&nbsp;{<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;\"access_token\": \"ya29.a0...\",<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;\"expires_in\": 3600,<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;\"token_type\": \"Bearer\"<br>\n    &nbsp;&nbsp;}<br>\n    <br>\n    8. Your backend uses access_token to call Google APIs\n  </div>\n</div>\n\n<div class=\"exercise\">\n  <h3>üõ†Ô∏è Choose the Right Grant Type</h3>\n  <p><strong>Scenario:</strong> You're building different types of applications that need to interact with your company's APIs:</p>\n  <ol>\n    <li><strong>Customer mobile app:</strong> Native iOS/Android app where users log in to view their orders</li>\n    <li><strong>Partner integration:</strong> Third-party vendor needs to import customer data on a schedule</li>\n    <li><strong>Internal admin dashboard:</strong> React SPA used by customer support team</li>\n    <li><strong>Microservice communication:</strong> Order service needs to call inventory service</li>\n  </ol>\n  <p><strong>Your task:</strong> For each scenario, specify:</p>\n  <ul>\n    <li>Which OAuth 2.0 grant type to use</li>\n    <li>Why that grant type is appropriate</li>\n    <li>What security considerations apply</li>\n    <li>Whether OAuth 2.0 alone is sufficient or if OpenID Connect is needed</li>\n  </ul>\n  <p><strong>Consider:</strong> Can the client keep a secret? Is there a user involved? What's the trust relationship?</p>\n</div>"
    }
  ]
}
