{
  "id": "authentication-authorization",
  "title": "Authentication & Authorization Mastery",
  "totalLessons": 6,
  "available": true,
  "lessons": [
    {
      "id": 1,
      "title": "Why Do We Need Authentication & Authorization Patterns?",
      "goals": [
        "Understand the fundamental difference between authentication and authorization",
        "Identify security challenges unique to distributed systems and microservices",
        "Recognize why traditional session-based authentication doesn't scale"
      ],
      "content": "<div class=\"concept-section\">\n  <h3>The Two Pillars of Security</h3>\n  <p>Imagine a hotel with hundreds of rooms. When you check in, the front desk verifies your identity by checking your ID‚Äîthat's <strong>authentication</strong>. They then hand you a key card programmed to open only your room and the gym‚Äîthat's <strong>authorization</strong>. You might be authenticated (the hotel knows who you are), but you're not authorized to access the presidential suite or the staff area.</p>\n  <p>In software systems, these concepts are equally distinct but often confused:</p>\n  <ul>\n    <li><strong>Authentication:</strong> Proving who you are (identity verification)</li>\n    <li><strong>Authorization:</strong> Determining what you're allowed to do (permission verification)</li>\n  </ul>\n</div>\n\n<div class=\"concept-section\">\n  <h3>The Monolithic Era: Simple Sessions</h3>\n  <p>In traditional web applications, authentication was straightforward:</p>\n  <ol>\n    <li>User submits username and password</li>\n    <li>Server validates credentials against database</li>\n    <li>Server creates a session, stores it in memory or database</li>\n    <li>Server returns session cookie to browser</li>\n    <li>Browser sends cookie with every subsequent request</li>\n  </ol>\n  <p>This worked beautifully when you had one application server handling all requests. The server maintained session state and could easily check \"Is this user logged in?\" by looking up the session.</p>\n</div>\n\n<div class=\"concept-section\">\n  <h3>The Distributed System Problem</h3>\n  <p>Modern architectures break this simple model in multiple ways:</p>\n  <ul>\n    <li><strong>Multiple services:</strong> Your frontend calls an API gateway, which calls user service, order service, payment service. Which service validates the session?</li>\n    <li><strong>Load balancing:</strong> Request 1 hits server A, request 2 hits server B. Does server B have access to the session created on server A?</li>\n    <li><strong>Stateless scaling:</strong> To scale horizontally, services should be stateless. Session storage creates state that must be shared.</li>\n    <li><strong>Mobile and SPAs:</strong> Not all clients are web browsers that handle cookies automatically</li>\n    <li><strong>Third-party access:</strong> How does a mobile app access your API without sharing user credentials?</li>\n  </ul>\n</div>\n\n<div class=\"concept-section\">\n  <h3>Security Challenges in Microservices</h3>\n  <div style=\"background: #fff3e0; padding: 20px; border-radius: 10px; margin: 20px 0;\">\n    <h4>‚ö†Ô∏è The Trust Boundary Problem</h4>\n    <p>In a microservices architecture, every service call crosses a trust boundary. Consider this flow:</p>\n    <ol>\n      <li>User authenticated at API Gateway</li>\n      <li>Gateway calls Order Service</li>\n      <li>Order Service calls Inventory Service</li>\n      <li>Inventory Service calls Pricing Service</li>\n    </ol>\n    <p><strong>Questions that arise:</strong></p>\n    <ul>\n      <li>Should Inventory Service re-verify the user's identity?</li>\n      <li>How does Pricing Service know which user initiated this request?</li>\n      <li>What if a malicious service impersonates the API Gateway?</li>\n      <li>How do you propagate user context through the entire chain?</li>\n    </ul>\n  </div>\n</div>\n\n<div class=\"concept-section\">\n  <h3>Common Attack Vectors</h3>\n  <ul>\n    <li><strong>Credential stuffing:</strong> Attackers use leaked passwords from other sites to access your system</li>\n    <li><strong>Session hijacking:</strong> Attacker steals session cookie and impersonates user</li>\n    <li><strong>Man-in-the-middle:</strong> Attacker intercepts communication between client and server</li>\n    <li><strong>Token theft:</strong> Stored tokens can be extracted from compromised devices</li>\n    <li><strong>Replay attacks:</strong> Attacker captures and reuses valid authentication requests</li>\n    <li><strong>Privilege escalation:</strong> User gains access to resources beyond their authorization level</li>\n  </ul>\n  <p>These threats drive the need for sophisticated authentication and authorization patterns beyond simple username/password.</p>\n</div>\n\n<div class=\"concept-section\">\n  <h3>Why We Need Standard Protocols</h3>\n  <p>Rather than building custom security solutions (which often have vulnerabilities), the industry has converged on standard protocols:</p>\n  <ul>\n    <li>‚úÖ <strong>Battle-tested:</strong> Security experts have reviewed and improved them over years</li>\n    <li>‚úÖ <strong>Interoperability:</strong> Systems from different vendors can integrate securely</li>\n    <li>‚úÖ <strong>Library support:</strong> Well-maintained implementations in every major language</li>\n    <li>‚úÖ <strong>Common patterns:</strong> Developers can move between projects with familiar approaches</li>\n  </ul>\n  <p>The protocols we'll explore‚ÄîOAuth 2.0, OpenID Connect, and JWT‚Äîaddress these distributed system challenges with proven patterns.</p>\n</div>\n\n<div class=\"exercise\">\n  <h3>üõ†Ô∏è Identify the Security Challenge</h3>\n  <p><strong>Scenario:</strong> You're building a social media platform with these components:</p>\n  <ul>\n    <li>Web frontend (React SPA)</li>\n    <li>Mobile apps (iOS and Android)</li>\n    <li>API Gateway</li>\n    <li>User Service (handles profiles, authentication)</li>\n    <li>Post Service (creates and retrieves posts)</li>\n    <li>Media Service (handles image uploads to S3)</li>\n    <li>Notification Service (sends push notifications)</li>\n  </ul>\n  <p><strong>Your task:</strong> Identify at least 3 specific security challenges this architecture faces that simple session-based authentication cannot solve. For each challenge, describe what could go wrong if not handled properly.</p>\n  <p><strong>Consider:</strong> How does the mobile app authenticate? How does Post Service know which user is creating a post? How do you prevent one user from accessing another user's photos?</p>\n</div>"
    },
    {
      "id": 2,
      "title": "OAuth 2.0 Fundamentals: The Authorization Framework",
      "goals": [
        "Understand what OAuth 2.0 is and, critically, what it is NOT",
        "Master the four core grant types and when to use each one",
        "Learn the roles and responsibilities of OAuth 2.0 components",
        "Recognize common OAuth misconceptions and anti-patterns"
      ],
      "content": "<div class=\"concept-section\">\n  <h3>What OAuth 2.0 Actually Is</h3>\n  <p>OAuth 2.0 is an <strong>authorization framework</strong>, not an authentication protocol. This is the most critical distinction to understand, and where most confusion begins.</p>\n  <p>Think of OAuth 2.0 like a valet parking system: You give the valet your car key (authorization), but you don't give them your house keys, your gym locker combination, or prove your identity. The valet can park your car (limited authorization) but can't do anything else. The valet service doesn't care <em>who you are</em>‚Äîit only cares that you're authorized to grant access to that specific car.</p>\n  <p><strong>OAuth 2.0's purpose:</strong> Allow one application to access resources on behalf of a user <em>without</em> sharing the user's credentials.</p>\n</div>\n\n<div class=\"concept-section\">\n  <h3>The OAuth 2.0 Roles</h3>\n  <p>Every OAuth 2.0 flow involves four key roles:</p>\n  <ul>\n    <li><strong>Resource Owner:</strong> The user who owns the data (e.g., you own your Facebook photos)</li>\n    <li><strong>Client:</strong> The application requesting access (e.g., a photo printing app)</li>\n    <li><strong>Authorization Server:</strong> Issues access tokens after authenticating the resource owner (e.g., Facebook's OAuth server)</li>\n    <li><strong>Resource Server:</strong> Hosts the protected resources and accepts access tokens (e.g., Facebook's API that serves photos)</li>\n  </ul>\n  <p><em>Note: Authorization Server and Resource Server are often the same system, but conceptually separate.</em></p>\n</div>\n\n<div class=\"concept-section\">\n  <h3>The Classic OAuth 2.0 Example</h3>\n  <p>You want to use a third-party service \"PrintMyPhotos.com\" to print your Facebook photos:</p>\n  <ol>\n    <li><strong>Without OAuth:</strong> You'd give PrintMyPhotos your Facebook username and password (terrible idea!)</li>\n    <li><strong>With OAuth:</strong> PrintMyPhotos redirects you to Facebook, you approve access to your photos only, Facebook gives PrintMyPhotos a token, PrintMyPhotos uses that token to fetch your photos</li>\n  </ol>\n  <p>You never shared your Facebook credentials with PrintMyPhotos, and you can revoke their access anytime.</p>\n</div>\n\n<div class=\"concept-section\">\n  <h3>OAuth 2.0 is NOT Authentication</h3>\n  <div style=\"background: #ffebee; padding: 20px; border-radius: 10px; margin: 20px 0;\">\n    <h4>‚ö†Ô∏è Critical Misconception</h4>\n    <p>An access token proves the client is authorized to access resources, but it doesn't prove the user's identity. Here's why:</p>\n    <ul>\n      <li>‚ùå Access tokens don't have a standardized format (could be opaque strings)</li>\n      <li>‚ùå No standard way to get user information from an access token</li>\n      <li>‚ùå Token might represent client credentials, not a user</li>\n      <li>‚ùå No standard claims about who the user is</li>\n    </ul>\n    <p><strong>Bottom line:</strong> If your app needs to know \"who is this user?\", OAuth 2.0 alone is insufficient. You need OpenID Connect (covered in Lesson 3).</p>\n  </div>\n</div>\n\n<div class=\"concept-section\">\n  <h3>The Four Grant Types</h3>\n  <p>OAuth 2.0 defines four ways (grant types) to obtain an access token, each suited to different scenarios:</p>\n</div>\n\n<div class=\"concept-section\">\n  <h4>1. Authorization Code Grant (Most Secure)</h4>\n  <p>The gold standard for web applications and mobile apps. Used when you can keep a client secret secure.</p>\n  <div style=\"background: #e8f5e8; padding: 20px; border-radius: 10px; margin: 10px 0;\">\n    <p><strong>Flow:</strong></p>\n    <ol>\n      <li>User clicks \"Login with Google\" in your app</li>\n      <li>Your app redirects to Google with your client_id and requested scopes</li>\n      <li>User authenticates with Google and approves access</li>\n      <li>Google redirects back to your app with an <strong>authorization code</strong></li>\n      <li>Your backend exchanges the code for an access token (using client_secret)</li>\n      <li>Your backend uses the access token to fetch user data from Google</li>\n    </ol>\n    <p><strong>‚úÖ Use when:</strong> You have a backend server that can securely store client_secret</p>\n    <p><strong>‚úÖ Security benefit:</strong> Access token never exposed to browser or mobile app</p>\n  </div>\n</div>\n\n<div class=\"concept-section\">\n  <h4>2. Client Credentials Grant</h4>\n  <p>Machine-to-machine authentication where no user is involved.</p>\n  <div style=\"background: #e3f2fd; padding: 20px; border-radius: 10px; margin: 10px 0;\">\n    <p><strong>Flow:</strong></p>\n    <ol>\n      <li>Your backend service authenticates directly with authorization server using client_id and client_secret</li>\n      <li>Authorization server returns access token</li>\n      <li>Your service uses token to access protected API</li>\n    </ol>\n    <p><strong>‚úÖ Use when:</strong> Service-to-service communication, scheduled jobs, backend processes</p>\n    <p><strong>Example:</strong> Your order processing service needs to call the inventory API</p>\n  </div>\n</div>\n\n<div class=\"concept-section\">\n  <h4>3. Implicit Grant (Deprecated - Don't Use)</h4>\n  <p>Designed for browser-based apps that couldn't keep secrets secure. Token returned directly in URL fragment.</p>\n  <div style=\"background: #fff3e0; padding: 20px; border-radius: 10px; margin: 10px 0;\">\n    <p><strong>‚ö†Ô∏è Status: Deprecated</strong></p>\n    <ul>\n      <li>‚ùå Token exposed in browser history and URL</li>\n      <li>‚ùå No refresh token support</li>\n      <li>‚ùå Vulnerable to token theft</li>\n    </ul>\n    <p><strong>Modern alternative:</strong> Use Authorization Code Grant with PKCE (Proof Key for Code Exchange) for single-page apps</p>\n  </div>\n</div>\n\n<div class=\"concept-section\">\n  <h4>4. Resource Owner Password Credentials Grant (Use Sparingly)</h4>\n  <p>User provides username and password directly to the client application.</p>\n  <div style=\"background: #fff3e0; padding: 20px; border-radius: 10px; margin: 10px 0;\">\n    <p><strong>Flow:</strong></p>\n    <ol>\n      <li>User enters username and password in your app</li>\n      <li>Your app sends credentials to authorization server</li>\n      <li>Authorization server returns access token</li>\n    </ol>\n    <p><strong>‚ö†Ô∏è Use ONLY when:</strong></p>\n    <ul>\n      <li>High trust between client and authorization server (e.g., mobile app to your own API)</li>\n      <li>Other grant types are not viable</li>\n      <li>Migrating from legacy authentication system</li>\n    </ul>\n    <p><strong>‚ùå Avoid because:</strong> Defeats OAuth's main purpose of not sharing credentials</p>\n  </div>\n</div>\n\n<div class=\"concept-section\">\n  <h3>OAuth 2.0 vs OpenID Connect vs SAML</h3>\n  <div style=\"display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; margin: 20px 0;\">\n    <div style=\"background: #e8f5e8; padding: 15px; border-radius: 10px;\">\n      <h4>OAuth 2.0</h4>\n      <ul>\n        <li><strong>Purpose:</strong> Authorization</li>\n        <li><strong>Question:</strong> \"Can I access this?\"</li>\n        <li><strong>Use case:</strong> Third-party API access</li>\n        <li><strong>Output:</strong> Access token</li>\n      </ul>\n    </div>\n    <div style=\"background: #e3f2fd; padding: 15px; border-radius: 10px;\">\n      <h4>OpenID Connect</h4>\n      <ul>\n        <li><strong>Purpose:</strong> Authentication + Authorization</li>\n        <li><strong>Question:</strong> \"Who are you?\"</li>\n        <li><strong>Use case:</strong> Single sign-on</li>\n        <li><strong>Output:</strong> ID token + Access token</li>\n      </ul>\n    </div>\n    <div style=\"background: #f3e5f5; padding: 15px; border-radius: 10px;\">\n      <h4>SAML</h4>\n      <ul>\n        <li><strong>Purpose:</strong> Enterprise SSO</li>\n        <li><strong>Question:</strong> \"Who are you?\"</li>\n        <li><strong>Use case:</strong> Enterprise federation</li>\n        <li><strong>Output:</strong> XML assertions</li>\n      </ul>\n    </div>\n  </div>\n  <p><strong>Key insight:</strong> OpenID Connect is an authentication layer <em>built on top of</em> OAuth 2.0. It's OAuth 2.0 + standardized authentication.</p>\n</div>\n\n<div class=\"concept-section\">\n  <h3>Authorization Code Flow: Detailed Walkthrough</h3>\n  <p>Let's trace exactly what happens when you click \"Sign in with Google\":</p>\n  <div style=\"background: #f8f9fa; padding: 10px; font-family: monospace; font-size: 14px; margin: 10px 0; line-height: 1.6;\">\n    1. User clicks \"Sign in with Google\"<br>\n    2. App redirects to:<br>\n    &nbsp;&nbsp;https://accounts.google.com/o/oauth2/v2/auth?<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;client_id=YOUR_CLIENT_ID&<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;redirect_uri=https://yourapp.com/callback&<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;response_type=code&<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;scope=email+profile<br>\n    <br>\n    3. User authenticates with Google<br>\n    4. User approves requested permissions<br>\n    5. Google redirects to:<br>\n    &nbsp;&nbsp;https://yourapp.com/callback?code=AUTH_CODE_HERE<br>\n    <br>\n    6. Your backend exchanges code for token:<br>\n    &nbsp;&nbsp;POST https://oauth2.googleapis.com/token<br>\n    &nbsp;&nbsp;client_id=YOUR_CLIENT_ID<br>\n    &nbsp;&nbsp;client_secret=YOUR_CLIENT_SECRET<br>\n    &nbsp;&nbsp;code=AUTH_CODE_HERE<br>\n    &nbsp;&nbsp;grant_type=authorization_code<br>\n    <br>\n    7. Google responds with:<br>\n    &nbsp;&nbsp;{<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;\"access_token\": \"ya29.a0...\",<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;\"expires_in\": 3600,<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;\"token_type\": \"Bearer\"<br>\n    &nbsp;&nbsp;}<br>\n    <br>\n    8. Your backend uses access_token to call Google APIs\n  </div>\n</div>\n\n<div class=\"exercise\">\n  <h3>üõ†Ô∏è Choose the Right Grant Type</h3>\n  <p><strong>Scenario:</strong> You're building different types of applications that need to interact with your company's APIs:</p>\n  <ol>\n    <li><strong>Customer mobile app:</strong> Native iOS/Android app where users log in to view their orders</li>\n    <li><strong>Partner integration:</strong> Third-party vendor needs to import customer data on a schedule</li>\n    <li><strong>Internal admin dashboard:</strong> React SPA used by customer support team</li>\n    <li><strong>Microservice communication:</strong> Order service needs to call inventory service</li>\n  </ol>\n  <p><strong>Your task:</strong> For each scenario, specify:</p>\n  <ul>\n    <li>Which OAuth 2.0 grant type to use</li>\n    <li>Why that grant type is appropriate</li>\n    <li>What security considerations apply</li>\n    <li>Whether OAuth 2.0 alone is sufficient or if OpenID Connect is needed</li>\n  </ul>\n  <p><strong>Consider:</strong> Can the client keep a secret? Is there a user involved? What's the trust relationship?</p>\n</div>"
    },{
      "id": 3,
      "title": "OpenID Connect & JWT: Adding Authentication to OAuth",
      "goals": [
        "Understand how OpenID Connect extends OAuth 2.0 to provide authentication",
        "Master JWT structure and learn to decode and validate tokens",
        "Distinguish between ID tokens, access tokens, and refresh tokens",
        "Learn how JWK and JWKS enable secure token verification"
      ],
      "content": "<div class=\"concept-section\">\n  <h3>The Authentication Gap in OAuth 2.0</h3>\n  <p>Imagine you're at an exclusive event. The bouncer checks your ticket (authorization) and lets you in. But once inside, how do other staff members know who you are? Your ticket doesn't have your name, photo, or any identifying information‚Äîit just proves you're allowed to be there.</p>\n  <p>This is OAuth 2.0's limitation: an access token proves authorization but doesn't reliably communicate identity. Enter <strong>OpenID Connect (OIDC)</strong>.</p>\n  <p><strong>OpenID Connect is an authentication layer built on top of OAuth 2.0.</strong> It extends OAuth 2.0 by adding standardized identity information through ID tokens and standard claims.</p>\n</div>\n\n<div class=\"concept-section\">\n  <h3>What OpenID Connect Adds to OAuth 2.0</h3>\n  <ul>\n    <li>‚úÖ <strong>ID Token:</strong> A new token type containing user identity information</li>\n    <li>‚úÖ <strong>UserInfo endpoint:</strong> Standardized API to get user profile data</li>\n    <li>‚úÖ <strong>Standard scopes:</strong> openid, profile, email for requesting user data</li>\n    <li>‚úÖ <strong>Standard claims:</strong> Agreed-upon fields for user attributes (sub, name, email, etc.)</li>\n  </ul>\n  <p>OpenID Connect uses the same grant types as OAuth 2.0 but adds the <code>openid</code> scope to trigger authentication.</p>\n</div>\n\n<div class=\"concept-section\">\n  <h3>ID Token vs Access Token: The Critical Distinction</h3>\n  <div style=\"display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;\">\n    <div style=\"background: #e3f2fd; padding: 20px; border-radius: 10px;\">\n      <h4>ID Token</h4>\n      <ul>\n        <li><strong>Purpose:</strong> Prove user identity</li>\n        <li><strong>Audience:</strong> Your application (the client)</li>\n        <li><strong>Format:</strong> Always JWT</li>\n        <li><strong>Contains:</strong> User identity claims</li>\n        <li><strong>Usage:</strong> Read once to authenticate user</li>\n        <li><strong>Lifetime:</strong> Short (minutes to hours)</li>\n        <li>‚ö†Ô∏è <strong>Never send to APIs</strong></li>\n      </ul>\n    </div>\n    <div style=\"background: #e8f5e8; padding: 20px; border-radius: 10px;\">\n      <h4>Access Token</h4>\n      <ul>\n        <li><strong>Purpose:</strong> Authorize API access</li>\n        <li><strong>Audience:</strong> Resource servers (APIs)</li>\n        <li><strong>Format:</strong> JWT or opaque string</li>\n        <li><strong>Contains:</strong> Permissions/scopes</li>\n        <li><strong>Usage:</strong> Send with every API request</li>\n        <li><strong>Lifetime:</strong> Short to medium</li>\n        <li>‚úÖ <strong>Include in Authorization header</strong></li>\n      </ul>\n    </div>\n  </div>\n  <p><strong>Key principle:</strong> ID tokens authenticate users to your app. Access tokens authorize your app to call APIs. Never confuse the two!</p>\n</div>\n\n<div class=\"concept-section\">\n  <h3>JWT: JSON Web Token Anatomy</h3>\n  <p>Both ID tokens and many access tokens use JWT format. A JWT has three Base64-encoded parts separated by dots:</p>\n  <div style=\"background: #f8f9fa; padding: 15px; border-radius: 10px; margin: 10px 0;\">\n    <p style=\"font-family: monospace; word-break: break-all; font-size: 12px; margin-bottom: 15px;\">\n      <span style=\"color: #d32f2f;\">eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImFiYzEyMyJ9</span>.<span style=\"color: #7b1fa2;\">eyJpc3MiOiJodHRwczovL2F1dGguZXhhbXBsZS5jb20iLCJzdWIiOiJ1c2VyMTIzIiwiYXVkIjoieW91ci1jbGllbnQtaWQiLCJleHAiOjE3MzU2ODk2MDAsImlhdCI6MTczNTY4NjAwMCwibmFtZSI6IkpvaG4gRG9lIiwiZW1haWwiOiJqb2huQGV4YW1wbGUuY29tIn0</span>.<span style=\"color: #1976d2;\">SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c</span>\n    </p>\n    <p><strong>Decoded structure:</strong></p>\n    <p style=\"font-family: monospace; font-size: 13px; line-height: 1.8;\">\n      <span style=\"color: #d32f2f;\"><strong>Header:</strong></span> { \"alg\": \"RS256\", \"typ\": \"JWT\", \"kid\": \"abc123\" }<br>\n      <span style=\"color: #7b1fa2;\"><strong>Payload:</strong></span> {<br>\n      &nbsp;&nbsp;\"iss\": \"https://auth.example.com\",&nbsp;&nbsp;// Issuer<br>\n      &nbsp;&nbsp;\"sub\": \"user123\",&nbsp;&nbsp;// Subject (user ID)<br>\n      &nbsp;&nbsp;\"aud\": \"your-client-id\",&nbsp;&nbsp;// Audience<br>\n      &nbsp;&nbsp;\"exp\": 1735689600,&nbsp;&nbsp;// Expiration timestamp<br>\n      &nbsp;&nbsp;\"iat\": 1735686000,&nbsp;&nbsp;// Issued at<br>\n      &nbsp;&nbsp;\"name\": \"John Doe\",<br>\n      &nbsp;&nbsp;\"email\": \"john@example.com\"<br>\n      }<br>\n      <span style=\"color: #1976d2;\"><strong>Signature:</strong></span> Cryptographic proof of authenticity\n    </p>\n  </div>\n  <p><strong>Critical point:</strong> The payload is Base64-encoded (readable by anyone), NOT encrypted. The signature ensures it hasn't been tampered with.</p>\n</div>\n\n<div class=\"concept-section\">\n  <h3>JWK and JWKS: Verifying Token Signatures</h3>\n  <p>When your application receives a JWT, you verify the signature using the issuer's public key. This is where JWK (JSON Web Key) and JWKS (JSON Web Key Set) come in.</p>\n  <p><strong>The verification flow:</strong></p>\n  <ol>\n    <li>Decode JWT header to get the <code>kid</code> (key ID)</li>\n    <li>Fetch JWKS from authorization server's <code>/.well-known/jwks.json</code> endpoint</li>\n    <li>Find the JWK with matching <code>kid</code></li>\n    <li>Use that public key to verify the JWT signature</li>\n    <li>If signature is valid, trust the token's claims</li>\n  </ol>\n  <div style=\"background: #f8f9fa; padding: 10px; font-family: monospace; margin: 10px 0; font-size: 13px;\">\n    Example JWKS endpoint response:<br>\n    {<br>\n    &nbsp;&nbsp;\"keys\": [<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;{<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"kty\": \"RSA\",&nbsp;&nbsp;// Key type<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"kid\": \"abc123\",&nbsp;&nbsp;// Key ID (matches JWT header)<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"use\": \"sig\",&nbsp;&nbsp;// Usage: signature verification<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"n\": \"0vx7ago...\",&nbsp;&nbsp;// RSA modulus<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"e\": \"AQAB\"&nbsp;&nbsp;// RSA exponent<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;}<br>\n    &nbsp;&nbsp;]<br>\n    }\n  </div>\n  <p>Authorization servers rotate keys periodically for security, which is why the <code>kid</code> field is crucial.</p>\n</div>\n\n<div class=\"concept-section\">\n  <h3>Token Validation Checklist</h3>\n  <p>When you receive a JWT (especially an ID token), you must validate:</p>\n  <ul>\n    <li>‚úÖ <strong>Signature:</strong> Verify using public key from JWKS</li>\n    <li>‚úÖ <strong>Issuer (iss):</strong> Matches expected authorization server</li>\n    <li>‚úÖ <strong>Audience (aud):</strong> Matches your client_id</li>\n    <li>‚úÖ <strong>Expiration (exp):</strong> Token hasn't expired</li>\n    <li>‚úÖ <strong>Issued at (iat):</strong> Token is reasonably recent</li>\n    <li>‚úÖ <strong>Nonce:</strong> Matches expected value (prevents replay attacks)</li>\n  </ul>\n  <p><strong>Never skip validation!</strong> Libraries like Spring Security, Auth0 SDK, and passport.js handle this automatically.</p>\n</div>\n\n<div class=\"concept-section\">\n  <h3>When You Need OAuth Only vs When You Need OIDC</h3>\n  <div style=\"display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;\">\n    <div style=\"background: #e8f5e8; padding: 20px; border-radius: 10px;\">\n      <h4>Use OAuth 2.0 Only</h4>\n      <ul>\n        <li>Machine-to-machine communication</li>\n        <li>Third-party access to your API</li>\n        <li>You don't care who the user is</li>\n        <li>You only need permissions/scopes</li>\n      </ul>\n      <p><strong>Example:</strong> GitHub app accessing repository data</p>\n    </div>\n    <div style=\"background: #e3f2fd; padding: 20px; border-radius: 10px;\">\n      <h4>Use OpenID Connect</h4>\n      <ul>\n        <li>User login and authentication</li>\n        <li>Single sign-on (SSO)</li>\n        <li>You need to know user identity</li>\n        <li>You need user profile data</li>\n      </ul>\n      <p><strong>Example:</strong> \"Sign in with Google\" on your web app</p>\n    </div>\n  </div>\n</div>\n\n<div class=\"concept-section\">\n  <h3>Common JWT/OIDC Mistakes to Avoid</h3>\n  <div style=\"background: #ffebee; padding: 20px; border-radius: 10px; margin: 20px 0;\">\n    <ul>\n      <li>‚ùå <strong>Storing sensitive data in JWT payload:</strong> It's Base64-encoded, not encrypted‚Äîanyone can read it</li>\n      <li>‚ùå <strong>Using ID token to call APIs:</strong> Always use access tokens for API authorization</li>\n      <li>‚ùå <strong>Skipping signature verification:</strong> Anyone can create a JWT with fake claims if you don't verify</li>\n    </ul>\n  </div>\n</div>\n\n<div class=\"exercise\">\n  <h3>üõ†Ô∏è Decode and Validate a JWT</h3>\n  <p><strong>Scenario:</strong> Your application receives this ID token after a user logs in via OpenID Connect. The current timestamp is 1735686500.</p>\n  <div style=\"background: #f8f9fa; padding: 10px; font-family: monospace; font-size: 12px; margin: 10px 0; word-break: break-all;\">\n    eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImFiYzEyMyJ9.eyJpc3MiOiJodHRwczovL2F1dGguZXhhbXBsZS5jb20iLCJzdWIiOiJ1c2VyMTIzIiwiYXVkIjoieW91ci1jbGllbnQtaWQiLCJleHAiOjE3MzU2ODk2MDAsImlhdCI6MTczNTY4NjAwMCwibm9uY2UiOiJyYW5kb20xMjMiLCJuYW1lIjoiSm9obiBEb2UiLCJlbWFpbCI6ImpvaG5AZXhhbXBsZS5jb20iLCJlbWFpbF92ZXJpZmllZCI6dHJ1ZX0.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\n  </div>\n  <p><strong>Your task:</strong></p>\n  <ol>\n    <li>Use <a href=\"https://jwt.io\" target=\"_blank\" rel=\"noopener noreferrer\">jwt.io</a> to decode the token and examine its parts</li>\n    <li>Identify which claims are standard OIDC claims vs custom claims</li>\n    <li>List all validation checks you would perform and whether this token passes each check</li>\n    <li>Explain what the <code>kid</code> field is used for and why it's important</li>\n    <li>Would you send this token when calling your backend API? Why or why not?</li>\n  </ol>\n  <p><strong>Consider:</strong> What would happen if an attacker modified the email claim in the payload? How would you detect this tampering?</p>\n</div>"
    },
    {
      "id": 4,
      "title": "Token Management: Security, Storage, and Refresh Strategies",
      "goals": [
        "Master the distinction between access tokens and refresh tokens",
        "Learn secure token storage strategies for different client types",
        "Understand token rotation and revocation patterns",
        "Implement the Backend-for-Frontend pattern for enhanced security"
      ],
      "content": "<div class=\"concept-section\">\n  <h3>The Token Lifecycle Problem</h3>\n  <p>Imagine you're issued a driver's license valid for 10 years. If stolen, the thief can impersonate you for a decade. Now imagine instead you carry a temporary daily pass, and you can request a new one from the DMV by showing your long-term credential that stays safely locked at home. If your daily pass is stolen, the damage window is just hours, not years.</p>\n  <p>This is the philosophy behind <strong>access tokens and refresh tokens</strong> in OAuth 2.0/OIDC systems.</p>\n</div>\n\n<div class=\"concept-section\">\n  <h3>Access Token vs Refresh Token</h3>\n  <div style=\"display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;\">\n    <div style=\"background: #e3f2fd; padding: 20px; border-radius: 10px;\">\n      <h4>Access Token</h4>\n      <ul>\n        <li><strong>Purpose:</strong> Short-term API access</li>\n        <li><strong>Lifetime:</strong> 15-60 minutes typically</li>\n        <li><strong>Sent to:</strong> Resource servers with every request</li>\n        <li><strong>Exposure risk:</strong> High (sent frequently)</li>\n        <li><strong>If stolen:</strong> Limited damage window</li>\n        <li><strong>Revocation:</strong> Difficult before expiration</li>\n      </ul>\n    </div>\n    <div style=\"background: #e8f5e8; padding: 20px; border-radius: 10px;\">\n      <h4>Refresh Token</h4>\n      <ul>\n        <li><strong>Purpose:</strong> Obtain new access tokens</li>\n        <li><strong>Lifetime:</strong> Days to months</li>\n        <li><strong>Sent to:</strong> Authorization server only</li>\n        <li><strong>Exposure risk:</strong> Lower (used rarely)</li>\n        <li><strong>If stolen:</strong> Can cause sustained damage</li>\n        <li><strong>Revocation:</strong> Can be revoked immediately</li>\n      </ul>\n    </div>\n  </div>\n  <p><strong>Design principle:</strong> Short-lived access tokens limit damage from theft. Long-lived refresh tokens enable seamless UX without constant re-authentication.</p>\n</div>\n\n<div class=\"concept-section\">\n  <h3>The Refresh Token Flow</h3>\n  <p>When an access token expires, the client uses the refresh token to get a new one without user interaction:</p>\n  <div style=\"background: #f8f9fa; padding: 10px; font-family: monospace; font-size: 14px; margin: 10px 0; line-height: 1.6;\">\n    1. Client calls API with access token<br>\n    2. API returns 401 Unauthorized (token expired)<br>\n    3. Client sends refresh token to auth server:<br>\n    &nbsp;&nbsp;POST /token<br>\n    &nbsp;&nbsp;grant_type=refresh_token<br>\n    &nbsp;&nbsp;refresh_token=REFRESH_TOKEN_HERE<br>\n    <br>\n    4. Auth server validates and returns:<br>\n    &nbsp;&nbsp;{<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;\"access_token\": \"new_token\",<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;\"refresh_token\": \"new_refresh_token\",&nbsp;&nbsp;‚Üê May rotate<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;\"expires_in\": 3600<br>\n    &nbsp;&nbsp;}<br>\n    <br>\n    5. Client retries API call with new access token\n  </div>\n</div>\n\n<div class=\"concept-section\">\n  <h3>Token Storage: Security Trade-offs</h3>\n  <p>Where you store tokens depends on your client type and acceptable risk level.</p>\n  <h4>Web Application Storage Options</h4>\n  <div style=\"display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;\">\n    <div style=\"background: #ffebee; padding: 20px; border-radius: 10px;\">\n      <h5>‚ùå Insecure Storage</h5>\n      <p><strong>localStorage / sessionStorage / Regular Cookies</strong></p>\n      <ul>\n        <li>Vulnerable to XSS attacks</li>\n        <li>Accessible to JavaScript</li>\n        <li>Can be stolen by malicious scripts</li>\n      </ul>\n      <p><strong>Verdict:</strong> Avoid for sensitive tokens</p>\n    </div>\n    <div style=\"background: #e8f5e8; padding: 20px; border-radius: 10px;\">\n      <h5>‚úÖ Secure Storage</h5>\n      <p><strong>HttpOnly + Secure + SameSite Cookies</strong></p>\n      <ul>\n        <li>Not accessible to JavaScript</li>\n        <li>Secure flag ensures HTTPS only</li>\n        <li>SameSite prevents CSRF attacks</li>\n        <li>Requires backend to set cookies</li>\n      </ul>\n      <p><strong>Verdict:</strong> Best practice for web apps</p>\n    </div>\n  </div>\n</div>\n\n<div class=\"concept-section\">\n  <h4>Mobile Application Storage</h4>\n  <ul>\n    <li>‚úÖ <strong>iOS Keychain:</strong> Encrypted, OS-level secure storage (recommended)</li>\n    <li>‚úÖ <strong>Android Keystore:</strong> Hardware-backed encryption (recommended)</li>\n    <li>‚ùå <strong>Plain text storage:</strong> Never store tokens unencrypted</li>\n  </ul>\n</div>\n\n<div class=\"concept-section\">\n  <h3>Understanding XSS vs CSRF Vulnerabilities</h3>\n  <div style=\"background: #f8f9fa; padding: 20px; border-radius: 10px; margin: 20px 0;\">\n    <p><strong>XSS (Cross-Site Scripting):</strong> Attacker injects malicious JavaScript that steals tokens from localStorage or cookies</p>\n    <p><strong>CSRF (Cross-Site Request Forgery):</strong> Attacker tricks browser into sending authenticated requests using your cookies</p>\n    <br>\n    <table style=\"width: 100%; border-collapse: collapse;\">\n      <tr style=\"background: #e0e0e0;\">\n        <th style=\"padding: 10px; text-align: left;\">Storage Method</th>\n        <th style=\"padding: 10px; text-align: center;\">XSS Risk</th>\n        <th style=\"padding: 10px; text-align: center;\">CSRF Risk</th>\n      </tr>\n      <tr>\n        <td style=\"padding: 10px; border-bottom: 1px solid #ccc;\">localStorage</td>\n        <td style=\"padding: 10px; border-bottom: 1px solid #ccc; text-align: center;\">‚ùå High</td>\n        <td style=\"padding: 10px; border-bottom: 1px solid #ccc; text-align: center;\">‚úÖ None</td>\n      </tr>\n      <tr>\n        <td style=\"padding: 10px; border-bottom: 1px solid #ccc;\">Regular Cookie</td>\n        <td style=\"padding: 10px; border-bottom: 1px solid #ccc; text-align: center;\">‚ùå High</td>\n        <td style=\"padding: 10px; border-bottom: 1px solid #ccc; text-align: center;\">‚ùå High</td>\n      </tr>\n      <tr>\n        <td style=\"padding: 10px; border-bottom: 1px solid #ccc;\">HttpOnly Cookie</td>\n        <td style=\"padding: 10px; border-bottom: 1px solid #ccc; text-align: center;\">‚úÖ Protected</td>\n        <td style=\"padding: 10px; border-bottom: 1px solid #ccc; text-align: center;\">‚ö†Ô∏è Medium</td>\n      </tr>\n      <tr>\n        <td style=\"padding: 10px;\">HttpOnly + SameSite Cookie</td>\n        <td style=\"padding: 10px; text-align: center;\">‚úÖ Protected</td>\n        <td style=\"padding: 10px; text-align: center;\">‚úÖ Protected</td>\n      </tr>\n    </table>\n  </div>\n</div>\n\n<div class=\"concept-section\">\n  <h3>Refresh Token Rotation</h3>\n  <p>Modern security best practice: issue a new refresh token every time it's used, and invalidate the old one.</p>\n  <ul>\n    <li>‚úÖ <strong>Limits damage:</strong> Stolen refresh token becomes useless after next legitimate use</li>\n    <li>‚úÖ <strong>Detects theft:</strong> If old refresh token is reused, indicates compromise</li>\n    <li>‚úÖ <strong>Automatic revocation:</strong> System can revoke entire token family on suspicious activity</li>\n  </ul>\n  <p><strong>Implementation:</strong> When rotation is enabled, each refresh request returns both a new access token AND a new refresh token. Store the new refresh token and discard the old one.</p>\n</div>\n\n<div class=\"concept-section\">\n  <h3>Backend-for-Frontend (BFF) Pattern</h3>\n  <p>For maximum security in single-page applications, introduce a lightweight backend proxy that handles all token operations.</p>\n  <div style=\"background: #e3f2fd; padding: 20px; border-radius: 10px; margin: 20px 0;\">\n    <h4>How BFF Works:</h4>\n    <ol>\n      <li>Frontend never sees or stores tokens</li>\n      <li>BFF backend performs OAuth/OIDC flow and gets tokens</li>\n      <li>BFF stores refresh token securely server-side</li>\n      <li>BFF issues session cookie to frontend (HttpOnly, Secure, SameSite)</li>\n      <li>Frontend sends session cookie with API requests</li>\n      <li>BFF validates session, attaches access token to upstream API calls</li>\n      <li>BFF handles token refresh transparently</li>\n    </ol>\n  </div>\n  <p><strong>Benefits:</strong> Tokens never exposed to browser, eliminates XSS risk, simplifies frontend code</p>\n  <p><strong>Trade-off:</strong> Adds infrastructure complexity and a network hop</p>\n</div>\n\n<div class=\"concept-section\">\n  <h3>Token Expiration Strategies</h3>\n  <div style=\"display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;\">\n    <div style=\"background: #fff3e0; padding: 20px; border-radius: 10px;\">\n      <h4>Short-lived Access Tokens</h4>\n      <p><strong>15-60 minutes</strong></p>\n      <ul>\n        <li>‚úÖ Minimizes impact of token theft</li>\n        <li>‚úÖ Limits unauthorized access window</li>\n        <li>‚ö†Ô∏è Requires refresh token handling</li>\n      </ul>\n      <p><strong>Use for:</strong> Most applications with sensitive data</p>\n    </div>\n    <div style=\"background: #e8f5e8; padding: 20px; border-radius: 10px;\">\n      <h4>Long-lived Refresh Tokens</h4>\n      <p><strong>7-90 days or until revoked</strong></p>\n      <ul>\n        <li>‚úÖ Better user experience (stay logged in)</li>\n        <li>‚úÖ Reduces authentication friction</li>\n        <li>‚ö†Ô∏è Must be stored very securely</li>\n      </ul>\n      <p><strong>Use for:</strong> Balancing security with UX, with rotation enabled</p>\n    </div>\n  </div>\n</div>\n\n<div class=\"concept-section\">\n  <h3>Token Revocation</h3>\n  <p>Sometimes you need to immediately invalidate tokens (user logs out, security breach, permission changes):</p>\n  <ul>\n    <li><strong>Refresh token revocation:</strong> Call authorization server's revocation endpoint to invalidate refresh token</li>\n    <li><strong>Access token revocation:</strong> Difficult since they're typically stateless. Options include:\n      <ul>\n        <li>Maintain a deny-list of revoked tokens (adds state)</li>\n        <li>Keep access tokens very short-lived</li>\n        <li>Use opaque tokens that require server lookup</li>\n      </ul>\n    </li>\n    <li><strong>Session revocation:</strong> In BFF pattern, simply delete server-side session</li>\n  </ul>\n</div>\n\n<div class=\"exercise\">\n  <h3>üõ†Ô∏è Design a Secure Token Strategy</h3>\n  <p><strong>Scenario:</strong> You're architecting authentication for three different applications:</p>\n  <ol>\n    <li><strong>Public web app:</strong> E-commerce site accessible to anyone, handles payment information</li>\n    <li><strong>Internal admin dashboard:</strong> React SPA used by 50 employees, manages sensitive customer data</li>\n    <li><strong>Mobile banking app:</strong> Native iOS/Android app with very high security requirements</li>\n  </ol>\n  <p><strong>Your task:</strong> For each application, specify:</p>\n  <ul>\n    <li>Where and how you'd store access tokens and refresh tokens</li>\n    <li>What token expiration times you'd use and why</li>\n    <li>Whether you'd implement token rotation</li>\n    <li>Whether you'd use the BFF pattern</li>\n    <li>Your strategy for handling token revocation</li>\n  </ul>\n  <p><strong>Consider:</strong> How do the security requirements differ between public users, employees, and banking customers? What's the acceptable trade-off between security and user experience for each?</p>\n</div>"
    }
  ]
}