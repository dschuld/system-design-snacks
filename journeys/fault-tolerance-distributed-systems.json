{
  "id": "fault-tolerance-distributed-systems",
  "title": "Fault Tolerance in Distributed Systems",
  "totalLessons": 6,
  "available": true,
  "lessons": [
    {
      "id": 1,
      "title": "Why Distributed Systems Fail (And Why That's Normal)",
      "goals": [
        "Understand why failures are inevitable in distributed systems at scale",
        "Identify the different types of failures that can occur in distributed environments",
        "Recognize the fallacies of distributed computing that lead to design mistakes"
      ],
      "content": "<div class=\"concept-section\">\n  <h3>Failure Is Not the Exception‚ÄîIt's the Operating Model</h3>\n  <p>Imagine running a restaurant where your kitchen, dining room, and payment system are in three different buildings connected by phones. Now imagine those phones randomly disconnect, messages arrive out of order, and sometimes you hear about orders that were never placed. This is the reality of distributed systems.</p>\n  <p>In a monolithic application on a single server, failures are relatively rare events. In distributed systems with hundreds or thousands of nodes, <strong>failures happen constantly</strong>. The question isn't \"if\" something will fail, but \"what's failing right now\" and \"how do we keep serving requests anyway?\"</p>\n</div>\n<div class=\"concept-section\">\n  <h3>The Scale of Failure in Production Systems</h3>\n  <p>Real-world data shows just how common failures are at scale:</p>\n  <ul>\n    <li><strong>Google:</strong> <a href=\"https://static.googleusercontent.com/media/research.google.com/en//archive/disk_failures.pdf\" target=\"_blank\" rel=\"noopener noreferrer\">Studies show that in large-scale storage systems, 2-4% of disks fail annually</a>, and when you have 100,000 drives, that's 2,000-4,000 failures per year</li>\n    <li><strong>Network failures:</strong> <a href=\"https://www.microsoft.com/en-us/research/publication/understanding-network-failures-in-data-centers-measurement-analysis-and-implications/\" target=\"_blank\" rel=\"noopener noreferrer\">Microsoft Research found that data center networks experience failures affecting ~5.2 devices per day</a> in a typical data center</li>\n    <li><strong>Server lifespans:</strong> <a href=\"https://dl.acm.org/doi/10.1145/1272996.1273020\" target=\"_blank\" rel=\"noopener noreferrer\">Industry studies indicate median server replacement cycles of 3-5 years</a>, meaning 20-33% of your fleet is replaced annually</li>\n    <li><strong>Memory errors:</strong> <a href=\"https://research.google/pubs/pub35162/\" target=\"_blank\" rel=\"noopener noreferrer\">Google's analysis shows 8% of DIMMs experience correctable errors per year</a></li>\n  </ul>\n  <p>At scale, something is <em>always</em> failing. Systems must be designed to continue operating despite these failures.</p>\n</div>\n<div class=\"concept-section\">\n  <h3>Types of Failures in Distributed Systems</h3>\n  <div style=\"background: #f8f9fa; padding: 20px; border-radius: 10px; margin: 20px 0;\">\n    <h4>Crash Failures (Fail-Stop)</h4>\n    <p>A node stops functioning entirely and stops responding to all requests.</p>\n    <ul>\n      <li>‚úì Easy to detect (no heartbeat response)</li>\n      <li>‚úì Clean failure mode‚Äînode doesn't send incorrect data</li>\n      <li>‚úó Can lose in-progress work</li>\n    </ul>\n  </div>\n  <div style=\"background: #fff3e0; padding: 20px; border-radius: 10px; margin: 20px 0;\">\n    <h4>Omission Failures</h4>\n    <p>Messages are lost, either sent but never received, or never sent at all.</p>\n    <ul>\n      <li>‚úó Hard to distinguish from slow responses</li>\n      <li>‚úó Can cause data inconsistency</li>\n      <li>‚úó Requires timeout-based detection</li>\n    </ul>\n  </div>\n  <div style=\"background: #ffebee; padding: 20px; border-radius: 10px; margin: 20px 0;\">\n    <h4>Timing Failures</h4>\n    <p>Responses arrive, but outside acceptable time bounds (too late or too early).</p>\n    <ul>\n      <li>‚úó Can cause cascading failures</li>\n      <li>‚úó Difficult to distinguish from network congestion</li>\n      <li>‚úó May trigger unnecessary failover</li>\n    </ul>\n  </div>\n  <div style=\"background: #fce4ec; padding: 20px; border-radius: 10px; margin: 20px 0;\">\n    <h4>Byzantine Failures</h4>\n    <p>Nodes send arbitrary or malicious responses‚Äîthe most difficult failure mode.</p>\n    <ul>\n      <li>‚úó Extremely hard to detect</li>\n      <li>‚úó Requires complex consensus protocols (Byzantine Fault Tolerance)</li>\n      <li>‚úó Can corrupt system state</li>\n    </ul>\n  </div>\n</div>\n<div class=\"concept-section\">\n  <h3>The Eight Fallacies of Distributed Computing</h3>\n  <p>These false assumptions, <a href=\"https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing\" target=\"_blank\" rel=\"noopener noreferrer\">originally identified by engineers at Sun Microsystems</a>, lead to fragile distributed systems:</p>\n  <ol>\n    <li><strong>The network is reliable</strong> ‚Üí Networks fail constantly; packets get lost</li>\n    <li><strong>Latency is zero</strong> ‚Üí Network calls take time; this affects consistency guarantees</li>\n    <li><strong>Bandwidth is infinite</strong> ‚Üí Sending large payloads can saturate links</li>\n    <li><strong>The network is secure</strong> ‚Üí Attackers can intercept or modify traffic</li>\n    <li><strong>Topology doesn't change</strong> ‚Üí Nodes join, leave, and fail constantly</li>\n    <li><strong>There is one administrator</strong> ‚Üí Multiple teams manage different components</li>\n    <li><strong>Transport cost is zero</strong> ‚Üí Serialization, network I/O, and parsing all have costs</li>\n    <li><strong>The network is homogeneous</strong> ‚Üí Different protocols, versions, and implementations coexist</li>\n  </ol>\n</div>\n<div class=\"concept-section\">\n  <h3>Why Traditional Reliability Approaches Fail</h3>\n  <div style=\"display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;\">\n    <div style=\"background: #e8f5e8; padding: 20px; border-radius: 10px;\">\n      <h4>Monolithic Reliability</h4>\n      <ul>\n        <li>‚úì Single point of failure to protect</li>\n        <li>‚úì ACID transactions guarantee consistency</li>\n        <li>‚úì Synchronous operations easier to reason about</li>\n        <li>‚úó Cannot scale beyond single machine capacity</li>\n      </ul>\n    </div>\n    <div style=\"background: #e3f2fd; padding: 20px; border-radius: 10px;\">\n      <h4>Distributed Reliability</h4>\n      <ul>\n        <li>‚úì Scales horizontally across many nodes</li>\n        <li>‚úì No single point of failure</li>\n        <li>‚úó Must handle partial failures</li>\n        <li>‚úó Network becomes a failure domain</li>\n        <li>‚úó Consistency is harder to achieve</li>\n      </ul>\n    </div>\n  </div>\n</div>\n<div class=\"concept-section\">\n  <h3>The Shift in Thinking: From Preventing Failures to Tolerating Them</h3>\n  <p>In distributed systems, you cannot prevent all failures. The design philosophy shifts to:</p>\n  <ul>\n    <li><strong>Assume failures will happen</strong> and design for graceful degradation</li>\n    <li><strong>Detect failures quickly</strong> through health checks and monitoring</li>\n    <li><strong>Isolate failures</strong> to prevent cascading effects</li>\n    <li><strong>Recover automatically</strong> without human intervention</li>\n    <li><strong>Degrade gracefully</strong> by reducing functionality rather than failing completely</li>\n  </ul>\n</div>\n<div class=\"exercise\">\n  <h3>üõ†Ô∏è Identify Failure Modes in Your System</h3>\n  <p><strong>Scenario:</strong> You're designing a distributed e-commerce checkout system with these components:</p>\n  <ul>\n    <li><strong>API Gateway:</strong> Routes requests to backend services</li>\n    <li><strong>Inventory Service:</strong> Checks product availability (reads from database)</li>\n    <li><strong>Payment Service:</strong> Processes credit card transactions (calls external payment processor)</li>\n    <li><strong>Order Service:</strong> Creates order records (writes to database)</li>\n    <li><strong>Notification Service:</strong> Sends order confirmation emails (uses message queue)</li>\n  </ul>\n  <p><strong>Your task:</strong> For each component, identify:</p>\n  <ol>\n    <li>What type of failure could occur (crash, omission, timing, byzantine)?</li>\n    <li>How would you detect this failure?</li>\n    <li>What's the impact if this component fails during checkout?</li>\n  </ol>\n  <p><strong>Consider:</strong> What happens if the payment processor responds \"success\" but the network drops before your service receives the response? How would you detect and handle this?</p>\n</div>"
    },
    {
      "id": 2,
      "title": "The CAP Theorem in Practice",
      "goals": [
        "Understand the fundamental trade-off between Consistency, Availability, and Partition tolerance",
        "Learn why distributed systems must choose between CP or AP during network partitions",
        "Identify real-world examples of CP and AP systems and their use cases"
      ],
      "content": "<div class=\"concept-section\">\n  <h3>The Impossible Trinity of Distributed Systems</h3>\n  <p>Imagine you're managing a chain of bank branches. You want three things: (1) all branches show the same account balance, (2) customers can always withdraw money at any branch, and (3) branches can operate even when phone lines are down. The CAP theorem, <a href=\"https://dl.acm.org/doi/10.1145/343477.343502\" target=\"_blank\" rel=\"noopener noreferrer\">formalized by Eric Brewer in 2000</a>, proves you can only guarantee two of these three properties simultaneously.</p>\n  <p>CAP stands for:</p>\n  <ul>\n    <li><strong>Consistency:</strong> All nodes see the same data at the same time</li>\n    <li><strong>Availability:</strong> Every request receives a response (success or failure)</li>\n    <li><strong>Partition tolerance:</strong> System continues operating despite network failures between nodes</li>\n  </ul>\n</div>\n<div class=\"concept-section\">\n  <h3>Understanding Each Property</h3>\n  <div style=\"background: #e8f5e8; padding: 20px; border-radius: 10px; margin: 20px 0;\">\n    <h4>Consistency (C)</h4>\n    <p>Every read receives the most recent write or an error. If you write \"balance = $100\" to the system, any subsequent read must return $100 or fail‚Äînever an outdated value like $50.</p>\n    <ul>\n      <li>‚úì Guarantees data correctness</li>\n      <li>‚úì Simplifies application logic‚Äîno stale data</li>\n      <li>‚úó Requires coordination between nodes</li>\n      <li>‚úó Can increase latency</li>\n    </ul>\n  </div>\n  <div style=\"background: #e3f2fd; padding: 20px; border-radius: 10px; margin: 20px 0;\">\n    <h4>Availability (A)</h4>\n    <p>Every request to a non-failing node must receive a response. Even if some nodes are down, the system continues serving requests from healthy nodes.</p>\n    <ul>\n      <li>‚úì System remains operational during failures</li>\n      <li>‚úì Better user experience‚Äîno error responses</li>\n      <li>‚úó May return stale data</li>\n      <li>‚úó Can lead to conflicting updates</li>\n    </ul>\n  </div>\n  <div style=\"background: #fff3e0; padding: 20px; border-radius: 10px; margin: 20px 0;\">\n    <h4>Partition Tolerance (P)</h4>\n    <p>The system continues to operate despite network failures that prevent some nodes from communicating. In practice, <strong>partitions are inevitable</strong> in distributed systems, so you must choose partition tolerance.</p>\n    <ul>\n      <li>‚úì System survives network failures</li>\n      <li>‚úì Required for any distributed system</li>\n      <li>‚úó Forces trade-off between C and A</li>\n    </ul>\n  </div>\n</div>\n<div class=\"concept-section\">\n  <h3>The Real Choice: CP vs AP</h3>\n  <p>Since network partitions are unavoidable in distributed systems, <strong>you must tolerate partitions (P)</strong>. The practical choice becomes: when a partition occurs, do you prioritize <strong>Consistency</strong> or <strong>Availability</strong>?</p>\n  <div style=\"display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;\">\n    <div style=\"background: #f3e5f5; padding: 20px; border-radius: 10px;\">\n      <h4>CP Systems (Consistency + Partition Tolerance)</h4>\n      <p><strong>Decision:</strong> Sacrifice availability to maintain consistency during partitions</p>\n      <ul>\n        <li>System refuses requests during partition</li>\n        <li>Returns errors rather than stale data</li>\n        <li>Waits for partition to heal before responding</li>\n      </ul>\n      <p><strong>Examples:</strong> HBase, MongoDB (with strong consistency), etcd, ZooKeeper</p>\n    </div>\n    <div style=\"background: #e0f2f1; padding: 20px; border-radius: 10px;\">\n      <h4>AP Systems (Availability + Partition Tolerance)</h4>\n      <p><strong>Decision:</strong> Sacrifice consistency to remain available during partitions</p>\n      <ul>\n        <li>System continues serving requests</li>\n        <li>May return stale data</li>\n        <li>Accepts conflicting updates</li>\n        <li>Resolves conflicts after partition heals</li>\n      </ul>\n      <p><strong>Examples:</strong> Cassandra, DynamoDB, Riak, CouchDB</p>\n    </div>\n  </div>\n</div>\n<div class=\"concept-section\">\n  <h3>Real-World Decision Framework</h3>\n  <p>Choosing between CP and AP depends on your application requirements:</p>\n  <div style=\"background: #f8f9fa; padding: 10px; font-family: monospace; margin: 10px 0;\">\n    if (data_correctness_is_critical) {<br>\n    &nbsp;&nbsp;‚Üí Choose CP (banking, inventory, bookings)<br>\n    &nbsp;&nbsp;‚Üí Better to show error than wrong balance<br>\n    } else if (system_must_always_respond) {<br>\n    &nbsp;&nbsp;‚Üí Choose AP (social media, caching, analytics)<br>\n    &nbsp;&nbsp;‚Üí Stale data acceptable; eventual consistency OK<br>\n    }\n  </div>\n</div>\n<div class=\"concept-section\">\n  <h3>Case Study: CP System in Action (Banking)</h3>\n  <p><strong>Scenario:</strong> A distributed banking system using a CP database</p>\n  <p><strong>Normal operation:</strong></p>\n  <ul>\n    <li>User checks balance: $1000</li>\n    <li>User withdraws $100</li>\n    <li>All nodes updated: balance = $900</li>\n    <li>User checks balance anywhere: $900 ‚úì</li>\n  </ul>\n  <p><strong>During network partition:</strong></p>\n  <ul>\n    <li>Network splits: Node A cannot reach Node B</li>\n    <li>User tries to withdraw $100 from Node A</li>\n    <li>Node A cannot confirm with Node B</li>\n    <li>Node A <strong>rejects the request</strong> with error</li>\n    <li>‚úì Consistency maintained‚Äîno incorrect balance</li>\n    <li>‚úó Availability lost‚Äîuser cannot withdraw</li>\n  </ul>\n  <p><strong>Why this matters:</strong> Better to temporarily prevent withdrawals than risk allowing overdrafts or inconsistent balances.</p>\n</div>\n<div class=\"concept-section\">\n  <h3>Case Study: AP System in Action (Social Media)</h3>\n  <p><strong>Scenario:</strong> A social media platform using an AP database (like Cassandra)</p>\n  <p><strong>Normal operation:</strong></p>\n  <ul>\n    <li>User posts: \"Hello World!\"</li>\n    <li>Post propagates to all datacenters</li>\n    <li>All users see the post ‚úì</li>\n  </ul>\n  <p><strong>During network partition:</strong></p>\n  <ul>\n    <li>Trans-Atlantic cable cut: US datacenter isolated from EU</li>\n    <li>User in US updates profile: \"New York\"</li>\n    <li>User in EU updates profile: \"London\"</li>\n    <li>Both updates <strong>succeed locally</strong></li>\n    <li>‚úì Availability maintained‚Äîboth users can update</li>\n    <li>‚úó Consistency lost‚Äîconflicting profile data</li>\n  </ul>\n  <p><strong>After partition heals:</strong> System must resolve conflict (typically last-write-wins or vector clocks)</p>\n  <p><strong>Why this matters:</strong> Users can continue posting and interacting even during network failures. Brief inconsistency is acceptable for better user experience.</p>\n</div>\n<div class=\"concept-section\">\n  <h3>Common Misconceptions About CAP</h3>\n  <div style=\"background: #ffebee; padding: 20px; border-radius: 10px; margin: 20px 0;\">\n    <h4>‚ö†Ô∏è CAP Clarifications</h4>\n    <ul>\n      <li><strong>Misconception:</strong> \"My system is CA (no partition tolerance)\"<br>\n      <strong>Reality:</strong> Network partitions happen whether you plan for them or not. CA systems simply fail during partitions.</li>\n      <li><strong>Misconception:</strong> \"The choice is permanent\"<br>\n      <strong>Reality:</strong> Many systems allow tuning consistency vs availability per operation (e.g., Cassandra's consistency levels)</li>\n      <li><strong>Misconception:</strong> \"CAP means you can't have consistency AND availability\"<br>\n      <strong>Reality:</strong> Under CAP, you can have both consistency and availability when there is no partition ‚Äî but in practice, systems that prioritize availability often sacrifice immediate consistency even during normal operation.</li>\n    </ul>\n  </div>\n</div>\n<div class=\"concept-section\">\n  <h3>Beyond CAP: The PACELC Theorem</h3>\n  <p><a href=\"https://dl.acm.org/doi/10.1145/2360352.2360369\" target=\"_blank\" rel=\"noopener noreferrer\">PACELC extends CAP</a> to describe system behavior both during partitions and normal operation:</p>\n  <ul>\n    <li><strong>P</strong>artition: During network partition, choose between <strong>A</strong>vailability or <strong>C</strong>onsistency (this is CAP)</li>\n    <li><strong>E</strong>lse: During normal operation, choose between <strong>L</strong>atency or <strong>C</strong>onsistency</li>\n  </ul>\n  <p>Examples:</p>\n  <ul>\n    <li><strong>DynamoDB:</strong> PA/EL (Available during partition, Low latency during normal operation)</li>\n    <li><strong>HBase:</strong> PC/EC (Consistent during partition, Consistent during normal operation)</li>\n  </ul>\n</div>\n<div class=\"exercise\">\n  <h3>üõ†Ô∏è Choose Your CAP Trade-off</h3>\n  <p><strong>Scenario:</strong> You need to make CAP decisions for three different systems:</p>\n  <ol>\n    <li><strong>E-commerce inventory system:</strong> Prevents overselling products (only 5 items in stock)</li>\n    <li><strong>User session cache:</strong> Stores temporary login sessions for faster page loads</li>\n    <li><strong>Multi-player game leaderboard:</strong> Shows player rankings updated every few seconds</li>\n  </ol>\n  <p><strong>Your task:</strong> For each system, decide:</p>\n  <ul>\n    <li>Would you choose CP or AP? Why?</li>\n    <li>What happens to users during a network partition?</li>\n    <li>What's the worst-case scenario if you chose the opposite approach?</li>\n  </ul>\n  <p><strong>Consider:</strong> The inventory system has a wrinkle‚Äîwould your answer change if you had 10,000 items in stock instead of 5?</p>\n</div>"
    },
    {
      "id": 3,
      "title": "Consensus and Split-Brain Scenarios",
      "goals": [
        "Understand what happens when distributed nodes disagree on system state",
        "Learn how quorum-based voting prevents split-brain scenarios",
        "Master strategies to protect against zombie leaders and data corruption"
      ],
      "content": "<div class=\"concept-section\">\n  <h3>The Split-Brain Problem</h3>\n  <p>A <strong>split-brain scenario</strong> occurs when a network partition divides your cluster into two or more groups, and each group believes it's the only functioning cluster. Both groups continue accepting writes, leading to divergent state that may be impossible to reconcile.</p>\n  <div style=\"background: #ffebee; padding: 20px; border-radius: 10px; margin: 20px 0;\">\n    <h4>‚ö†Ô∏è Split-Brain Disaster</h4>\n    <p><strong>Setup:</strong> Database with 1 primary + 2 replicas, automatic failover enabled</p>\n    <p><strong>What happens:</strong></p>\n    <ol>\n      <li>Network partition isolates the primary from the replicas</li>\n      <li>Replicas can't reach primary, assume it's dead</li>\n      <li>Replicas promote one of themselves to new primary</li>\n      <li>Old primary is still alive, still accepting writes</li>\n      <li><strong>Result:</strong> Two primaries, conflicting writes, data corruption</li>\n    </ol>\n  </div>\n</div>\n<div class=\"concept-section\">\n  <h3>Quorum: The Mathematical Solution</h3>\n  <p>The solution is simple: require a <strong>majority vote</strong> before making any decision.</p>\n  <div style=\"background: #e8f5e8; padding: 20px; border-radius: 10px; margin: 20px 0;\">\n    <h4>How Quorums Prevent Split-Brain</h4>\n    <p><strong>Key insight:</strong> Two majorities cannot exist at the same time‚Äîit's mathematically impossible.</p>\n    <p><strong>Example with 5 nodes:</strong></p>\n    <ul>\n      <li><strong>Quorum = 3 nodes</strong> (more than half)</li>\n      <li><strong>Network partition splits 3-2</strong></li>\n      <li><strong>The 3-node side:</strong> Has quorum ‚úì Can elect leader and accept writes</li>\n      <li><strong>The 2-node side:</strong> No quorum ‚úó Cannot elect leader, goes read-only</li>\n      <li><strong>Result:</strong> Only one side makes decisions, split-brain prevented</li>\n    </ul>\n  </div>\n  <p><strong>The 2F+1 rule:</strong> To tolerate F failures, you need 2F+1 nodes total</p>\n  <ul>\n    <li>3 nodes ‚Üí tolerates 1 failure</li>\n    <li>5 nodes ‚Üí tolerates 2 failures</li>\n    <li>7 nodes ‚Üí tolerates 3 failures (rarely needed)</li>\n  </ul>\n</div>\n<div class=\"concept-section\">\n  <h3>Read/Write Quorums for Consistency</h3>\n  <p>Quorums also control consistency guarantees. You configure:</p>\n  <ul>\n    <li><strong>W</strong> = nodes that must acknowledge a write</li>\n    <li><strong>R</strong> = nodes that must respond to a read</li>\n    <li><strong>N</strong> = total replica nodes</li>\n  </ul>\n  <p><strong>The magic formula: W + R > N guarantees strong consistency</strong></p>\n  <div style=\"background: #f8f9fa; padding: 10px; font-family: monospace; margin: 10px 0;\">\n    Example with N=5, W=3, R=3:<br>\n    Write to 3 nodes ‚Üí at least 3 have latest value<br>\n    Read from 3 nodes ‚Üí at least 1 must have latest value<br>\n    Why? 3 + 3 = 6 > 5, so they MUST overlap ‚úì\n  </div>\n  <div style=\"display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;\">\n    <div style=\"background: #e8f5e8; padding: 15px; border-radius: 10px;\">\n      <h4>Strong Consistency</h4>\n      <p><strong>W=3, R=3 (N=5)</strong></p>\n      <ul>\n        <li>‚úì Always read latest write</li>\n        <li>‚úó Slower, less available</li>\n      </ul>\n      <p><strong>Use for:</strong> Financial data</p>\n    </div>\n    <div style=\"background: #fff3e0; padding: 15px; border-radius: 10px;\">\n      <h4>Eventual Consistency</h4>\n      <p><strong>W=2, R=2 (N=5)</strong></p>\n      <ul>\n        <li>‚úì Faster, more available</li>\n        <li>‚úó May read stale data</li>\n      </ul>\n      <p><strong>Use for:</strong> Social feeds</p>\n    </div>\n  </div>\n</div>\n<div class=\"concept-section\">\n  <h3>Fencing Tokens: Defense Against Zombie Leaders</h3>\n  <p>Even with quorum-based leader election, there's a problem: what if the old leader doesn't know it's been replaced?</p>\n  <div style=\"background: #fff3e0; padding: 20px; border-radius: 10px; margin: 20px 0;\">\n    <h4>The Zombie Leader Problem</h4>\n    <ol>\n      <li>Leader A elected (term 1)</li>\n      <li>Network delay causes missed heartbeats</li>\n      <li>Cluster elects Leader B (term 2)</li>\n      <li>Delay resolves, but A doesn't know it's replaced</li>\n      <li><strong>Both A and B try to write‚Äîcorruption!</strong></li>\n    </ol>\n  </div>\n  <p><strong>Solution:</strong> Each leader gets an increasing token (term number). Storage rejects writes with tokens lower than the highest seen.</p>\n  <div style=\"background: #f8f9fa; padding: 10px; font-family: monospace; margin: 10px 0;\">\n    Leader A writes with token=1 ‚Üí Storage accepts ‚úì<br>\n    Leader B writes with token=2 ‚Üí Storage accepts ‚úì<br>\n    Zombie A tries token=1 ‚Üí Storage rejects (1 < 2) ‚úì\n  </div>\n  <p><strong>Why both quorum AND fencing?</strong> Quorum prevents split-brain at election. Fencing tokens provide a safety net if network delays cause confusion.</p>\n</div>\n<div class=\"exercise\">\n  <h3>üõ†Ô∏è Analyze Split-Brain Scenarios</h3>\n  <p><strong>Scenario 1: Partition Voting</strong></p>\n  <p>5-node cluster splits into {A, B} and {C, D, E} during network partition.</p>\n  <p><strong>Questions:</strong></p>\n  <ul>\n    <li>Which side can elect a new leader?</li>\n    <li>What happens to writes sent to nodes A and B?</li>\n    <li>When partition heals, what happens?</li>\n  </ul>\n  <p><strong>Scenario 2: Quorum Configuration</strong></p>\n  <p>You have N=5 replicas. Configure W and R for:</p>\n  <ol>\n    <li><strong>Bank account balances:</strong> Must be strongly consistent</li>\n    <li><strong>Product view counts:</strong> Eventual consistency OK</li>\n  </ol>\n  <p><strong>Consider:</strong> What if 2 nodes fail? Can your configurations still work?</p>\n</div>"
    },
    {
      "id": 4,
      "title": "Eventual Consistency Patterns",
      "goals": [
        "Understand the trade-offs between strong and eventual consistency",
        "Learn practical conflict resolution strategies for eventually consistent systems",
        "Identify when eventual consistency is appropriate and when it's dangerous"
      ],
      "content": "<div class=\"concept-section\">\n  <h3>The Consistency Spectrum</h3>\n  <p>Strong consistency (every read sees the latest write) is expensive in distributed systems. It requires coordination, reduces availability, and increases latency. Most real-world systems make deliberate trade-offs along the <strong>consistency spectrum</strong>.</p>\n  <div style=\"background: #f8f9fa; padding: 20px; border-radius: 10px; margin: 20px 0;\">\n    <h4>From Strongest to Weakest:</h4>\n    <ul>\n      <li><strong>Strong Consistency:</strong> Every read sees latest write immediately</li>\n      <li><strong>Causal Consistency:</strong> Related operations appear in correct order</li>\n      <li><strong>Session Consistency:</strong> You see your own writes; others may not</li>\n      <li><strong>Eventual Consistency:</strong> All replicas converge eventually, but reads may be stale</li>\n    </ul>\n  </div>\n</div>\n<div class=\"concept-section\">\n  <h3>What Is Eventual Consistency?</h3>\n  <p>Eventual consistency guarantees that <em>if no new updates are made</em>, all replicas will eventually converge to the same value. There's no time bound‚Äî\"eventually\" could be milliseconds or minutes.</p>\n  <ul>\n    <li>‚úì <strong>High availability:</strong> Replicas accept writes independently, no coordination needed</li>\n    <li>‚úì <strong>Low latency:</strong> Don't wait for other nodes to respond</li>\n    <li>‚úì <strong>Partition tolerance:</strong> Each partition continues operating during network failures</li>\n    <li>‚úó <strong>Temporary inconsistency:</strong> Different replicas may return different values</li>\n    <li>‚úó <strong>Conflict resolution required:</strong> Concurrent updates must be reconciled</li>\n  </ul>\n  <p><strong>The trade-off:</strong> Give up immediate consistency to gain availability and performance.</p>\n</div>\n<div class=\"concept-section\">\n  <h3>Session Consistency: Read-Your-Writes</h3>\n  <p>A practical middle ground‚Äîstronger than eventual consistency but weaker than strong consistency:</p>\n  <ul>\n    <li><strong>Guarantee:</strong> A client always sees its own writes</li>\n    <li><strong>No guarantee:</strong> Other clients may see stale data temporarily</li>\n  </ul>\n  <div style=\"background: #e8f5e8; padding: 20px; border-radius: 10px; margin: 20px 0;\">\n    <h4>Example: Social Media Profile Update</h4>\n    <ol>\n      <li>You update your profile picture ‚Üí Write goes to Replica A</li>\n      <li>You immediately view your profile ‚Üí Read goes to Replica A ‚Üí You see new picture ‚úì</li>\n      <li>Friend views your profile ‚Üí Read goes to Replica B ‚Üí Sees old picture temporarily ‚úó</li>\n      <li>After seconds/minutes, Replica B syncs ‚Üí Friend sees new picture ‚úì</li>\n    </ol>\n    <p><strong>Implementation:</strong> Route each user's requests to the same replica (sticky sessions) or use version tracking.</p>\n  </div>\n</div>\n<div class=\"concept-section\">\n  <h3>Conflict Resolution: Last-Write-Wins</h3>\n  <p>The simplest strategy: use timestamps to determine which write is \"newest\" and discard others.</p>\n  <ul>\n    <li>‚úì Simple to implement</li>\n    <li>‚úì Always converges to single value</li>\n    <li>‚úó <strong>Loses data</strong>‚Äîearlier writes are permanently discarded</li>\n    <li>‚úó Requires synchronized clocks (or logical clocks)</li>\n  </ul>\n  <p><strong>Best for:</strong> Cache values, session data, metrics‚Äîanything where losing some writes is acceptable.</p>\n  <div style=\"background: #f8f9fa; padding: 10px; font-family: monospace; margin: 10px 0;\">\n    User updates profile location:<br>\n    Replica A: location=\"New York\" timestamp=10:00:01<br>\n    Replica B: location=\"London\" timestamp=10:00:03<br><br>\n    After sync: Both keep \"London\" (newer timestamp) ‚úì<br>\n    \"New York\" is lost forever ‚úó\n  </div>\n</div>\n<div class=\"concept-section\">\n  <h3>Conflict Resolution: Keep All Values (Siblings)</h3>\n  <p>Instead of discarding conflicts, preserve all concurrent writes and let the application resolve them.</p>\n  <ul>\n    <li>‚úì No data loss‚Äîall writes preserved</li>\n    <li>‚úì Application can choose best resolution strategy</li>\n    <li>‚úó Complexity pushed to application layer</li>\n    <li>‚úó Storage overhead for multiple values</li>\n  </ul>\n  <div style=\"background: #e3f2fd; padding: 20px; border-radius: 10px; margin: 20px 0;\">\n    <h4>The Shopping Cart Problem</h4>\n    <p><strong>Scenario:</strong> User adds items from two different devices simultaneously</p>\n    <ul>\n      <li>Device A adds \"Laptop\" ‚Üí Replica 1: cart={Laptop}</li>\n      <li>Device B adds \"Mouse\" ‚Üí Replica 2: cart={Mouse}</li>\n      <li>Conflict detected: cart has two versions</li>\n    </ul>\n    <p><strong>Bad resolution:</strong> Last-Write-Wins ‚Üí One item disappears ‚úó</p>\n    <p><strong>Good resolution:</strong> Merge both ‚Üí cart={Laptop, Mouse} ‚úì</p>\n    <p><strong>Used by:</strong> <a href=\"https://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf\" target=\"_blank\" rel=\"noopener noreferrer\">Amazon's Dynamo</a> for shopping carts</p>\n  </div>\n</div>\n<div class=\"concept-section\">\n  <h3>CRDTs: Conflict-Free Data Types</h3>\n  <p><a href=\"https://hal.inria.fr/inria-00555588/document\" target=\"_blank\" rel=\"noopener noreferrer\">CRDTs</a> are data structures designed to automatically merge without conflicts. No conflict resolution logic needed‚Äîmerges are deterministic and commutative.</p>\n  <div style=\"display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;\">\n    <div style=\"background: #e8f5e8; padding: 15px; border-radius: 10px;\">\n      <h4>G-Counter (Grow-Only)</h4>\n      <p>Counter that only increments</p>\n      <ul>\n        <li>Each node has own counter</li>\n        <li>Merge: take max of each counter</li>\n        <li>Total = sum of all counters</li>\n      </ul>\n      <p><strong>Use:</strong> Page views, likes</p>\n    </div>\n    <div style=\"background: #e3f2fd; padding: 15px; border-radius: 10px;\">\n      <h4>OR-Set (Add/Remove)</h4>\n      <p>Set supporting add and remove</p>\n      <ul>\n        <li>Each element has unique ID</li>\n        <li>Tracks adds and removes separately</li>\n        <li>Add wins over remove</li>\n      </ul>\n      <p><strong>Use:</strong> Collaborative editing</p>\n    </div>\n  </div>\n  <p><strong>Trade-off:</strong> CRDTs are powerful but limited‚Äînot all data structures have CRDT equivalents. Used by: Redis (geo-replication), Riak, collaborative editing tools.</p>\n</div>\n<div class=\"concept-section\">\n  <h3>When to Use Eventual Consistency</h3>\n  <div style=\"display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;\">\n    <div style=\"background: #e8f5e8; padding: 20px; border-radius: 10px;\">\n      <h4>‚úì Good Use Cases</h4>\n      <ul>\n        <li><strong>Social media feeds:</strong> Stale posts acceptable</li>\n        <li><strong>Product catalogs:</strong> Price updates can lag</li>\n        <li><strong>Analytics/metrics:</strong> Approximate counts fine</li>\n        <li><strong>Shopping carts:</strong> Conflicts rare, easily merged</li>\n        <li><strong>DNS, CDN:</strong> Built for eventual consistency</li>\n      </ul>\n    </div>\n    <div style=\"background: #ffebee; padding: 20px; border-radius: 10px;\">\n      <h4>‚úó Bad Use Cases</h4>\n      <ul>\n        <li><strong>Bank balances:</strong> Wrong balance = disaster</li>\n        <li><strong>Limited inventory:</strong> Overselling is costly</li>\n        <li><strong>Reservations:</strong> Double-booking unacceptable</li>\n        <li><strong>Access control:</strong> Security implications</li>\n        <li><strong>Auction bids:</strong> Wrong winner = lawsuit</li>\n      </ul>\n    </div>\n  </div>\n</div>\n<div class=\"concept-section\">\n  <h3>Tuning Consistency Per Operation</h3>\n  <p>Modern databases like Cassandra allow <strong>per-query consistency levels</strong>, letting you choose the right trade-off for each operation:</p>\n  <div style=\"background: #f8f9fa; padding: 10px; font-family: monospace; margin: 10px 0;\">\n    // Critical read - must be consistent<br>\n    SELECT balance FROM accounts WHERE user_id=123<br>\n    CONSISTENCY QUORUM;<br><br>\n    // Timeline read - eventual is fine<br>\n    SELECT * FROM posts WHERE user_id=123<br>\n    CONSISTENCY ONE;\n  </div>\n  <ul>\n    <li><strong>ONE:</strong> Read from any single replica (fastest, least consistent)</li>\n    <li><strong>QUORUM:</strong> Read from majority (balanced)</li>\n    <li><strong>ALL:</strong> Read from all replicas (slowest, most consistent)</li>\n  </ul>\n</div>\n<div class=\"exercise\">\n  <h3>üõ†Ô∏è Choose Your Consistency Model</h3>\n  <p><strong>Scenario:</strong> You're building a ride-sharing app with the following features:</p>\n  <ol>\n    <li><strong>Driver location updates:</strong> GPS coordinates updated every 2 seconds</li>\n    <li><strong>Ride requests:</strong> User requests a ride, must be matched to exactly one driver</li>\n    <li><strong>Ride history:</strong> Past rides displayed in user profile</li>\n    <li><strong>Driver ratings:</strong> Users rate drivers after rides</li>\n  </ol>\n  <p><strong>Your task:</strong> For each feature, decide:</p>\n  <ul>\n    <li>Strong consistency or eventual consistency?</li>\n    <li>What conflict resolution strategy (if eventual)?</li>\n    <li>What's the worst case if you get stale data?</li>\n  </ul>\n  <p><strong>Consider:</strong> What happens if two users simultaneously request the same driver? How would you prevent double-booking with eventual consistency?</p>\n</div>"
    }
  ]
}