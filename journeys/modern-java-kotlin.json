{
  "id": "modern-java-kotlin",
  "title": "Modern Java for Kotlin Developers: Java 17-23 Features",
  "totalLessons": 6,
  "available": true,
  "lessons": [
    {
      "id": 1,
      "title": "Pattern Matching Revolution: instanceof and switch",
      "goals": [
        "Master pattern matching for instanceof with automatic variable binding",
        "Understand pattern matching in switch expressions and statements",
        "Compare Java's pattern matching evolution with Kotlin's when and is operators"
      ],
      "content": "<div class=\"concept-section\">\n  <h3>Java Finally Gets Smart Type Narrowing</h3>\n  <p>Remember writing this in old Java?</p>\n  <div style=\"background: #f8f9fa; padding: 10px; font-family: monospace; margin: 10px 0;\">\n    if (obj instanceof String) {<br>\n    &nbsp;&nbsp;String s = (String) obj;<br>\n    &nbsp;&nbsp;System.out.println(s.toUpperCase());<br>\n    }\n  </div>\n  <p>As a Kotlin developer, you know this is ridiculous compared to:</p>\n  <div style=\"background: #e8f5e8; padding: 10px; font-family: monospace; margin: 10px 0;\">\n    if (obj is String) {<br>\n    &nbsp;&nbsp;println(obj.toUpperCase())<br>\n    }\n  </div>\n  <p>Good news: <strong>Java 16+</strong> finally caught up with <strong>pattern matching for instanceof</strong>:</p>\n  <div style=\"background: #e3f2fd; padding: 10px; font-family: monospace; margin: 10px 0;\">\n    if (obj instanceof String s) {<br>\n    &nbsp;&nbsp;System.out.println(s.toUpperCase());<br>\n    }\n  </div>\n  <p>The cast is gone! The variable <code>s</code> is automatically bound and scoped to where the pattern matches.</p>\n</div>\n<div class=\"concept-section\">\n  <h3>Pattern Variables: Scope and Flow-Sensitive Typing</h3>\n  <p>Java's pattern variables work with <strong>flow-sensitive typing</strong> - they're only in scope where the compiler knows the pattern matched:</p>\n  <div style=\"background: #f8f9fa; padding: 10px; font-family: monospace; margin: 10px 0;\">\n    if (obj instanceof String s) {<br>\n    &nbsp;&nbsp;System.out.println(s.length()); // ‚úì s is in scope<br>\n    } else {<br>\n    &nbsp;&nbsp;// System.out.println(s.length()); // ‚úó Compile error!<br>\n    }<br>\n    <br>\n    // Also works with negation:<br>\n    if (!(obj instanceof String s)) {<br>\n    &nbsp;&nbsp;return;<br>\n    }<br>\n    System.out.println(s.toUpperCase()); // ‚úì s is in scope here\n  </div>\n  <p><strong>Kotlin comparison:</strong> This is essentially what Kotlin's smart casts have done from day one, but Java's explicit pattern variable syntax makes it more visible in the code.</p>\n</div>\n<div class=\"concept-section\">\n  <h3>Pattern Matching in switch: The Game Changer (Java 21)</h3>\n  <p>The real revolution came in <strong>Java 21</strong> when pattern matching was finalized for <code>switch</code>. Compare old vs. new approaches:</p>\n  <div style=\"display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;\">\n    <div style=\"background: #ffebee; padding: 20px; border-radius: 10px;\">\n      <h4>‚ùå Old Java (pre-21)</h4>\n      <div style=\"background: #fff; padding: 10px; font-family: monospace; font-size: 12px;\">\n        String formatted;<br>\n        if (obj instanceof Integer) {<br>\n        &nbsp;&nbsp;formatted = String.format(<br>\n        &nbsp;&nbsp;&nbsp;&nbsp;\"int %d\", (Integer) obj);<br>\n        } else if (obj instanceof Long) {<br>\n        &nbsp;&nbsp;formatted = String.format(<br>\n        &nbsp;&nbsp;&nbsp;&nbsp;\"long %d\", (Long) obj);<br>\n        } else if (obj instanceof Double) {<br>\n        &nbsp;&nbsp;formatted = String.format(<br>\n        &nbsp;&nbsp;&nbsp;&nbsp;\"double %f\", (Double) obj);<br>\n        } else {<br>\n        &nbsp;&nbsp;formatted = obj.toString();<br>\n        }\n      </div>\n    </div>\n    <div style=\"background: #e8f5e8; padding: 20px; border-radius: 10px;\">\n      <h4>‚úÖ Modern Java (21+)</h4>\n      <div style=\"background: #fff; padding: 10px; font-family: monospace; font-size: 12px;\">\n        String formatted = switch (obj) {<br>\n        &nbsp;&nbsp;case Integer i -><br>\n        &nbsp;&nbsp;&nbsp;&nbsp;String.format(\"int %d\", i);<br>\n        &nbsp;&nbsp;case Long l -><br>\n        &nbsp;&nbsp;&nbsp;&nbsp;String.format(\"long %d\", l);<br>\n        &nbsp;&nbsp;case Double d -><br>\n        &nbsp;&nbsp;&nbsp;&nbsp;String.format(\"double %f\", d);<br>\n        &nbsp;&nbsp;default -><br>\n        &nbsp;&nbsp;&nbsp;&nbsp;obj.toString();<br>\n        };\n      </div>\n    </div>\n  </div>\n</div>\n<div class=\"concept-section\">\n  <h3>Guarded Patterns: Adding Conditions</h3>\n  <p>Java 21 also introduced <strong>guarded patterns</strong> using the <code>when</code> clause (yes, borrowed from Kotlin!):</p>\n  <div style=\"background: #f8f9fa; padding: 10px; font-family: monospace; margin: 10px 0;\">\n    String result = switch (obj) {<br>\n    &nbsp;&nbsp;case String s when s.length() > 10 -><br>\n    &nbsp;&nbsp;&nbsp;&nbsp;\"Long string: \" + s.substring(0, 10) + \"...\";<br>\n    &nbsp;&nbsp;case String s -><br>\n    &nbsp;&nbsp;&nbsp;&nbsp;\"Short string: \" + s;<br>\n    &nbsp;&nbsp;case Integer i when i > 0 -><br>\n    &nbsp;&nbsp;&nbsp;&nbsp;\"Positive: \" + i;<br>\n    &nbsp;&nbsp;case Integer i -><br>\n    &nbsp;&nbsp;&nbsp;&nbsp;\"Non-positive: \" + i;<br>\n    &nbsp;&nbsp;default -> \"Other: \" + obj;<br>\n    };\n  </div>\n  <p><strong>Kotlin comparison:</strong> This is similar to Kotlin's <code>when</code> with conditions:</p>\n  <div style=\"background: #e8f5e8; padding: 10px; font-family: monospace; margin: 10px 0;\">\n    val result = when (obj) {<br>\n    &nbsp;&nbsp;is String if obj.length > 10 -><br>\n    &nbsp;&nbsp;&nbsp;&nbsp;\"Long string: ${obj.take(10)}...\"<br>\n    &nbsp;&nbsp;is String -> \"Short string: $obj\"<br>\n    &nbsp;&nbsp;is Int if obj > 0 -> \"Positive: $obj\"<br>\n    &nbsp;&nbsp;is Int -> \"Non-positive: $obj\"<br>\n    &nbsp;&nbsp;else -> \"Other: $obj\"<br>\n    }\n  </div>\n  <p>Note: Java uses <code>when</code> for guards, Kotlin uses <code>if</code> - slightly confusing if you switch between languages!</p>\n</div>\n<div class=\"concept-section\">\n  <h3>Null Handling in Pattern Matching</h3>\n  <p>Java 21 allows explicit <code>null</code> cases in switch, making null handling part of pattern matching:</p>\n  <div style=\"background: #f8f9fa; padding: 10px; font-family: monospace; margin: 10px 0;\">\n    String result = switch (obj) {<br>\n    &nbsp;&nbsp;case null -> \"Got null!\";<br>\n    &nbsp;&nbsp;case String s -> \"String: \" + s;<br>\n    &nbsp;&nbsp;case Integer i -> \"Integer: \" + i;<br>\n    &nbsp;&nbsp;default -> \"Other: \" + obj;<br>\n    };\n  </div>\n  <p><strong>Kotlin perspective:</strong> While Kotlin's null safety system is still far more comprehensive, Java's explicit null handling in patterns is a step forward. In Kotlin, you'd typically handle this with nullable types and safe calls:</p>\n  <div style=\"background: #e8f5e8; padding: 10px; font-family: monospace; margin: 10px 0;\">\n    val result = when (obj) {<br>\n    &nbsp;&nbsp;null -> \"Got null!\"<br>\n    &nbsp;&nbsp;is String -> \"String: $obj\"<br>\n    &nbsp;&nbsp;is Int -> \"Integer: $obj\"<br>\n    &nbsp;&nbsp;else -> \"Other: $obj\"<br>\n    }\n  </div>\n</div>\n<div class=\"concept-section\">\n  <h3>Where Java Still Lags Behind Kotlin</h3>\n  <ul>\n    <li>‚ùå <strong>No pattern matching in when expressions for arbitrary conditions</strong> - Java's switch still requires a single selector expression</li>\n    <li>‚ùå <strong>No smart casts across complex conditions</strong> - Kotlin's flow typing is more sophisticated</li>\n    <li>‚ùå <strong>More verbose syntax</strong> - Java requires <code>-></code> or <code>:</code> and explicit <code>break</code> in statement form</li>\n    <li>‚ùå <strong>No exhaustiveness without default</strong> - Java requires default for non-sealed types</li>\n    <li>‚úÖ <strong>But Java gained</strong>: Explicit pattern variable names can improve readability in complex cases</li>\n  </ul>\n</div>\n<div class=\"exercise\">\n  <h3>üõ†Ô∏è Refactor Using Pattern Matching</h3>\n  <p><strong>Scenario:</strong> You're reviewing legacy Java code that processes API responses. The code uses instanceof chains and explicit casting:</p>\n  <div style=\"background: #f8f9fa; padding: 10px; font-family: monospace; margin: 10px 0;\">\n    Object response = apiCall();<br>\n    if (response instanceof SuccessResponse) {<br>\n    &nbsp;&nbsp;SuccessResponse success = (SuccessResponse) response;<br>\n    &nbsp;&nbsp;if (success.getData() instanceof User) {<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;User user = (User) success.getData();<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;return user.getName();<br>\n    &nbsp;&nbsp;}<br>\n    } else if (response instanceof ErrorResponse) {<br>\n    &nbsp;&nbsp;ErrorResponse error = (ErrorResponse) response;<br>\n    &nbsp;&nbsp;if (error.getCode() >= 500) {<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;return \"Server error: \" + error.getMessage();<br>\n    &nbsp;&nbsp;} else {<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;return \"Client error: \" + error.getMessage();<br>\n    &nbsp;&nbsp;}<br>\n    }<br>\n    return \"Unknown response\";\n  </div>\n  <p><strong>Your task:</strong></p>\n  <ul>\n    <li>Refactor this code using Java 21 pattern matching with switch</li>\n    <li>Use guarded patterns for the error code check</li>\n    <li>Then write the equivalent Kotlin version - compare verbosity and readability</li>\n  </ul>\n  <p><strong>Consider:</strong> In an interview, how would you explain the benefits of this refactoring? What would you say about maintainability and type safety?</p>\n</div>"
    },
    {
      "id": 2,
      "title": "Records and Sealed Types: Type-Safe Domain Modeling",
      "goals": [
        "Understand Java records as immutable data carriers and their limitations",
        "Master sealed classes and interfaces for restricted type hierarchies",
        "Compare records and sealed types with Kotlin's data classes and sealed classes"
      ],
      "content": "<div class=\"concept-section\">\n  <h3>Records: Java's Answer to Data Classes</h3>\n  <p>As a Kotlin developer, you're used to writing concise data classes:</p>\n  <div style=\"background: #e8f5e8; padding: 10px; font-family: monospace; margin: 10px 0;\">\n    data class User(val id: Long, val name: String, val email: String)\n  </div>\n  <p>In old Java, this required:</p>\n  <div style=\"background: #ffebee; padding: 10px; font-family: monospace; margin: 10px 0;\">\n    public class User {<br>\n    &nbsp;&nbsp;private final Long id;<br>\n    &nbsp;&nbsp;private final String name;<br>\n    &nbsp;&nbsp;private final String email;<br>\n    &nbsp;&nbsp;<br>\n    &nbsp;&nbsp;public User(Long id, String name, String email) {<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;this.id = id; this.name = name; this.email = email;<br>\n    &nbsp;&nbsp;}<br>\n    &nbsp;&nbsp;// + getters, equals, hashCode, toString...<br>\n    }\n  </div>\n  <p><strong>Java 16+</strong> introduced <strong>records</strong> that reduce this to:</p>\n  <div style=\"background: #e3f2fd; padding: 10px; font-family: monospace; margin: 10px 0;\">\n    public record User(Long id, String name, String email) { }\n  </div>\n  <p>This automatically generates: constructor, getters (without \"get\" prefix), <code>equals()</code>, <code>hashCode()</code>, and <code>toString()</code>.</p>\n</div>\n<div class=\"concept-section\">\n  <h3>Records vs. Kotlin Data Classes: Key Differences</h3>\n  <div style=\"display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;\">\n    <div style=\"background: #e3f2fd; padding: 20px; border-radius: 10px;\">\n      <h4>Java Records</h4>\n      <ul>\n        <li>‚úì Truly immutable (final by default)</li>\n        <li>‚úì Cannot extend classes (only implement interfaces)</li>\n        <li>‚úì Component names become accessor methods: <code>user.name()</code></li>\n        <li>‚úì Compact constructor syntax for validation</li>\n        <li>‚úó No copy method</li>\n        <li>‚úó Cannot be abstract or sealed</li>\n      </ul>\n    </div>\n    <div style=\"background: #e8f5e8; padding: 20px; border-radius: 10px;\">\n      <h4>Kotlin Data Classes</h4>\n      <ul>\n        <li>‚úì Can be open or abstract</li>\n        <li>‚úì Can extend classes</li>\n        <li>‚úì Properties are properties: <code>user.name</code></li>\n        <li>‚úì Built-in <code>copy()</code> method</li>\n        <li>‚úì Can mix val and var</li>\n        <li>‚úó More flexibility = more ways to break immutability</li>\n      </ul>\n    </div>\n  </div>\n</div>\n<div class=\"concept-section\">\n  <h3>Record Customization: Compact Constructors</h3>\n  <p>Records support <strong>compact constructors</strong> for validation without parameter repetition:</p>\n  <div style=\"background: #f8f9fa; padding: 10px; font-family: monospace; margin: 10px 0;\">\n    public record User(Long id, String name, String email) {<br>\n    &nbsp;&nbsp;public User {  // Compact constructor<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;if (id == null || id <= 0) {<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new IllegalArgumentException(\"Invalid id\");<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;}<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;if (name == null || name.isBlank()) {<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new IllegalArgumentException(\"Name required\");<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;}<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;// Assignments happen automatically after this block<br>\n    &nbsp;&nbsp;}<br>\n    }\n  </div>\n  <p><strong>Kotlin equivalent:</strong></p>\n  <div style=\"background: #e8f5e8; padding: 10px; font-family: monospace; margin: 10px 0;\">\n    data class User(val id: Long, val name: String, val email: String) {<br>\n    &nbsp;&nbsp;init {<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;require(id > 0) { \"Invalid id\" }<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;require(name.isNotBlank()) { \"Name required\" }<br>\n    &nbsp;&nbsp;}<br>\n    }\n  </div>\n  <p>Very similar! Java's compact constructor is essentially Kotlin's <code>init</code> block.</p>\n</div>\n<div class=\"concept-section\">\n  <h3>The Missing Copy Method Problem</h3>\n  <p>One major limitation: records don't have a <code>copy()</code> method like Kotlin data classes:</p>\n  <div style=\"background: #e8f5e8; padding: 10px; font-family: monospace; margin: 10px 0;\">\n    // Kotlin: Easy immutable updates<br>\n    val updatedUser = user.copy(name = \"New Name\")\n  </div>\n  <p>In Java, you must manually create a new instance:</p>\n  <div style=\"background: #f8f9fa; padding: 10px; font-family: monospace; margin: 10px 0;\">\n    // Java: Manual reconstruction<br>\n    var updatedUser = new User(user.id(), \"New Name\", user.email());\n  </div>\n  <p>For complex records, consider adding custom <code>withX()</code> methods:</p>\n  <div style=\"background: #f8f9fa; padding: 10px; font-family: monospace; margin: 10px 0;\">\n    public record User(Long id, String name, String email) {<br>\n    &nbsp;&nbsp;public User withName(String newName) {<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;return new User(id, newName, email);<br>\n    &nbsp;&nbsp;}<br>\n    &nbsp;&nbsp;public User withEmail(String newEmail) {<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;return new User(id, name, newEmail);<br>\n    &nbsp;&nbsp;}<br>\n    }\n  </div>\n</div>\n<div class=\"concept-section\">\n  <h3>Sealed Classes: Restricted Type Hierarchies (Java 17)</h3>\n  <p>Sealed classes let you explicitly control which classes can extend or implement a type. This was finalized in <strong>Java 17</strong>:</p>\n  <div style=\"background: #f8f9fa; padding: 10px; font-family: monospace; margin: 10px 0;\">\n    public sealed interface PaymentMethod<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;permits CreditCard, PayPal, BankTransfer {<br>\n    &nbsp;&nbsp;BigDecimal getAmount();<br>\n    }<br>\n    <br>\n    public final class CreditCard implements PaymentMethod {<br>\n    &nbsp;&nbsp;private final String cardNumber;<br>\n    &nbsp;&nbsp;private final BigDecimal amount;<br>\n    &nbsp;&nbsp;// implementation...<br>\n    }<br>\n    <br>\n    public final class PayPal implements PaymentMethod { /* ... */ }<br>\n    public final class BankTransfer implements PaymentMethod { /* ... */ }\n  </div>\n  <p><strong>Key point:</strong> All permitted subclasses must be in the same module (or same source file for simple cases).</p>\n</div>\n<div class=\"concept-section\">\n  <h3>Sealed Classes + Pattern Matching = Exhaustiveness</h3>\n  <p>The real power of sealed types comes when combined with pattern matching. The compiler knows all possible subtypes:</p>\n  <div style=\"background: #f8f9fa; padding: 10px; font-family: monospace; margin: 10px 0;\">\n    String processPayment(PaymentMethod payment) {<br>\n    &nbsp;&nbsp;return switch (payment) {<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;case CreditCard cc -><br>\n    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"Processing credit card: \" + cc.getCardNumber();<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;case PayPal pp -><br>\n    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"Processing PayPal: \" + pp.getEmail();<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;case BankTransfer bt -><br>\n    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"Processing bank transfer: \" + bt.getIban();<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;// No default needed! Compiler ensures exhaustiveness<br>\n    &nbsp;&nbsp;};<br>\n    }\n  </div>\n  <p>If you add a new payment method, <strong>all switch expressions will fail to compile</strong> until you handle the new case. This is compile-time safety!</p>\n</div>\n<div class=\"concept-section\">\n  <h3>Sealed Classes vs. Kotlin: Very Similar!</h3>\n  <p>Kotlin's sealed classes are nearly identical:</p>\n  <div style=\"background: #e8f5e8; padding: 10px; font-family: monospace; margin: 10px 0;\">\n    sealed interface PaymentMethod {<br>\n    &nbsp;&nbsp;val amount: BigDecimal<br>\n    }<br>\n    <br>\n    data class CreditCard(<br>\n    &nbsp;&nbsp;val cardNumber: String,<br>\n    &nbsp;&nbsp;override val amount: BigDecimal<br>\n    ) : PaymentMethod<br>\n    <br>\n    data class PayPal(<br>\n    &nbsp;&nbsp;val email: String,<br>\n    &nbsp;&nbsp;override val amount: BigDecimal<br>\n    ) : PaymentMethod<br>\n    <br>\n    // Exhaustive when expression<br>\n    fun processPayment(payment: PaymentMethod) = when (payment) {<br>\n    &nbsp;&nbsp;is CreditCard -> \"Processing credit card: ${payment.cardNumber}\"<br>\n    &nbsp;&nbsp;is PayPal -> \"Processing PayPal: ${payment.email}\"<br>\n    &nbsp;&nbsp;is BankTransfer -> \"Processing bank transfer: ${payment.iban}\"<br>\n    }\n  </div>\n  <p><strong>Key differences:</strong></p>\n  <ul>\n    <li>Kotlin allows sealed class hierarchies across the same package (more flexible)</li>\n    <li>Kotlin's syntax is more concise (no <code>permits</code> keyword needed)</li>\n    <li>Java requires explicit <code>final</code> on concrete implementations</li>\n    <li>Both provide exhaustiveness checking with pattern matching</li>\n  </ul>\n</div>\n<div class=\"concept-section\">\n  <h3>Records + Sealed Types: The Perfect Combination</h3>\n  <p>Combining records with sealed types creates elegant, type-safe domain models:</p>\n  <div style=\"background: #f8f9fa; padding: 10px; font-family: monospace; margin: 10px 0;\">\n    public sealed interface Result&lt;T&gt;<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;permits Success, Error {<br>\n    }<br>\n    <br>\n    public record Success&lt;T&gt;(T data) implements Result&lt;T&gt; {}<br>\n    <br>\n    public record Error&lt;T&gt;(String message, int code)<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;implements Result&lt;T&gt; {}<br>\n    <br>\n    // Usage with pattern matching<br>\n    &lt;T&gt; String handleResult(Result&lt;T&gt; result) {<br>\n    &nbsp;&nbsp;return switch (result) {<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;case Success&lt;T&gt; s -> \"Got data: \" + s.data();<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;case Error&lt;T&gt; e -> \"Error \" + e.code() + \": \" + e.message();<br>\n    &nbsp;&nbsp;};<br>\n    }\n  </div>\n  <p>This is essentially Java's version of Kotlin's <code>sealed class</code> + <code>data class</code> combination for Result types!</p>\n</div>\n<div class=\"concept-section\">\n  <h3>Interview Tips: What to Emphasize</h3>\n  <ul>\n    <li>‚úì <strong>Records eliminate boilerplate</strong> - mention how they compare to Lombok's @Data</li>\n    <li>‚úì <strong>Sealed types enable exhaustive pattern matching</strong> - this is a type safety win</li>\n    <li>‚úì <strong>Together they model algebraic data types</strong> - show you understand functional concepts</li>\n    <li>‚úì <strong>Be ready to discuss immutability trade-offs</strong> - records are always immutable</li>\n    <li>‚úì <strong>Know the limitations</strong> - no copy methods, no inheritance for records</li>\n  </ul>\n</div>\n<div class=\"exercise\">\n  <h3>üõ†Ô∏è Model an Order Processing Domain</h3>\n  <p><strong>Scenario:</strong> You need to model an order processing system with different order states and payment methods for a Java interview coding exercise.</p>\n  <p><strong>Requirements:</strong></p>\n  <ul>\n    <li>Order can be: <code>Pending</code>, <code>Confirmed</code>, <code>Shipped</code>, <code>Delivered</code>, or <code>Cancelled</code></li>\n    <li>Each state has different data (e.g., Shipped has tracking number and carrier)</li>\n    <li>Payment can be: <code>CreditCard</code>, <code>DebitCard</code>, or <code>DigitalWallet</code></li>\n    <li>Must be type-safe and enable exhaustive matching</li>\n  </ul>\n  <p><strong>Your task:</strong></p>\n  <ol>\n    <li>Design the domain model using sealed interfaces and records</li>\n    <li>Implement a method that returns status messages using pattern matching</li>\n    <li>Write the equivalent Kotlin version and compare</li>\n    <li>Prepare to explain why this design is better than using enums or inheritance</li>\n  </ol>\n  <p><strong>Consider:</strong> What would you say if the interviewer asks \"Why not just use a String field for the status?\" or \"How does this help with testing?\"</p>\n</div>"
    },
     {
      "id": 3,
      "title": "Virtual Threads: Java's Answer to Lightweight Concurrency",
      "goals": [
        "Understand virtual threads and how they differ from platform threads",
        "Learn when to use virtual threads vs traditional thread pools",
        "Compare Java's virtual threads with Kotlin's coroutines model"
      ],
      "content": "<div class=\"concept-section\">\n  <h3>The Concurrency Problem Java Finally Solved</h3>\n  <p>As a Kotlin developer, you're familiar with this elegant coroutine code:</p>\n  <div style=\"background: #e8f5e8; padding: 10px; font-family: monospace; margin: 10px 0;\">\n    suspend fun fetchUser(id: Long): User {<br>\n    &nbsp;&nbsp;return httpClient.get(\"/users/$id\")<br>\n    }<br>\n    <br>\n    // Launch 1 million concurrent requests<br>\n    runBlocking {<br>\n    &nbsp;&nbsp;(1..1_000_000).map { id -><br>\n    &nbsp;&nbsp;&nbsp;&nbsp;async { fetchUser(id) }<br>\n    &nbsp;&nbsp;}.awaitAll()<br>\n    }\n  </div>\n  <p>Traditional Java? You'd need thread pools, careful tuning, and still hit scalability limits around 5,000-10,000 threads.</p>\n  <p><strong>Java 21</strong> introduced <strong>virtual threads (Project Loom)</strong> - lightweight threads that can scale to millions, similar to how Kotlin coroutines work:</p>\n  <div style=\"background: #e3f2fd; padding: 10px; font-family: monospace; margin: 10px 0;\">\n    User fetchUser(long id) throws Exception {<br>\n    &nbsp;&nbsp;return httpClient.send(request).body();<br>\n    }<br>\n    <br>\n    // Launch 1 million concurrent requests<br>\n    try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {<br>\n    &nbsp;&nbsp;var futures = IntStream.range(1, 1_000_000)<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;.mapToObj(id -> executor.submit(() -> fetchUser(id)))<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;.toList();<br>\n    &nbsp;&nbsp;for (var future : futures) future.get();<br>\n    }\n  </div>\n  <p>Each virtual thread has its own stack and can block without tying up an OS thread!</p>\n</div>\n<div class=\"concept-section\">\n  <h3>Platform Threads vs Virtual Threads</h3>\n  <div style=\"display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;\">\n    <div style=\"background: #ffebee; padding: 20px; border-radius: 10px;\">\n      <h4>Platform Threads (Old Model)</h4>\n      <ul>\n        <li>‚úó 1:1 mapping to OS threads</li>\n        <li>‚úó ~1-2MB stack per thread</li>\n        <li>‚úó Expensive context switching</li>\n        <li>‚úó Practical limit: ~5,000 threads</li>\n        <li>‚úó Thread pools needed for scalability</li>\n        <li>‚úì Can pin native code</li>\n      </ul>\n    </div>\n    <div style=\"background: #e8f5e8; padding: 20px; border-radius: 10px;\">\n      <h4>Virtual Threads (Java 21+)</h4>\n      <ul>\n        <li>‚úì M:N mapping (many virtual : few OS threads)</li>\n        <li>‚úì Small heap allocation per thread</li>\n        <li>‚úì Cheap to create and block</li>\n        <li>‚úì Scale to millions of threads</li>\n        <li>‚úì Simple thread-per-request code</li>\n        <li>‚úó Cannot pin (yields to carrier thread)</li>\n      </ul>\n    </div>\n  </div>\n</div>\n<div class=\"concept-section\">\n  <h3>Creating Virtual Threads: Three Approaches</h3>\n  <p><strong>1. Thread.ofVirtual() - Direct creation:</strong></p>\n  <div style=\"background: #f8f9fa; padding: 10px; font-family: monospace; margin: 10px 0;\">\n    Thread vThread = Thread.ofVirtual().start(() -> {<br>\n    &nbsp;&nbsp;System.out.println(\"Running in: \" + Thread.currentThread());<br>\n    });<br>\n    vThread.join();\n  </div>\n  <p><strong>2. Executors.newVirtualThreadPerTaskExecutor() - Executor service:</strong></p>\n  <div style=\"background: #f8f9fa; padding: 10px; font-family: monospace; margin: 10px 0;\">\n    try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {<br>\n    &nbsp;&nbsp;Future&lt;String&gt; future = executor.submit(() -> {<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;return fetchDataFromAPI();<br>\n    &nbsp;&nbsp;});<br>\n    &nbsp;&nbsp;String result = future.get();<br>\n    }\n  </div>\n  <p><strong>3. Virtual thread factory - Custom configuration:</strong></p>\n  <div style=\"background: #f8f9fa; padding: 10px; font-family: monospace; margin: 10px 0;\">\n    ThreadFactory factory = Thread.ofVirtual()<br>\n    &nbsp;&nbsp;.name(\"worker-\", 0)<br>\n    &nbsp;&nbsp;.factory();<br>\n    <br>\n    try (var executor = Executors.newThreadPerTaskExecutor(factory)) {<br>\n    &nbsp;&nbsp;// Use executor...<br>\n    }\n  </div>\n</div>\n<div class=\"concept-section\">\n  <h3>Virtual Threads vs Kotlin Coroutines: Architecture Comparison</h3>\n  <div style=\"background: #fff3e0; padding: 20px; border-radius: 10px; margin: 20px 0;\">\n    <h4>üéØ Key Architectural Differences</h4>\n    <table style=\"width: 100%; border-collapse: collapse;\">\n      <tr style=\"background: #f5f5f5;\">\n        <th style=\"padding: 10px; text-align: left; border: 1px solid #ddd;\">Aspect</th>\n        <th style=\"padding: 10px; text-align: left; border: 1px solid #ddd;\">Java Virtual Threads</th>\n        <th style=\"padding: 10px; text-align: left; border: 1px solid #ddd;\">Kotlin Coroutines</th>\n      </tr>\n      <tr>\n        <td style=\"padding: 10px; border: 1px solid #ddd;\"><strong>API Model</strong></td>\n        <td style=\"padding: 10px; border: 1px solid #ddd;\">Blocking API that doesn't block OS threads</td>\n        <td style=\"padding: 10px; border: 1px solid #ddd;\">Suspend functions with explicit suspension points</td>\n      </tr>\n      <tr>\n        <td style=\"padding: 10px; border: 1px solid #ddd;\"><strong>Code Changes</strong></td>\n        <td style=\"padding: 10px; border: 1px solid #ddd;\">None - existing blocking code works</td>\n        <td style=\"padding: 10px; border: 1px solid #ddd;\">Requires suspend modifier and rewriting APIs</td>\n      </tr>\n      <tr>\n        <td style=\"padding: 10px; border: 1px solid #ddd;\"><strong>Cancellation</strong></td>\n        <td style=\"padding: 10px; border: 1px solid #ddd;\">Thread.interrupt() (traditional model)</td>\n        <td style=\"padding: 10px; border: 1px solid #ddd;\">Structured with Job.cancel() and CancellationException</td>\n      </tr>\n      <tr>\n        <td style=\"padding: 10px; border: 1px solid #ddd;\"><strong>Context</strong></td>\n        <td style=\"padding: 10px; border: 1px solid #ddd;\">ThreadLocal works naturally</td>\n        <td style=\"padding: 10px; border: 1px solid #ddd;\">CoroutineContext replaces ThreadLocal</td>\n      </tr>\n      <tr>\n        <td style=\"padding: 10px; border: 1px solid #ddd;\"><strong>Learning Curve</strong></td>\n        <td style=\"padding: 10px; border: 1px solid #ddd;\">Low - familiar thread model</td>\n        <td style=\"padding: 10px; border: 1px solid #ddd;\">Medium - new mental model required</td>\n      </tr>\n    </table>\n  </div>\n</div>\n<div class=\"concept-section\">\n  <h3>When Virtual Threads Shine</h3>\n  <ul>\n    <li>‚úÖ <strong>I/O-bound applications:</strong> Web servers, microservices, database applications</li>\n    <li>‚úÖ <strong>Legacy code migration:</strong> No need to rewrite to async APIs</li>\n    <li>‚úÖ <strong>Thread-per-request model:</strong> Simple mental model, easy debugging</li>\n    <li>‚úÖ <strong>Blocking operations:</strong> JDBC, file I/O, HTTP clients all work naturally</li>\n    <li>‚ùå <strong>CPU-bound tasks:</strong> No benefit over platform threads</li>\n    <li>‚ùå <strong>Pinning scenarios:</strong> synchronized blocks, native calls can block carrier threads</li>\n  </ul>\n</div>\n<div class=\"concept-section\">\n  <h3>The Pinning Problem</h3>\n  <p>Virtual threads can be \"pinned\" to carrier threads in certain situations, losing their lightweight benefit:</p>\n  <div style=\"background: #ffebee; padding: 10px; font-family: monospace; margin: 10px 0;\">\n    // ‚ùå BAD: synchronized blocks pin virtual threads<br>\n    synchronized (lock) {<br>\n    &nbsp;&nbsp;expensiveIOOperation(); // Blocks carrier thread!<br>\n    }\n  </div>\n  <div style=\"background: #e8f5e8; padding: 10px; font-family: monospace; margin: 10px 0;\">\n    // ‚úÖ GOOD: Use ReentrantLock instead<br>\n    lock.lock();<br>\n    try {<br>\n    &nbsp;&nbsp;expensiveIOOperation(); // Virtual thread can be unmounted<br>\n    } finally {<br>\n    &nbsp;&nbsp;lock.unlock();<br>\n    }\n  </div>\n  <p><strong>Kotlin perspective:</strong> Coroutines don't have this issue because they use non-blocking primitives by design (Mutex, Semaphore). However, calling blocking Java code from coroutines requires <code>Dispatchers.IO</code> to avoid blocking the coroutine thread pool.</p>\n</div>\n<div class=\"concept-section\">\n  <h3>Structured Concurrency (Preview Feature)</h3>\n  <p>Java is also introducing <strong>structured concurrency</strong> to manage virtual thread lifecycles better (still in preview in Java 21-23):</p>\n  <div style=\"background: #f8f9fa; padding: 10px; font-family: monospace; margin: 10px 0;\">\n    try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {<br>\n    &nbsp;&nbsp;Future&lt;User&gt; user = scope.fork(() -> fetchUser(id));<br>\n    &nbsp;&nbsp;Future&lt;Orders&gt; orders = scope.fork(() -> fetchOrders(id));<br>\n    <br>\n    &nbsp;&nbsp;scope.join();           // Wait for all<br>\n    &nbsp;&nbsp;scope.throwIfFailed();  // Propagate errors<br>\n    <br>\n    &nbsp;&nbsp;return new Profile(user.resultNow(), orders.resultNow());<br>\n    }<br>\n    // All subtasks automatically cancelled if scope exits\n  </div>\n  <p>This is conceptually similar to Kotlin's <code>coroutineScope</code>:</p>\n  <div style=\"background: #e8f5e8; padding: 10px; font-family: monospace; margin: 10px 0;\">\n    coroutineScope {<br>\n    &nbsp;&nbsp;val user = async { fetchUser(id) }<br>\n    &nbsp;&nbsp;val orders = async { fetchOrders(id) }<br>\n    &nbsp;&nbsp;Profile(user.await(), orders.await())<br>\n    }<br>\n    // All child coroutines cancelled if scope fails\n  </div>\n</div>\n<div class=\"concept-section\">\n  <h3>Real-World Example: HTTP Server Comparison</h3>\n  <p><strong>Traditional Java with thread pool:</strong></p>\n  <div style=\"background: #ffebee; padding: 10px; font-family: monospace; margin: 10px 0;\">\n    var executor = Executors.newFixedThreadPool(200);<br>\n    serverSocket.accept(socket -> {<br>\n    &nbsp;&nbsp;executor.submit(() -> {<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;handleRequest(socket); // Limited to 200 concurrent<br>\n    &nbsp;&nbsp;});<br>\n    });\n  </div>\n  <p><strong>Virtual threads - unlimited concurrency:</strong></p>\n  <div style=\"background: #e8f5e8; padding: 10px; font-family: monospace; margin: 10px 0;\">\n    serverSocket.accept(socket -> {<br>\n    &nbsp;&nbsp;Thread.ofVirtual().start(() -> {<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;handleRequest(socket); // Scales to millions<br>\n    &nbsp;&nbsp;});<br>\n    });\n  </div>\n  <p><strong>Kotlin coroutines:</strong></p>\n  <div style=\"background: #e3f2fd; padding: 10px; font-family: monospace; margin: 10px 0;\">\n    serverSocket.accept { socket -><br>\n    &nbsp;&nbsp;launch {<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;handleRequest(socket) // Also scales to millions<br>\n    &nbsp;&nbsp;}<br>\n    }\n  </div>\n</div>\n<div class=\"concept-section\">\n  <h3>Interview Tips: What Interviewers Want to Hear</h3>\n  <ul>\n    <li>‚úì <strong>Understand the problem:</strong> Explain why thread pools became necessary and their limitations</li>\n    <li>‚úì <strong>Know when NOT to use them:</strong> CPU-bound work, synchronized blocks</li>\n    <li>‚úì <strong>Compare with reactive:</strong> Virtual threads vs Project Reactor/RxJava</li>\n    <li>‚úì <strong>Migration story:</strong> How to gradually adopt in existing applications</li>\n    <li>‚úì <strong>Be honest about Kotlin:</strong> Acknowledge coroutines are more mature, but virtual threads work with existing blocking code</li>\n  </ul>\n</div>\n<div class=\"exercise\">\n  <h3>üõ†Ô∏è Refactor a Traditional Thread Pool Service</h3>\n  <p><strong>Scenario:</strong> You're interviewing and given this traditional Java service that processes batch jobs:</p>\n  <div style=\"background: #f8f9fa; padding: 10px; font-family: monospace; margin: 10px 0;\">\n    class BatchProcessor {<br>\n    &nbsp;&nbsp;private final ExecutorService executor =<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;Executors.newFixedThreadPool(50);<br>\n    <br>\n    &nbsp;&nbsp;void processBatch(List&lt;Job&gt; jobs) {<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;List&lt;Future&lt;Result&gt;&gt; futures = new ArrayList&lt;&gt;();<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;for (Job job : jobs) {<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;futures.add(executor.submit(() -> {<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return expensiveExternalAPICall(job);<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}));<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;}<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;// Wait for all and collect results...<br>\n    &nbsp;&nbsp;}<br>\n    }\n  </div>\n  <p><strong>Your task:</strong></p>\n  <ol>\n    <li>Refactor this code to use virtual threads</li>\n    <li>Add structured concurrency (even if using preview API)</li>\n    <li>Explain how this handles 10,000 concurrent jobs vs the original 50</li>\n    <li>Write equivalent Kotlin coroutine code and discuss trade-offs</li>\n    <li>Prepare to answer: \"What if each job needs to make multiple sequential API calls?\"</li>\n  </ol>\n  <p><strong>Consider:</strong> How would you explain the performance difference? What monitoring would you add? How do you handle errors differently?</p>\n</div>"
    },
    {
      "id": 4,
      "title": "Collections and Stream API Evolution",
      "goals": [
        "Master sequenced collections for consistent ordering operations",
        "Understand stream gatherers for custom intermediate operations",
        "Compare Java's collection improvements with Kotlin's rich collection API"
      ],
      "content": "<div class=\"concept-section\">\n  <h3>The Missing Collection Interface</h3>\n  <p>Before Java 21, getting the first or last element from different collection types was inconsistent:</p>\n  <div style=\"background: #ffebee; padding: 10px; font-family: monospace; margin: 10px 0;\">\n    // Different approaches for different types<br>\n    List&lt;String&gt; list = List.of(\"a\", \"b\", \"c\");<br>\n    String first = list.get(0);           // List way<br>\n    String last = list.get(list.size()-1);<br>\n    <br>\n    Deque&lt;String&gt; deque = new ArrayDeque&lt;&gt;(list);<br>\n    first = deque.getFirst();             // Deque way<br>\n    last = deque.getLast();<br>\n    <br>\n    SortedSet&lt;String&gt; set = new TreeSet&lt;&gt;(list);<br>\n    first = set.first();                  // SortedSet way<br>\n    last = set.last();\n  </div>\n  <p><strong>Kotlin developers know better:</strong></p>\n  <div style=\"background: #e8f5e8; padding: 10px; font-family: monospace; margin: 10px 0;\">\n    val collection = listOf(\"a\", \"b\", \"c\")<br>\n    val first = collection.first()  // Works on any collection<br>\n    val last = collection.last()    // Consistent API\n  </div>\n  <p><strong>Java 21</strong> introduced <strong>SequencedCollection</strong> to solve this inconsistency!</p>\n</div>\n<div class=\"concept-section\">\n  <h3>The Sequenced Collections Hierarchy</h3>\n  <p>Java 21 added three new interfaces to the collections framework:</p>\n  <ul>\n    <li><strong>SequencedCollection</strong> - Base interface for collections with a defined encounter order</li>\n    <li><strong>SequencedSet</strong> - Sequenced collections that are also sets</li>\n    <li><strong>SequencedMap</strong> - Maps with ordered entries</li>\n  </ul>\n  <div style=\"background: #f8f9fa; padding: 10px; font-family: monospace; margin: 10px 0;\">\n    interface SequencedCollection&lt;E&gt; extends Collection&lt;E&gt; {<br>\n    &nbsp;&nbsp;SequencedCollection&lt;E&gt; reversed();<br>\n    &nbsp;&nbsp;void addFirst(E e);<br>\n    &nbsp;&nbsp;void addLast(E e);<br>\n    &nbsp;&nbsp;E getFirst();<br>\n    &nbsp;&nbsp;E getLast();<br>\n    &nbsp;&nbsp;E removeFirst();<br>\n    &nbsp;&nbsp;E removeLast();<br>\n    }\n  </div>\n  <p>Now <strong>List</strong>, <strong>Deque</strong>, and <strong>LinkedHashSet</strong> all implement SequencedCollection!</p>\n</div>\n<div class=\"concept-section\">\n  <h3>Sequenced Collections in Action</h3>\n  <div style=\"background: #f8f9fa; padding: 10px; font-family: monospace; margin: 10px 0;\">\n    List&lt;String&gt; list = new ArrayList&lt;&gt;(List.of(\"a\", \"b\", \"c\"));<br>\n    <br>\n    // Consistent API across collection types<br>\n    list.addFirst(\"start\");  // [start, a, b, c]<br>\n    list.addLast(\"end\");     // [start, a, b, c, end]<br>\n    <br>\n    String first = list.getFirst();   // \"start\"<br>\n    String last = list.getLast();     // \"end\"<br>\n    <br>\n    // Reversed view - no copying!<br>\n    List&lt;String&gt; rev = list.reversed();<br>\n    System.out.println(rev); // [end, c, b, a, start]<br>\n    <br>\n    // Modifications affect both views<br>\n    rev.addFirst(\"new\");     // [new, end, c, b, a, start]<br>\n    System.out.println(list); // [start, a, b, c, end, new]\n  </div>\n</div>\n<div class=\"concept-section\">\n  <h3>Sequenced Maps: Ordered Key-Value Pairs</h3>\n  <p>Maps also got the sequenced treatment:</p>\n  <div style=\"background: #f8f9fa; padding: 10px; font-family: monospace; margin: 10px 0;\">\n    LinkedHashMap&lt;String, Integer&gt; map = new LinkedHashMap&lt;&gt;();<br>\n    map.put(\"first\", 1);<br>\n    map.put(\"second\", 2);<br>\n    map.put(\"third\", 3);<br>\n    <br>\n    // New methods for sequenced maps<br>\n    Map.Entry&lt;String, Integer&gt; first = map.firstEntry();  // first=1<br>\n    Map.Entry&lt;String, Integer&gt; last = map.lastEntry();    // third=3<br>\n    <br>\n    map.putFirst(\"zero\", 0);   // Insert at beginning<br>\n    map.putLast(\"four\", 4);    // Insert at end<br>\n    <br>\n    // Reversed view of the map<br>\n    SequencedMap&lt;String, Integer&gt; reversed = map.reversed();<br>\n    System.out.println(reversed.firstEntry()); // four=4\n  </div>\n  <p><strong>Kotlin comparison:</strong> Kotlin doesn't have explicit sequenced interfaces, but extension functions provide similar convenience:</p>\n  <div style=\"background: #e8f5e8; padding: 10px; font-family: monospace; margin: 10px 0;\">\n    val map = linkedMapOf(\"first\" to 1, \"second\" to 2)<br>\n    val first = map.entries.first()  // Extension function<br>\n    val last = map.entries.last()<br>\n    val reversed = map.entries.reversed()  // Creates new list\n  </div>\n</div>\n<div class=\"concept-section\">\n  <h3>Where Java Sequenced Collections Differ from Kotlin</h3>\n  <div style=\"display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;\">\n    <div style=\"background: #e3f2fd; padding: 20px; border-radius: 10px;\">\n      <h4>Java's Approach</h4>\n      <ul>\n        <li>‚úì Type-safe at compile time</li>\n        <li>‚úì Reversed views don't copy data</li>\n        <li>‚úì Built into the type hierarchy</li>\n        <li>‚úó Only for inherently ordered collections</li>\n        <li>‚úó More ceremony (interfaces, implementations)</li>\n      </ul>\n    </div>\n    <div style=\"background: #e8f5e8; padding: 20px; border-radius: 10px;\">\n      <h4>Kotlin's Approach</h4>\n      <ul>\n        <li>‚úì Works on any collection via extensions</li>\n        <li>‚úì More operations (firstOrNull, lastOrNull, etc.)</li>\n        <li>‚úì Consistent across all types</li>\n        <li>‚úó May throw if collection is empty</li>\n        <li>‚úó reversed() creates copies, not views</li>\n      </ul>\n    </div>\n  </div>\n</div>\n<div class=\"concept-section\">\n  <h3>Stream Gatherers: Custom Intermediate Operations (Preview Java 22-23)</h3>\n  <p>Stream API has been powerful but limited to predefined operations. <strong>Stream gatherers</strong> (preview in Java 22-23) let you create custom intermediate operations:</p>\n  <div style=\"background: #fff3e0; padding: 20px; border-radius: 10px; margin: 20px 0;\">\n    <h4>üî¨ Preview Feature</h4>\n    <p>Stream gatherers are still in preview. To use them, compile with <code>--enable-preview</code>.</p>\n  </div>\n  <p><strong>Example: Sliding window gatherer</strong></p>\n  <div style=\"background: #f8f9fa; padding: 10px; font-family: monospace; margin: 10px 0;\">\n    // Create windows of size 3<br>\n    List&lt;List&lt;Integer&gt;&gt; windows = Stream.of(1, 2, 3, 4, 5)<br>\n    &nbsp;&nbsp;.gather(Gatherers.windowSliding(3))<br>\n    &nbsp;&nbsp;.toList();<br>\n    <br>\n    // Result: [[1,2,3], [2,3,4], [3,4,5]]\n  </div>\n  <p><strong>Built-in gatherers include:</strong></p>\n  <ul>\n    <li><code>windowFixed(size)</code> - Fixed-size non-overlapping windows</li>\n    <li><code>windowSliding(size)</code> - Sliding windows with overlap</li>\n    <li><code>fold(init, combiner)</code> - Stateful reduction</li>\n    <li><code>scan(init, combiner)</code> - Like fold but emits intermediate results</li>\n  </ul>\n</div>\n<div class=\"concept-section\">\n  <h3>Gatherers vs Kotlin Collection Operations</h3>\n  <p>Kotlin has had powerful collection operations from the start:</p>\n  <div style=\"background: #e8f5e8; padding: 10px; font-family: monospace; margin: 10px 0;\">\n    val numbers = listOf(1, 2, 3, 4, 5)<br>\n    <br>\n    // Windowing in Kotlin<br>\n    val windows = numbers.windowed(size = 3)<br>\n    // Result: [[1,2,3], [2,3,4], [3,4,5]]<br>\n    <br>\n    // Chunking (fixed windows)<br>\n    val chunks = numbers.chunked(2)<br>\n    // Result: [[1,2], [3,4], [5]]<br>\n    <br>\n    // Running fold (scan equivalent)<br>\n    val running = numbers.runningFold(0) { acc, i -> acc + i }<br>\n    // Result: [0, 1, 3, 6, 10, 15]\n  </div>\n  <p>Java gatherers are catching up to what Kotlin's collection API has always provided!</p>\n</div>\n<div class=\"concept-section\">\n  <h3>Custom Gatherer Example</h3>\n  <p>You can create custom gatherers for specialized operations:</p>\n  <div style=\"background: #f8f9fa; padding: 10px; font-family: monospace; margin: 10px 0;\">\n    // Custom gatherer to emit duplicates<br>\n    Gatherer&lt;Integer, ?, Integer&gt; duplicateElements =<br>\n    &nbsp;&nbsp;Gatherer.of(<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;() -> new Object(), // No state needed<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;(state, element, downstream) -> {<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;downstream.push(element);<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;downstream.push(element); // Duplicate!<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;}<br>\n    &nbsp;&nbsp;);<br>\n    <br>\n    List&lt;Integer&gt; doubled = Stream.of(1, 2, 3)<br>\n    &nbsp;&nbsp;.gather(duplicateElements)<br>\n    &nbsp;&nbsp;.toList();<br>\n    // Result: [1, 1, 2, 2, 3, 3]\n  </div>\n  <p><strong>Kotlin equivalent:</strong></p>\n  <div style=\"background: #e8f5e8; padding: 10px; font-family: monospace; margin: 10px 0;\">\n    val doubled = listOf(1, 2, 3)<br>\n    &nbsp;&nbsp;.flatMap { listOf(it, it) }<br>\n    // Result: [1, 1, 2, 2, 3, 3]<br>\n    <br>\n    // Or as extension function<br>\n    fun &lt;T&gt; Sequence&lt;T&gt;.duplicate() = flatMap { sequenceOf(it, it) }\n  </div>\n</div>\n<div class=\"concept-section\">\n  <h3>Stream API Improvements: Other Notable Additions</h3>\n  <ul>\n    <li><strong>toList() (Java 16):</strong> Direct conversion without collectors<br>\n      <code>stream.toList()</code> instead of <code>stream.collect(Collectors.toList())</code>\n    </li>\n    <li><strong>mapMulti() (Java 16):</strong> One-to-many mapping with imperative style<br>\n      More efficient than <code>flatMap</code> for small expansions\n    </li>\n    <li><strong>takeWhile() and dropWhile() (Java 9):</strong> Conditional stream truncation<br>\n      Similar to Kotlin's <code>takeWhile</code> and <code>dropWhile</code>\n    </li>\n  </ul>\n  <div style=\"background: #f8f9fa; padding: 10px; font-family: monospace; margin: 10px 0;\">\n    // mapMulti example<br>\n    List&lt;Integer&gt; expanded = Stream.of(1, 2, 3)<br>\n    &nbsp;&nbsp;.&lt;Integer&gt;mapMulti((num, consumer) -> {<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;consumer.accept(num);<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;consumer.accept(num * 10);<br>\n    &nbsp;&nbsp;})<br>\n    &nbsp;&nbsp;.toList();<br>\n    // Result: [1, 10, 2, 20, 3, 30]\n  </div>\n</div>\n<div class=\"concept-section\">\n  <h3>Interview Focus: What Matters Most</h3>\n  <ul>\n    <li>‚úì <strong>SequencedCollection</strong> - Know why it was added and the consistency problem it solves</li>\n    <li>‚úì <strong>Reversed views</strong> - Understand they're views, not copies (performance implication)</li>\n    <li>‚úì <strong>Stream gatherers</strong> - Know they exist and their purpose (custom intermediate ops)</li>\n    <li>‚úì <strong>Kotlin comparison</strong> - Be ready to discuss how Kotlin's collection API is more mature</li>\n    <li>‚úì <strong>Practical usage</strong> - When to use List.getFirst() vs. List.get(0)? (clarity vs compatibility)</li>\n  </ul>\n</div>\n<div class=\"exercise\">\n  <h3>üõ†Ô∏è Modernize Collection Processing Code</h3>\n  <p><strong>Scenario:</strong> You're in an interview refactoring legacy collection code. You have a service that processes transaction records:</p>\n  <div style=\"background: #f8f9fa; padding: 10px; font-family: monospace; margin: 10px 0;\">\n    class TransactionProcessor {<br>\n    &nbsp;&nbsp;List&lt;Transaction&gt; transactions;<br>\n    <br>\n    &nbsp;&nbsp;Transaction getLatest() {<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;return transactions.get(transactions.size() - 1);<br>\n    &nbsp;&nbsp;}<br>\n    <br>\n    &nbsp;&nbsp;Transaction getOldest() {<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;return transactions.get(0);<br>\n    &nbsp;&nbsp;}<br>\n    <br>\n    &nbsp;&nbsp;List&lt;Transaction&gt; getRecentN(int n) {<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;int start = Math.max(0, transactions.size() - n);<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;return new ArrayList&lt;&gt;(<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;transactions.subList(start, transactions.size()));<br>\n    &nbsp;&nbsp;}<br>\n    <br>\n    &nbsp;&nbsp;List&lt;Transaction&gt; reverseOrder() {<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;List&lt;Transaction&gt; reversed = new ArrayList&lt;&gt;(transactions);<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;Collections.reverse(reversed);<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;return reversed;<br>\n    &nbsp;&nbsp;}<br>\n    }\n  </div>\n  <p><strong>Your task:</strong></p>\n  <ol>\n    <li>Refactor using SequencedCollection methods</li>\n    <li>Add a method that groups transactions into 5-transaction windows using stream gatherers</li>\n    <li>Implement equivalent functionality in Kotlin and compare</li>\n    <li>Explain when reversed views are better than creating new lists</li>\n  </ol>\n  <p><strong>Bonus challenge:</strong> The interviewer asks: \"How would you handle an empty transaction list?\" Show both the Java and Kotlin approaches to safety.</p>\n  <p><strong>Consider:</strong> What are the performance implications of using reversed() vs creating a new reversed list? When does each make sense?</p>\n</div>"
    }
  ]
}