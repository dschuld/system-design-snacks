{
  "id": "idempotency-in-distributed-systems",
     "title": "Idempotency in Distributed Systems",
    "totalLessons": 6,
    "available": true,
    "lessons": [
      {
        "id": 1,
        "title": "Why Do We Need Idempotency?",
        "goals": [
          "Define idempotency and explain why retries are inevitable in distributed systems",
          "Identify concrete duplicate-side-effect risks in payments and social posting",
          "Differentiate between read vs write idempotency and the role of side effects"
        ],
        "content": "<div class=\"concept-section\">\n  <h3>What is Idempotency and Why It Matters</h3>\n  <p>Idempotency means that executing the same operation once or multiple times produces the same externally observable result. In distributed systems, <em>retries are guaranteed to happen</em> due to network timeouts, transient errors, client crashes, and load balancer behavior. Without idempotency, accidental replays can cause duplicate side effects like double-charging a card or posting the same message twice.</p>\n  <ul>\n    <li>‚úÖ Idempotent: GET on a resource; PUT with the same body; DELETE (usually) when it removes a resource deterministically.</li>\n    <li>‚ùå Non-idempotent: naive POST that <em>creates</em> a new resource each time it is called.</li>\n  </ul>\n</div>\n<div class=\"concept-section\">\n  <h3>Where Duplicates Come From</h3>\n  <ul>\n    <li>Client retries after a timeout even though the server succeeded.</li>\n    <li>Mobile networks causing delayed or duplicated sends.</li>\n    <li>Load balancers and gateway retries on 5xx/timeout.</li>\n    <li>At-least-once delivery from queues or webhooks.</li>\n  </ul>\n  <p><strong>Key distinction:</strong> <em>Read idempotency</em> is usually free (re-reading doesn't change state), but <em>write idempotency</em> requires design to ensure side effects (charges, emails, inventory decrements) are not repeated.</p>\n</div>\n<div class=\"concept-section\">\n  <h3>Consequences of Missing Idempotency</h3>\n  <ul>\n    <li>Incorrect balances or double-charges</li>\n    <li>Out-of-sync aggregates and analytics</li>\n    <li>Customer support burden and dispute handling</li>\n    <li>Complex, hard-to-reproduce bugs under load</li>\n  </ul>\n</div>\n<div class=\"exercise\">\n  <h3>üõ†Ô∏è Spot the Risk</h3>\n  <p><strong>Scenario:</strong> A customer taps ‚ÄúPay‚Äù and loses connectivity. When the app reconnects, it retries. Meanwhile, the original request actually succeeded on the server.</p>\n  <p><strong>Your task:</strong> List the <em>three</em> most harmful side effects that could occur without idempotency. Then, describe how each would appear to the customer and to your monitoring dashboards.</p>\n  <p><em>Hint:</em> Think charges, inventory, and notifications.</p>\n</div>"
      },
      {
        "id": 2,
        "title": "Client vs Server Responsibility",
        "goals": [
          "Explain why the server is the primary enforcer of idempotency",
          "Describe how clients assist via stable request identity (Idempotency-Key or resource ID)",
          "Design scope and validation rules for idempotency keys"
        ],
        "content": "<div class=\"concept-section\">\n  <h3>Shared Responsibility Model</h3>\n  <p>The <strong>server</strong> must guarantee that duplicate requests do not apply duplicate side effects. The <strong>client</strong> helps by providing a stable identity across retries‚Äîcommonly an <code>Idempotency-Key</code> header or a deterministic resource ID in the URL.</p>\n  <ul>\n    <li>‚úÖ Server: deduplicate, persist results, handle partial failures.</li>\n    <li>‚úÖ Client: generate cryptographically strong, unique keys; reuse the same key for the same intent.</li>\n    <li>‚ùå Anti-pattern: relying on client-side UI to block double clicks without server validation.</li>\n  </ul>\n</div>\n<div class=\"concept-section\">\n  <h3>Scoping and Validation</h3>\n  <p>Define what a key uniquely identifies (per user, per merchant, per tenant). Validate that a reused key corresponds to the <em>same normalized request</em> to avoid collisions and misuse.</p>\n  <ul>\n    <li>Keys should be high-entropy (e.g., UUIDv4) and time-bounded.</li>\n    <li>Store a <code>request_hash</code> to ensure key reuse matches the same payload.</li>\n    <li>Return <code>409 Conflict</code> if the same key is used with a different request.</li>\n  </ul>\n</div>\n<div class=\"concept-section\">\n  <h3>POST + Key vs PUT + Resource ID</h3>\n  <div style=\"display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;\">\n    <div style=\"background: #e8f5e8; padding: 20px; border-radius: 10px;\">\n      <h4>POST /payments + Idempotency-Key</h4>\n      <ul><li>‚úÖ Simple create semantics</li><li>‚úÖ Works well when resource ID is server-generated</li><li>‚ùå Requires key storage and replay logic</li></ul>\n    </div>\n    <div style=\"background: #e3f2fd; padding: 20px; border-radius: 10px;\">\n      <h4>PUT /payments/{id}</h4>\n      <ul><li>‚úÖ Natural upsert semantics</li><li>‚úÖ No separate key store if request fully deterministic</li><li>‚ùå Client must pick stable IDs and manage collisions</li></ul>\n    </div>\n  </div>\n</div>\n<div class=\"exercise\">\n  <h3>üõ†Ô∏è Scope the Key</h3>\n  <p><strong>Scenario:</strong> A marketplace with many merchants processes customer payments. You choose POST + Idempotency-Key.</p>\n  <p><strong>Your task:</strong> Propose a scoping rule for keys (e.g., per-merchant, per-customer). Explain how this avoids cross-tenant collisions and facilitates support/debugging.</p>\n</div>"
      },
      {
        "id": 3,
        "title": "Designing the Idempotency Store & Concurrency Control",
        "goals": [
          "Design a durable idempotency record schema and request normalization",
          "Explain the difference between short-term locks and long-term expiry",
          "Prevent in-flight duplicate execution across workers"
        ],
        "content": "<div class=\"concept-section\">\n  <h3>Data Model</h3>\n  <p>Create a dedicated <code>idempotency_records</code> store that maps a key to the normalized request and the final response.</p>\n  <ul>\n    <li><code>key</code> (PK), <code>request_hash</code>, <code>status</code>, <code>response_code</code>, <code>response_body</code>, <code>resource_id</code>, <code>locked_until</code>, <code>expires_at</code>, timestamps</li>\n    <li>Normalize request: sort maps, strip irrelevant headers, canonicalize numbers/strings.</li>\n  </ul>\n</div>\n<div class=\"concept-section\">\n  <h3>Execution Flow</h3>\n  <div style=\"background:#f8f9fa; padding:10px; font-family: monospace; margin:10px 0;\">\n    begin;<br>\n    -- 1) Insert or select for update idempotency record<br>\n    -- 2) If new: set status=in_progress, locked_until=now()+30s<br>\n    -- 3) If existing: check request_hash; if mismatch ‚Üí 409; if succeeded/failed_final ‚Üí replay<br>\n    -- 4) Perform side effect (create payment) atomically with commit<br>\n    -- 5) Persist response + status=succeeded; set expires_at<br>\n    commit;\n  </div>\n  <p>Use a short-lived <strong>lock</strong> (<code>locked_until</code> or DB row lock) to ensure only one worker performs the action at a time.</p>\n</div>\n<div class=\"concept-section\">\n  <h3>Locks vs Expiry</h3>\n  <ul>\n    <li><strong>locked_until:</strong> seconds-level, guards concurrent processing.</li>\n    <li><strong>expires_at:</strong> hours‚Äìdays, defines replay window and bounds storage growth.</li>\n  </ul>\n</div>\n<div class=\"concept-section\">\n  <h3>Error Paths & Partial Failures</h3>\n  <ul>\n    <li>Response lost after success ‚Üí client retries ‚Üí server replays stored 201/200 and body.</li>\n    <li>Timeout while PSP charged card ‚Üí use same key with PSP and reconcile via webhooks/outbox.</li>\n    <li>Crash mid-flight ‚Üí on restart, <em>status=in_progress &amp;&amp; locked_until expired</em> ‚Üí safely resume or retry.</li>\n  </ul>\n</div>\n<div class=\"exercise\">\n  <h3>üõ†Ô∏è Race-Proof It</h3>\n  <p><strong>Scenario:</strong> Two identical requests with the same key arrive milliseconds apart to different app nodes.</p>\n  <p><strong>Your task:</strong> Describe the exact sequence of DB operations (including locks or <code>SELECT ... FOR UPDATE</code>) that ensures only one payment is created.</p>\n</div>"
      },
      {
        "id": 4,
        "title": "End-to-End Idempotency Across Services",
        "goals": [
          "Apply idempotency to downstream calls and messaging (outbox/inbox)",
          "Contrast exactly-once processing myth vs at-least-once + idempotent consumers",
          "Choose a TTL policy aligned with client/gateway retry horizons"
        ],
        "content": "<div class=\"concept-section\">\n  <h3>Downstream Consistency</h3>\n  <p>Idempotency must extend to downstream services: payment gateways, email services, inventory, and message brokers. Propagate the same key or derive a stable <em>operation ID</em> to each hop.</p>\n  <ul>\n    <li><strong>Outbox pattern:</strong> write events in the same DB transaction as state changes; publish after commit.</li>\n    <li><strong>Inbox table / processed_messages:</strong> consumers record message IDs to avoid reapplying side effects.</li>\n  </ul>\n</div>\n<div class=\"concept-section\">\n  <h3>Exactly-Once vs Idempotent At-Least-Once</h3>\n  <p><em>Exactly-once</em> delivery is impractical in distributed systems. Design for <strong>at-least-once</strong> delivery with idempotent handlers and deduplication by message ID.</p>\n</div>\n<div class=\"concept-section\">\n  <h3>Choosing TTL</h3>\n  <ul>\n    <li>Base TTL on max(client retry horizon, gateway/webhook horizon, incident recovery).</li>\n    <li>48‚Äì72h common for internet-facing payment flows; 24‚Äì36h for internal calls.</li>\n    <li>Compact records after TTL (keep key ‚Üí resource_id, drop response body).</li>\n  </ul>\n</div>\n<div class=\"exercise\">\n  <h3>üõ†Ô∏è Propagate the Key</h3>\n  <p><strong>Scenario:</strong> Your service charges a card, sends a receipt email, and decrements inventory, with events on a queue.</p>\n  <p><strong>Your task:</strong> Describe how you would propagate and use a single idempotency key (or operation ID) across the gateway call, event production (outbox), and each consumer (inbox/processed table) to guarantee no duplicate side effects.</p>\n</div>"
      },
      {
        "id": 5,
        "title": "Instrumentation, Testing, and Operational Playbooks",
        "goals": [
          "Instrument idempotency with metrics and logs for observability and SLOs",
          "Design test strategies for retries, races, and partial failures",
          "Prepare operational runbooks for incident handling and reconciliation"
        ],
        "content": "<div class=\"concept-section\">\n  <h3>Observability &amp; Metrics</h3>\n  <ul>\n    <li><strong>Metrics:</strong> replay rate, key collisions (hash mismatch), in-progress timeouts, lock contention, TTL expirations.</li>\n    <li><strong>Logs/Traces:</strong> include the idempotency key in structured logs and tracing spans.</li>\n    <li><strong>Dashboards:</strong> correlate retries with latency spikes and 5xx rates.</li>\n  </ul>\n</div>\n<div class=\"concept-section\">\n  <h3>Testing Strategy</h3>\n  <div style=\"background:#f8f9fa; padding:10px; font-family: monospace; margin:10px 0;\">\n    Test A: same key, identical payload ‚Üí first 201, subsequent 200 with identical body<br>\n    Test B: same key, different payload ‚Üí 409 Conflict<br>\n    Test C: concurrent requests with same key ‚Üí exactly one side effect<br>\n    Test D: success but response lost ‚Üí retry returns stored success<br>\n    Test E: PSP charged but local crash ‚Üí reconcile via webhook/outbox, then replay\n  </div>\n</div>\n<div class=\"concept-section\">\n  <h3>Operational Playbooks</h3>\n  <ul>\n    <li>Reprocessing: safe to retry with the same key inside TTL; after TTL, require a new key.</li>\n    <li>Data hygiene: scheduled compaction job to prune or downsample old records.</li>\n    <li>Security: scope keys per tenant; detect high-rate key reuse patterns as abuse.</li>\n  </ul>\n</div>\n<div class=\"concept-section\">\n  <h3>Implementation Example (Pseudocode)</h3>\n  <div style=\"background:#f8f9fa; padding:10px; font-family: monospace; margin:10px 0;\">\n    function handleCreatePayment(request) {<br>\n    &nbsp;&nbsp;const key = request.headers['Idempotency-Key'];<br>\n    &nbsp;&nbsp;const hash = normalizeAndHash(request.body);<br>\n    &nbsp;&nbsp;tx(() =&gt; {<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;let r = getRecordForUpdate(key);<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;if (!r) insertInProgress(key, hash, lock(30));<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;else if (r.status=='succeeded' || r.status=='failed_final') return replay(r);<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;else if (r.request_hash != hash) throw Conflict409;<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;const payment = createPayment(request.body);<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;const response = { code:201, body:serialize(payment) };<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;updateRecord(key, 'succeeded', response, payment.id, ttlHours(48));<br>\n    &nbsp;&nbsp;});<br>\n    &nbsp;&nbsp;publishOutboxEvents();<br>\n    &nbsp;&nbsp;return response;<br>\n    }\n  </div>\n</div>\n<div class=\"concept-section\">\n  <h3>üéâ Idempotency Journey Complete!</h3>\n  <p>You've now mastered:</p>\n  <ul>\n    <li>‚úÖ Why retries force idempotency</li>\n    <li>‚úÖ Client vs server responsibilities</li>\n    <li>‚úÖ Designing the idempotency store and concurrency control</li>\n    <li>‚úÖ End-to-end propagation with outbox/inbox</li>\n    <li>‚úÖ Instrumentation, testing, and operations</li>\n  </ul>\n  <p><strong>Next steps:</strong> Apply the same patterns to webhooks, message consumers, and multi-region deployments.</p>\n</div>"
      },
      {
        "id": 6,
        "title": "Case Studies in Idempotency",
        "goals": [
          "Learn how real-world companies implement idempotency in APIs and messaging",
          "Compare design choices across domains like payments, social media, and queues",
          "Apply idempotency concepts to a hypothetical complex scenario"
        ],
        "content": "<div class=\"concept-section\">\n  <h3>Real-World Case Studies</h3>\n  <ul>\n    <li><strong>Stripe (Payments):</strong> POSTs accept an <code>Idempotency-Key</code>. The system stores the key, normalizes the request, and replays the same response. Keys typically expire after 24 hours. \n      <a href=\"https://docs.stripe.com/api/idempotent_requests\" target=\"_blank\" rel=\"noopener noreferrer\">Stripe docs</a> ¬∑ \n      <a href=\"https://docs.stripe.com/error-low-level\" target=\"_blank\" rel=\"noopener noreferrer\">TTL reference</a></li>\n    <li><strong>Adyen (Payments):</strong> Send an <code>Idempotency-Key</code> header; the platform deduplicates and returns the first response for retries. Keys are valid for at least 7 days (per Adyen docs). \n      <a href=\"https://docs.adyen.com/development-resources/api-idempotency/\" target=\"_blank\" rel=\"noopener noreferrer\">Adyen docs</a></li>\n    <li><strong>AWS SQS FIFO (Messaging):</strong> Provide a <code>MessageDeduplicationId</code>; duplicates within the 5-minute dedup window are not delivered again. \n      <a href=\"https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/using-messagededuplicationid-property.html\" target=\"_blank\" rel=\"noopener noreferrer\">SQS dedup ID</a></li>\n  </ul>\n</div>\n<div class=\"concept-section\">\n  <h3>Design Lessons from These Case Studies</h3>\n  <ul>\n    <li>Payment APIs emphasize <strong>longer TTLs</strong> and replaying responses exactly, since financial correctness is critical.</li>\n    <li>Messaging systems like SQS use <strong>bounded deduplication windows</strong> rather than indefinite replay.</li>\n  </ul>\n</div>\n<div class=\"concept-section\">\n  <h3>Hypothetical Case Study: Ride-Hailing App</h3>\n  <p>Design a ride-hailing backend. Mobile clients retry due to flaky networks. Side effects include trip creation, payment, driver notifications, cancellations.</p>\n  <ul>\n    <li>Trip creation: avoid duplicate trips</li>\n    <li>Payment: avoid double charges</li>\n    <li>Notifications: avoid duplicate requests to drivers</li>\n    <li>Cancellations: exactly one cancellation should persist</li>\n  </ul>\n</div>\n<div class=\"exercise\">\n  <h3>üõ†Ô∏è Design the Ride-Hailing Flow</h3>\n  <p><strong>Scenario:</strong> Passenger requests a ride but the client retries several times; cancellations can also be retried or delayed.</p>\n  <p><strong>Your task:</strong> Propose how you'd use idempotency keys (or resource IDs) across trip creation, payments, and cancellations. Explain where idempotency is enforced, and how to handle late retries.</p>\n  <p><em>Optional challenge:</em> Consider propagating the idempotency key through notifications to drivers.</p>\n</div>\n<div class=\"concept-section\">\n  <h3>üéâ Case Studies Lesson Complete!</h3>\n  <p>You've now seen:</p>\n  <ul>\n    <li>‚úÖ Stripe's replayable POST model</li>\n    <li>‚úÖ Adyen's API-level idempotency</li>\n    <li>‚úÖ AWS SQS's bounded deduplication window</li>\n    <li>‚úÖ A composite ride-hailing flow tying these ideas together</li>\n  </ul>\n  <p><strong>Next steps:</strong> Explore engineering blogs for more patterns, or model idempotency in your past systems.</p>\n</div>"
      }
    ]
  }