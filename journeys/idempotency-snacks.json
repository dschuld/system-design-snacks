{
  "id": "idempotency-in-distributed-systems-long",
    "title": "Idempotency in Distributed Systems",
    "description": "5 lessons, ~12‚Äì15 min each",
    "totalLessons": 5,
    "available": true,
    "lessons": [
      {
        "id": 1,
        "title": "Why Do We Need Idempotency?",
        "goals": [
          "Define idempotency and explain why retries are inevitable in distributed systems",
          "Identify concrete duplicate-side-effect risks in payments and social posting",
          "Differentiate between read vs write idempotency and the role of side effects"
        ],
        "content": "<div class=\"concept-section\"><h3>What is Idempotency and Why It Matters</h3><p>Idempotency means that executing the same operation once or multiple times produces the same externally observable result. In distributed systems, <em>retries are guaranteed to happen</em> due to network timeouts, transient errors, client crashes, and load balancer behavior. Without idempotency, accidental replays can cause duplicate side effects like double-charging a card or posting the same message twice.</p><ul><li>‚úÖ Idempotent: GET on a resource; PUT with the same body; DELETE (usually) when it removes a resource deterministically.</li><li>‚ùå Non-idempotent: naive POST that <em>creates</em> a new resource each time it is called.</li></ul></div><div class=\"concept-section\"><h3>Where Duplicates Come From</h3><ul><li>Client retries after a timeout even though the server succeeded.</li><li>Mobile networks causing delayed or duplicated sends.</li><li>Load balancers and gateway retries on 5xx/timeout.</li><li>At-least-once delivery from queues or webhooks.</li></ul><p><strong>Key distinction:</strong> <em>Read idempotency</em> is usually free (re-reading doesn't change state), but <em>write idempotency</em> requires design to ensure side effects (charges, emails, inventory decrements) are not repeated.</p></div><div class=\"concept-section\"><h3>Consequences of Missing Idempotency</h3><ul><li>Incorrect balances or double-charges</li><li>Out-of-sync aggregates and analytics</li><li>Customer support burden and dispute handling</li><li>Complex, hard-to-reproduce bugs under load</li></ul></div><div class=\"exercise\"><h3>üõ†Ô∏è Spot the Risk</h3><p><strong>Scenario:</strong> A customer taps ‚ÄúPay‚Äù and loses connectivity. When the app reconnects, it retries. Meanwhile, the original request actually succeeded on the server.</p><p><strong>Your task:</strong> List the <em>three</em> most harmful side effects that could occur without idempotency. Then, describe how each would appear to the customer and to your monitoring dashboards.</p><p><em>Hint:</em> Think charges, inventory, and notifications.</p></div>"
      },
      {
        "id": 2,
        "title": "Client vs Server Responsibility",
        "goals": [
          "Explain why the server is the primary enforcer of idempotency",
          "Describe how clients assist via stable request identity (Idempotency-Key or resource ID)",
          "Design scope and validation rules for idempotency keys"
        ],
        "content": "<div class=\"concept-section\"><h3>Shared Responsibility Model</h3><p>The <strong>server</strong> must guarantee that duplicate requests do not apply duplicate side effects. The <strong>client</strong> helps by providing a stable identity across retries‚Äîcommonly an <code>Idempotency-Key</code> header or a deterministic resource ID in the URL.</p><ul><li>‚úÖ Server: deduplicate, persist results, handle partial failures.</li><li>‚úÖ Client: generate cryptographically strong, unique keys; reuse the same key for the same intent.</li><li>‚ùå Anti-pattern: relying on client-side UI to block double clicks without server validation.</li></ul></div><div class=\"concept-section\"><h3>Scoping and Validation</h3><p>Define what a key uniquely identifies (per user, per merchant, per tenant). Validate that a reused key corresponds to the <em>same normalized request</em> to avoid collisions and misuse.</p><ul><li>Keys should be high-entropy (e.g., UUIDv4) and time-bounded.</li><li>Store a <code>request_hash</code> to ensure key reuse matches the same payload.</li><li>Return <code>409 Conflict</code> if the same key is used with a different request.</li></ul></div><div class=\"concept-section\"><h3>POST + Key vs PUT + Resource ID</h3><div style=\"display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;\"><div style=\"background: #e8f5e8; padding: 20px; border-radius: 10px;\"><h4>POST /payments + Idempotency-Key</h4><ul><li>‚úÖ Simple create semantics</li><li>‚úÖ Works well when resource ID is server-generated</li><li>‚ùå Requires key storage and replay logic</li></ul></div><div style=\"background: #e3f2fd; padding: 20px; border-radius: 10px;\"><h4>PUT /payments/{id}</h4><ul><li>‚úÖ Natural upsert semantics</li><li>‚úÖ No separate key store if request fully deterministic</li><li>‚ùå Client must pick stable IDs and manage collisions</li></ul></div></div></div><div class=\"exercise\"><h3>üõ†Ô∏è Scope the Key</h3><p><strong>Scenario:</strong> A marketplace with many merchants processes customer payments. You choose POST + Idempotency-Key.</p><p><strong>Your task:</strong> Propose a scoping rule for keys (e.g., per-merchant, per-customer). Explain how this avoids cross-tenant collisions and facilitates support/debugging.</p></div>"
      },
      {
        "id": 3,
        "title": "Designing the Idempotency Store & Concurrency Control",
        "goals": [
          "Design a durable idempotency record schema and request normalization",
          "Explain the difference between short-term locks and long-term expiry",
          "Prevent in-flight duplicate execution across workers"
        ],
        "content": "<div class=\"concept-section\"><h3>Data Model</h3><p>Create a dedicated <code>idempotency_records</code> store that maps a key to the normalized request and the final response.</p><ul><li><code>key</code> (PK), <code>request_hash</code>, <code>status</code>, <code>response_code</code>, <code>response_body</code>, <code>resource_id</code>, <code>locked_until</code>, <code>expires_at</code>, timestamps</li><li>Normalize request: sort maps, strip irrelevant headers, canonicalize numbers/strings.</li></ul></div><div class=\"concept-section\"><h3>Execution Flow</h3><div style=\"background:#f8f9fa; padding:10px; font-family: monospace; margin:10px 0;\">begin;<br>-- 1) Insert or select for update idempotency record<br>-- 2) If new: set status=in_progress, locked_until=now()+30s<br>-- 3) If existing: check request_hash; if mismatch ‚Üí 409; if succeeded/failed_final ‚Üí replay<br>-- 4) Perform side effect (create payment) atomically with commit<br>-- 5) Persist response + status=succeeded; set expires_at<br>commit;</div><p>Use a short-lived <strong>lock</strong> (<code>locked_until</code> or DB row lock) to ensure only one worker performs the action at a time.</p></div><div class=\"concept-section\"><h3>Locks vs Expiry</h3><ul><li><strong>locked_until:</strong> seconds-level, guards concurrent processing.</li><li><strong>expires_at:</strong> hours‚Äìdays, defines replay window and bounds storage growth.</li></ul></div><div class=\"concept-section\"><h3>Error Paths & Partial Failures</h3><ul><li>Response lost after success ‚Üí client retries ‚Üí server replays stored 201/200 and body.</li><li>Timeout while PSP charged card ‚Üí use same key with PSP and reconcile via webhooks/outbox.</li><li>Crash mid-flight ‚Üí on restart, <em>status=in_progress && locked_until expired</em> ‚Üí safely resume or retry.</li></ul></div><div class=\"exercise\"><h3>üõ†Ô∏è Race-Proof It</h3><p><strong>Scenario:</strong> Two identical requests with the same key arrive milliseconds apart to different app nodes.</p><p><strong>Your task:</strong> Describe the exact sequence of DB operations (including locks or <code>SELECT ... FOR UPDATE</code>) that ensures only one payment is created.</p></div>"
      },
      {
        "id": 4,
        "title": "End-to-End Idempotency Across Services",
        "goals": [
          "Apply idempotency to downstream calls and messaging (outbox/inbox)",
          "Contrast exactly-once processing myth vs at-least-once + idempotent consumers",
          "Choose a TTL policy aligned with client/gateway retry horizons"
        ],
        "content": "<div class=\"concept-section\"><h3>Downstream Consistency</h3><p>Idempotency must extend to downstream services: payment gateways, email services, inventory, and message brokers. Propagate the same key or derive a stable <em>operation ID</em> to each hop.</p><ul><li><strong>Outbox pattern:</strong> write events in the same DB transaction as state changes; publish after commit.</li><li><strong>Inbox table / processed_messages:</strong> consumers record message IDs to avoid reapplying side effects.</li></ul></div><div class=\"concept-section\"><h3>Exactly-Once vs Idempotent At-Least-Once</h3><p><em>Exactly-once</em> delivery is impractical in distributed systems. Design for <strong>at-least-once</strong> delivery with idempotent handlers and deduplication by message ID.</p></div><div class=\"concept-section\"><h3>Choosing TTL</h3><ul><li>Base TTL on max(client retry horizon, gateway/webhook horizon, incident recovery).</li><li>48‚Äì72h common for internet-facing payment flows; 24‚Äì36h for internal calls.</li><li>Compact records after TTL (keep key ‚Üí resource_id, drop response body).</li></ul></div><div class=\"exercise\"><h3>üõ†Ô∏è Propagate the Key</h3><p><strong>Scenario:</strong> Your service charges a card, sends a receipt email, and decrements inventory, with events on a queue.</p><p><strong>Your task:</strong> Describe how you would propagate and use a single idempotency key (or operation ID) across the gateway call, event production (outbox), and each consumer (inbox/processed table) to guarantee no duplicate side effects.</p></div>"
      },
      {
        "id": 5,
        "title": "Instrumentation, Testing, and Operational Playbooks",
        "goals": [
          "Instrument idempotency with metrics and logs for observability and SLOs",
          "Design test strategies for retries, races, and partial failures",
          "Prepare operational runbooks for incident handling and reconciliation"
        ],
        "content": "<div class=\"concept-section\"><h3>Observability & Metrics</h3><ul><li><strong>Metrics:</strong> replay rate, key collisions (hash mismatch), in-progress timeouts, lock contention, TTL expirations.</li><li><strong>Logs/Traces:</strong> include the idempotency key in structured logs and tracing spans.</li><li><strong>Dashboards:</strong> correlate retries with latency spikes and 5xx rates.</li></ul></div><div class=\"concept-section\"><h3>Testing Strategy</h3><div style=\"background:#f8f9fa; padding:10px; font-family: monospace; margin:10px 0;\">Test A: same key, identical payload ‚Üí first 201, subsequent 200 with identical body<br>Test B: same key, different payload ‚Üí 409 Conflict<br>Test C: concurrent requests with same key ‚Üí exactly one side effect<br>Test D: success but response lost ‚Üí retry returns stored success<br>Test E: PSP charged but local crash ‚Üí reconcile via webhook/outbox, then replay<br></div></div><div class=\"concept-section\"><h3>Operational Playbooks</h3><ul><li>Reprocessing: safe to retry with the same key inside TTL; after TTL, require a new key.</li><li>Data hygiene: scheduled compaction job to prune or downsample old records.</li><li>Security: scope keys per tenant; detect high-rate key reuse patterns as abuse.</li></ul></div><div class=\"concept-section\"><h3>Implementation Example (Pseudocode)</h3><div style=\"background:#f8f9fa; padding:10px; font-family: monospace; margin:10px 0;\">function handleCreatePayment(request) {<br>&nbsp;&nbsp;const key = request.headers['Idempotency-Key'];<br>&nbsp;&nbsp;const hash = normalizeAndHash(request.body);<br>&nbsp;&nbsp;tx(() =&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;let r = getRecordForUpdate(key);<br>&nbsp;&nbsp;&nbsp;&nbsp;if (!r) insertInProgress(key, hash, lock(30));<br>&nbsp;&nbsp;&nbsp;&nbsp;else if (r.status=='succeeded' || r.status=='failed_final') return replay(r);<br>&nbsp;&nbsp;&nbsp;&nbsp;else if (r.request_hash != hash) throw Conflict409;<br>&nbsp;&nbsp;&nbsp;&nbsp;const payment = createPayment(request.body);<br>&nbsp;&nbsp;&nbsp;&nbsp;const response = { code:201, body:serialize(payment) };<br>&nbsp;&nbsp;&nbsp;&nbsp;updateRecord(key, 'succeeded', response, payment.id, ttlHours(48));<br>&nbsp;&nbsp;});<br>&nbsp;&nbsp;publishOutboxEvents();<br>&nbsp;&nbsp;return response;<br>}<br></div></div><div class=\"concept-section\"><h3>üéâ Idempotency Journey Complete!</h3><p>You've now mastered:</p><ul><li>‚úÖ Why retries force idempotency</li><li>‚úÖ Client vs server responsibilities</li><li>‚úÖ Designing the idempotency store and concurrency control</li><li>‚úÖ End-to-end propagation with outbox/inbox</li><li>‚úÖ Instrumentation, testing, and operations</li></ul><p><strong>Next steps:</strong> Apply the same patterns to webhooks, message consumers, and multi-region deployments.</p></div>"
      }
    ]
  }
