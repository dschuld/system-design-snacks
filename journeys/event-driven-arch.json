{
  "id": "event-driven-architecture",
  "title": "Event-Driven Architecture",
  "totalLessons": 6,
  "available": true,
  "lessons": [
    {
      "id": 1,
      "title": "Why Choose Event-Driven Architecture?",
      "goals": [
        "Identify the scaling bottlenecks that make synchronous architectures inadequate",
        "Understand how event-driven systems enable loose coupling and independent scaling",
        "Recognize when to evolve from request-response to event-driven patterns"
      ],
      "content": "<div class=\"concept-section\">\n  <h3>The Synchronous Architecture Wall</h3>\n  <p>Imagine a busy restaurant where every order must be processed sequentially: take order ‚Üí check inventory ‚Üí reserve table ‚Üí process payment ‚Üí notify kitchen ‚Üí update loyalty points. If any step fails or slows down, the entire process stalls. This is the <strong>synchronous bottleneck</strong> that forces architectural evolution.</p>\n  <p>Event-Driven Architecture (EDA) transforms this into a flowing system: each step publishes events that other services consume independently. The order service doesn't wait for payment processing‚Äîit publishes an \"order placed\" event and continues. Payment service processes when ready and publishes \"payment completed.\"</p>\n</div>\n<div class=\"concept-section\">\n  <h3>The Problems EDA Solves</h3>\n  <ul>\n    <li><strong>Cascading failures:</strong> One slow service brings down entire request chains</li>\n    <li><strong>Tight coupling:</strong> Services must know about and wait for each other</li>\n    <li><strong>Scalability bottlenecks:</strong> Slowest service determines overall system performance</li>\n    <li><strong>Deployment dependencies:</strong> Can't deploy services independently due to synchronous contracts</li>\n    <li><strong>Temporal coupling:</strong> All services must be available simultaneously for workflows to complete</li>\n  </ul>\n</div>\n<div class=\"concept-section\">\n  <h3>Event-Driven Benefits</h3>\n  <div style=\"display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;\">\n    <div style=\"background: #e8f5e8; padding: 20px; border-radius: 10px;\">\n      <h4>‚úÖ Loose Coupling</h4>\n      <ul>\n        <li>Services only know about events, not other services</li>\n        <li>Add new consumers without changing producers</li>\n        <li>Independent deployment and scaling</li>\n      </ul>\n    </div>\n    <div style=\"background: #e3f2fd; padding: 20px; border-radius: 10px;\">\n      <h4>‚ö° Better Performance</h4>\n      <ul>\n        <li>Asynchronous processing reduces response times</li>\n        <li>Parallel processing of independent operations</li>\n        <li>Natural backpressure handling</li>\n      </ul>\n    </div>\n  </div>\n</div>\n<div class=\"concept-section\">\n  <h3>When NOT to Use Event-Driven Architecture</h3>\n  <div style=\"background: #ffebee; padding: 20px; border-radius: 10px; margin: 20px 0;\">\n    <h4>‚ö†Ô∏è EDA Warning Signs</h4>\n    <ul>\n      <li><strong>Simple CRUD applications:</strong> Direct database operations are more efficient</li>\n      <li><strong>Strong consistency requirements:</strong> Financial transactions needing immediate confirmation</li>\n      <li><strong>Small team/simple domain:</strong> Complexity overhead outweighs benefits</li>\n      <li><strong>Synchronous user workflows:</strong> Users expect immediate feedback (login, search)</li>\n    </ul>\n  </div>\n</div>\n<div class=\"concept-section\">\n  <h3>EDA vs Traditional Patterns</h3>\n  <div style=\"display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; margin: 20px 0;\">\n    <div style=\"background: #f5f5f5; padding: 15px; border-radius: 10px;\">\n      <h4>Monolith</h4>\n      <ul>\n        <li>‚úÖ Simple deployment</li>\n        <li>‚úÖ ACID transactions</li>\n        <li>‚ùå Single point of failure</li>\n        <li>‚ùå Scaling challenges</li>\n      </ul>\n    </div>\n    <div style=\"background: #fff3e0; padding: 15px; border-radius: 10px;\">\n      <h4>Sync Microservices</h4>\n      <ul>\n        <li>‚úÖ Service isolation</li>\n        <li>‚úÖ Independent deployment</li>\n        <li>‚ùå Cascading failures</li>\n        <li>‚ùå Tight coupling</li>\n      </ul>\n    </div>\n    <div style=\"background: #e8f5e8; padding: 15px; border-radius: 10px;\">\n      <h4>Event-Driven</h4>\n      <ul>\n        <li>‚úÖ Loose coupling</li>\n        <li>‚úÖ High availability</li>\n        <li>‚ùå Eventual consistency</li>\n        <li>‚ùå Complex debugging</li>\n      </ul>\n    </div>\n  </div>\n</div>\n<div class=\"concept-section\">\n  <h3>Real-World EDA Adoption Triggers</h3>\n  <ul>\n    <li><strong>Netflix:</strong> Migrated to EDA when synchronous API calls caused cascading outages during peak viewing</li>\n    <li><strong>Uber:</strong> Adopted events when real-time pricing updates couldn't keep up with demand spikes</li>\n    <li><strong>Airbnb:</strong> Switched to EDA when booking workflows became too complex for synchronous orchestration</li>\n  </ul>\n</div>\n<div class=\"exercise\">\n  <h3>üõ†Ô∏è Identify Your EDA Opportunity</h3>\n  <p><strong>Scenario:</strong> You're building a food delivery platform. Current architecture uses synchronous calls:</p>\n  <p>User places order ‚Üí Validate payment ‚Üí Check restaurant availability ‚Üí Calculate delivery time ‚Üí Reserve driver ‚Üí Send notifications</p>\n  <p><strong>Your task:</strong> Identify three specific problems this synchronous flow might create at scale, and propose how event-driven architecture would solve each problem.</p>\n  <p><strong>Consider:</strong> What happens during payment processing delays? How would you handle restaurant unavailability? What if the notification service is down?</p>\n  <p><em>Bonus: Design the event flow for this scenario, listing the events each service would publish and consume.</em></p>\n</div>"
    },
    {
      "id": 2,
      "title": "Event Streaming vs Event Sourcing Fundamentals",
      "goals": [
        "Distinguish between event streaming and event sourcing architectural patterns",
        "Understand when to apply each approach based on business requirements",
        "Learn the trade-offs between current state and event-based state reconstruction"
      ],
      "content": "<div class=\"concept-section\">\n  <h3>Two Fundamental Event Patterns</h3>\n  <p>Think of the difference between watching a live news feed versus reading a history book. <strong>Event streaming</strong> is like the live feed‚Äîyou see what's happening now and react to it. <strong>Event sourcing</strong> is like the history book‚Äîyou store every event that ever happened and can reconstruct any point in time by replaying the events.</p>\n  <p>Both patterns use events, but serve different purposes and have different architectural implications.</p>\n</div>\n<div class=\"concept-section\">\n  <h3>Event Streaming: Real-Time Data Flow</h3>\n  <p>Event streaming focuses on <strong>current events flowing through the system</strong>. Events represent things happening right now that other services need to know about.</p>\n  <ul>\n    <li><strong>Purpose:</strong> Distribute current state changes and trigger real-time reactions</li>\n    <li><strong>Storage:</strong> Events may be retained for hours/days, then discarded</li>\n    <li><strong>State:</strong> Services maintain their own current state in databases</li>\n    <li><strong>Use cases:</strong> User activity tracking, real-time notifications, system integration</li>\n  </ul>\n  <div style=\"background: #f8f9fa; padding: 10px; font-family: monospace; margin: 10px 0;\">\n    // Event streaming example<br>\n    UserLoggedIn { userId: 123, timestamp: now(), sessionId: \"abc\" }<br>\n    ‚Üí Analytics Service (update user activity)<br>\n    ‚Üí Notification Service (welcome message)<br>\n    ‚Üí Recommendation Service (prepare personalized content)\n  </div>\n</div>\n<div class=\"concept-section\">\n  <h3>Event Sourcing: History as Source of Truth</h3>\n  <p>Event sourcing treats <strong>events as the primary data store</strong>. Instead of storing current state, you store the sequence of events that led to that state.</p>\n  <ul>\n    <li><strong>Purpose:</strong> Complete audit trail, temporal queries, state reconstruction</li>\n    <li><strong>Storage:</strong> Events stored permanently as immutable log</li>\n    <li><strong>State:</strong> Current state derived by replaying events from the beginning</li>\n    <li><strong>Use cases:</strong> Financial systems, compliance-heavy domains, debugging complex state changes</li>\n  </ul>\n  <div style=\"background: #f8f9fa; padding: 10px; font-family: monospace; margin: 10px 0;\">\n    // Event sourcing example - Account balance<br>\n    AccountOpened { accountId: 456, initialBalance: 1000 }<br>\n    MoneyDeposited { accountId: 456, amount: 500 }<br>\n    MoneyWithdrawn { accountId: 456, amount: 200 }<br>\n    ‚Üí Current balance = 1000 + 500 - 200 = 1300\n  </div>\n</div>\n<div class=\"concept-section\">\n  <h3>Comparing the Approaches</h3>\n  <div style=\"display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;\">\n    <div style=\"background: #e3f2fd; padding: 20px; border-radius: 10px;\">\n      <h4>Event Streaming</h4>\n      <ul>\n        <li>‚úÖ Lower storage requirements</li>\n        <li>‚úÖ Faster queries (pre-computed state)</li>\n        <li>‚úÖ Simpler mental model</li>\n        <li>‚ùå No historical reconstruction</li>\n        <li>‚ùå Limited audit capabilities</li>\n      </ul>\n    </div>\n    <div style=\"background: #f3e5f5; padding: 20px; border-radius: 10px;\">\n      <h4>Event Sourcing</h4>\n      <ul>\n        <li>‚úÖ Complete audit trail</li>\n        <li>‚úÖ Temporal queries (\"balance on March 1st\")</li>\n        <li>‚úÖ Easy debugging and replay</li>\n        <li>‚ùå Higher storage costs</li>\n        <li>‚ùå Complex query performance</li>\n      </ul>\n    </div>\n  </div>\n</div>\n<div class=\"concept-section\">\n  <h3>Hybrid Approaches</h3>\n  <p>Many systems combine both patterns:</p>\n  <ul>\n    <li><strong>Event sourcing for critical aggregates</strong> (user accounts, orders)</li>\n    <li><strong>Event streaming for cross-service communication</strong> (notifications, integrations)</li>\n    <li><strong>Snapshots + events</strong> to optimize event sourcing performance</li>\n    <li><strong>CQRS</strong> to separate write (event sourced) and read (streaming) models</li>\n  </ul>\n</div>\n<div class=\"concept-section\">\n  <h3>Choosing Your Pattern</h3>\n  <div style=\"display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;\">\n    <div style=\"background: #e8f5e8; padding: 20px; border-radius: 10px;\">\n      <h4>Choose Event Streaming When:</h4>\n      <ul>\n        <li>Real-time reactions are more important than history</li>\n        <li>Current state queries dominate your access patterns</li>\n        <li>Storage costs are a major concern</li>\n        <li>Integration between services is the primary goal</li>\n      </ul>\n    </div>\n    <div style=\"background: #fff3e0; padding: 20px; border-radius: 10px;\">\n      <h4>Choose Event Sourcing When:</h4>\n      <ul>\n        <li>Audit trails are business-critical</li>\n        <li>You need to query historical states</li>\n        <li>Complex business rules change frequently</li>\n        <li>Debugging requires understanding state evolution</li>\n      </ul>\n    </div>\n  </div>\n</div>\n<div class=\"concept-section\">\n  <h3>Implementation Technologies</h3>\n  <ul>\n    <li><strong>Event Streaming:</strong> Apache Kafka, Amazon Kinesis, Azure Event Hubs</li>\n    <li><strong>Event Sourcing:</strong> EventStore, Apache Kafka (with compaction), Custom solutions</li>\n    <li><strong>Processing:</strong> Kafka Streams, Apache Flink, Spring Cloud Stream</li>\n  </ul>\n</div>\n<div class=\"exercise\">\n  <h3>üõ†Ô∏è Design Your Event Strategy</h3>\n  <p><strong>Scenario:</strong> You're building an e-commerce system with these requirements:</p>\n  <ol>\n    <li><strong>User behavior tracking:</strong> Page views, clicks, searches for recommendations</li>\n    <li><strong>Order management:</strong> Must track every state change for compliance and refunds</li>\n    <li><strong>Inventory updates:</strong> Real-time stock updates across multiple sales channels</li>\n    <li><strong>Price changes:</strong> Need to know exact price at time of each order</li>\n  </ol>\n  <p><strong>Your task:</strong> For each requirement, decide whether to use event streaming or event sourcing. Explain your reasoning and describe the events you would capture.</p>\n  <p><strong>Consider:</strong> How would you handle a customer asking \"Why was I charged $99 when the product now costs $89?\" How would you generate \"customers who viewed this also bought\" recommendations?</p>\n</div>"
    },
    {
      "id": 3,
      "title": "CQRS and Advanced Event Patterns",
      "goals": [
        "Master Command Query Responsibility Segregation in event-driven systems",
        "Understand event ordering, deduplication, and exactly-once processing challenges",
        "Learn event versioning strategies for evolving schemas over time"
      ],
      "content": "<div class=\"concept-section\">\n  <h3>CQRS: Separating Reads and Writes</h3>\n  <p>Command Query Responsibility Segregation (CQRS) recognizes that reading data and writing data have different requirements. It's like having separate lanes for buses and cars‚Äîeach optimized for their specific traffic patterns.</p>\n  <p>In event-driven systems, CQRS typically means:</p>\n  <ul>\n    <li><strong>Write side:</strong> Commands create events, stored in event streams</li>\n    <li><strong>Read side:</strong> Events build optimized read models (projections)</li>\n    <li><strong>Separation:</strong> Different data stores, different schemas, different scaling</li>\n  </ul>\n</div>\n<div class=\"concept-section\">\n  <h3>CQRS Benefits in Event-Driven Architecture</h3>\n  <ul>\n    <li><strong>Independent scaling:</strong> Scale read replicas without affecting write performance</li>\n    <li><strong>Optimized queries:</strong> Read models designed for specific query patterns</li>\n    <li><strong>Multiple views:</strong> Same events can create different read models</li>\n    <li><strong>Event replay:</strong> Rebuild read models from events if corrupted</li>\n    <li><strong>Performance:</strong> No complex joins‚Äîeach read model is pre-computed</li>\n  </ul>\n</div>\n<div class=\"concept-section\">\n  <h3>Event Ordering Challenges</h3>\n  <p>In distributed systems, events don't always arrive in the order they were created. Consider two events:</p>\n  <div style=\"background: #f8f9fa; padding: 10px; font-family: monospace; margin: 10px 0;\">\n    UserRegistered { userId: 123, email: \"user@example.com\" }<br>\n    EmailUpdated { userId: 123, newEmail: \"newemail@example.com\" }\n  </div>\n  <p>If EmailUpdated arrives before UserRegistered, your system might try to update a user that doesn't exist yet.</p>\n  <h4>Ordering Solutions:</h4>\n  <ul>\n    <li><strong>Partition by entity ID:</strong> All events for user 123 go to same partition</li>\n    <li><strong>Sequence numbers:</strong> Include ordering information in events</li>\n    <li><strong>Vector clocks:</strong> Track causal relationships between events</li>\n    <li><strong>Accept eventual consistency:</strong> Design for out-of-order tolerance</li>\n  </ul>\n</div>\n<div class=\"concept-section\">\n  <h3>Exactly-Once Processing</h3>\n  <p>Networks are unreliable. Events might be:</p>\n  <ul>\n    <li><strong>Duplicated:</strong> Network retry sends the same event twice</li>\n    <li><strong>Lost:</strong> Network failure drops events entirely</li>\n    <li><strong>Reordered:</strong> Events arrive in different order than sent</li>\n  </ul>\n  <div style=\"display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; margin: 20px 0;\">\n    <div style=\"background: #ffebee; padding: 15px; border-radius: 10px;\">\n      <h4>At-Most-Once</h4>\n      <ul>\n        <li>‚úÖ No duplicates</li>\n        <li>‚ùå May lose events</li>\n        <li>Use: Metrics, logging</li>\n      </ul>\n    </div>\n    <div style=\"background: #fff3e0; padding: 15px; border-radius: 10px;\">\n      <h4>At-Least-Once</h4>\n      <ul>\n        <li>‚úÖ No lost events</li>\n        <li>‚ùå May have duplicates</li>\n        <li>Use: Most business events</li>\n      </ul>\n    </div>\n    <div style=\"background: #e8f5e8; padding: 15px; border-radius: 10px;\">\n      <h4>Exactly-Once</h4>\n      <ul>\n        <li>‚úÖ Perfect delivery</li>\n        <li>‚ùå Complex & expensive</li>\n        <li>Use: Financial transactions</li>\n      </ul>\n    </div>\n  </div>\n</div>\n<div class=\"concept-section\">\n  <h3>Idempotent Event Processing</h3>\n  <p>Since exactly-once is expensive, design for idempotency‚Äîprocessing the same event multiple times has the same effect as processing it once.</p>\n  <div style=\"background: #f8f9fa; padding: 10px; font-family: monospace; margin: 10px 0;\">\n    // Bad: Non-idempotent<br>\n    onMoneyDeposited(event) {<br>\n    &nbsp;&nbsp;balance += event.amount<br>\n    }<br><br>\n    // Good: Idempotent<br>\n    onMoneyDeposited(event) {<br>\n    &nbsp;&nbsp;if (!processedEventIds.contains(event.id)) {<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;balance += event.amount<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;processedEventIds.add(event.id)<br>\n    &nbsp;&nbsp;}<br>\n    }\n  </div>\n</div>\n<div class=\"concept-section\">\n  <h3>Event Versioning and Schema Evolution</h3>\n  <p>Events stored in event sourcing systems live forever, but business requirements change. You need strategies to evolve event schemas without breaking existing events.</p>\n  <ul>\n    <li><strong>Additive changes:</strong> Add optional fields with defaults</li>\n    <li><strong>Event upcasting:</strong> Transform old events to new format during replay</li>\n    <li><strong>Event migration:</strong> Batch process to update stored events</li>\n    <li><strong>Multiple versions:</strong> Support reading both old and new formats</li>\n  </ul>\n  <div style=\"background: #f8f9fa; padding: 10px; font-family: monospace; margin: 10px 0;\">\n    // Version 1<br>\n    UserRegistered { userId: 123, email: \"user@example.com\" }<br><br>\n    // Version 2 - Added optional field<br>\n    UserRegistered { <br>\n    &nbsp;&nbsp;userId: 123, <br>\n    &nbsp;&nbsp;email: \"user@example.com\",<br>\n    &nbsp;&nbsp;registrationSource: \"web\" // defaults to \"unknown\" for v1 events<br>\n    }\n  </div>\n</div>\n<div class=\"concept-section\">\n  <h3>Read Model Synchronization Patterns</h3>\n  <ul>\n    <li><strong>Eventually consistent:</strong> Accept temporary inconsistency for better performance</li>\n    <li><strong>Synchronous projection:</strong> Update read model in same transaction as event</li>\n    <li><strong>Catch-up subscription:</strong> Replay missed events when read model is behind</li>\n    <li><strong>Snapshotting:</strong> Periodically save read model state for faster recovery</li>\n  </ul>\n</div>\n<div class=\"exercise\">\n  <h3>üõ†Ô∏è Design CQRS with Event Handling</h3>\n  <p><strong>Scenario:</strong> You're building a social media platform where users can post content, follow other users, and see a personalized feed. You've decided to use CQRS with event sourcing for posts and event streaming for feed updates.</p>\n  <p><strong>Your task:</strong> Design the event flow and read models for these operations:</p>\n  <ol>\n    <li><strong>User creates a post</strong> ‚Üí All followers should see it in their feed</li>\n    <li><strong>User follows someone</strong> ‚Üí Their feed should include that person's recent posts</li>\n    <li><strong>User unfollows someone</strong> ‚Üí Remove that person's posts from follower's feed</li>\n  </ol>\n  <p><strong>Consider:</strong></p>\n  <ul>\n    <li>What events would you publish for each operation?</li>\n    <li>How would you handle the case where a user follows someone with 10K existing posts?</li>\n    <li>How would you ensure feed updates are idempotent?</li>\n    <li>What read models would you create for efficient feed queries?</li>\n  </ul>\n  <p><em>Bonus: How would you handle event schema changes if you later want to add \"post categories\" or \"post visibility settings\"?</em></p>\n</div>"
    },
    {
      "id": 4,
      "title": "Distributed Transactions with Saga Patterns",
      "goals": [
        "Design choreography vs orchestration-based saga implementations",
        "Handle failures and compensating actions in long-running processes",
        "Choose between saga patterns and traditional distributed transactions"
      ],
      "content": "<div class=\"concept-section\">\n  <h3>The Distributed Transaction Problem</h3>\n  <p>Imagine coordinating a wedding where the venue, catering, flowers, and music must all be booked together‚Äîif any one fails, you need to cancel everything. In distributed systems, this becomes exponentially more complex when services are spread across networks, data centers, and organizational boundaries.</p>\n  <p>Traditional ACID transactions work within a single database, but distributed transactions across multiple services face the dual challenges of network failures and service independence.</p>\n</div>\n<div class=\"concept-section\">\n  <h3>Saga Pattern: Distributed Transaction Alternative</h3>\n  <p>A saga breaks down a distributed transaction into a sequence of local transactions, each with a defined compensation action. If any step fails, the saga runs compensations in reverse order to undo completed work.</p>\n  <p><strong>Key principles:</strong></p>\n  <ul>\n    <li>Each step is a local transaction that can succeed or fail independently</li>\n    <li>Every step has a corresponding compensation action</li>\n    <li>Compensations must be idempotent and eventually successful</li>\n    <li>The overall process achieves eventual consistency</li>\n  </ul>\n</div>\n<div class=\"concept-section\">\n  <h3>Choreography-Based Sagas</h3>\n  <p>Services coordinate by publishing and reacting to events, with no central coordinator. Each service knows what to do next based on events it receives.</p>\n  <div style=\"background: #f8f9fa; padding: 10px; font-family: monospace; margin: 10px 0;\">\n    // E-commerce order choreography<br>\n    Order Service: OrderCreated ‚Üí Payment Service<br>\n    Payment Service: PaymentProcessed ‚Üí Inventory Service<br>\n    Inventory Service: ItemsReserved ‚Üí Shipping Service<br>\n    Shipping Service: ShipmentScheduled ‚Üí Order Service<br>\n    Order Service: OrderConfirmed ‚Üí Customer\n  </div>\n  <ul>\n    <li>‚úÖ <strong>Loose coupling:</strong> Services don't know about each other directly</li>\n    <li>‚úÖ <strong>High availability:</strong> No single point of failure</li>\n    <li>‚úÖ <strong>Scalable:</strong> Easy to add new participants</li>\n    <li>‚ùå <strong>Complex to trace:</strong> Hard to understand overall flow</li>\n    <li>‚ùå <strong>Difficult testing:</strong> End-to-end scenarios involve many services</li>\n  </ul>\n</div>\n<div class=\"concept-section\">\n  <h3>Orchestration-Based Sagas</h3>\n  <p>A central saga orchestrator manages the transaction flow, telling each service what to do and handling failures.</p>\n  <div style=\"background: #f8f9fa; padding: 10px; font-family: monospace; margin: 10px 0;\">\n    // Order orchestrator flow<br>\n    Orchestrator ‚Üí Payment Service: ProcessPayment<br>\n    Payment Service ‚Üí Orchestrator: PaymentSucceeded<br>\n    Orchestrator ‚Üí Inventory Service: ReserveItems<br>\n    Inventory Service ‚Üí Orchestrator: ItemsReserved<br>\n    Orchestrator ‚Üí Shipping Service: ScheduleShipment<br>\n    // If shipping fails:<br>\n    Orchestrator ‚Üí Inventory Service: ReleaseItems<br>\n    Orchestrator ‚Üí Payment Service: RefundPayment\n  </div>\n  <ul>\n    <li>‚úÖ <strong>Clear flow:</strong> Easy to understand and debug</li>\n    <li>‚úÖ <strong>Centralized logic:</strong> Business rules in one place</li>\n    <li>‚úÖ <strong>Better monitoring:</strong> Single place to track progress</li>\n    <li>‚ùå <strong>Single point of failure:</strong> Orchestrator must be highly available</li>\n    <li>‚ùå <strong>Coupling:</strong> Orchestrator knows about all participants</li>\n  </ul>\n</div>\n<div class=\"concept-section\">\n  <h3>Compensation Strategies</h3>\n  <p>Not all operations can be perfectly \"undone.\" Compensation strategies vary by business context:</p>\n  <div style=\"display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;\">\n    <div style=\"background: #e8f5e8; padding: 20px; border-radius: 10px;\">\n      <h4>Perfect Compensation</h4>\n      <ul>\n        <li><strong>Reserve inventory</strong> ‚Üí Release reservation</li>\n        <li><strong>Hold payment</strong> ‚Üí Release hold</li>\n        <li><strong>Create database record</strong> ‚Üí Delete record</li>\n      </ul>\n    </div>\n    <div style=\"background: #fff3e0; padding: 20px; border-radius: 10px;\">\n      <h4>Business Compensation</h4>\n      <ul>\n        <li><strong>Send email</strong> ‚Üí Send apology email</li>\n        <li><strong>Charge credit card</strong> ‚Üí Issue refund</li>\n        <li><strong>Ship product</strong> ‚Üí Process return</li>\n      </ul>\n    </div>\n  </div>\n</div>\n<div class=\"concept-section\">\n  <h3>Handling Saga Failures</h3>\n  <ul>\n    <li><strong>Step failure:</strong> Execute compensations for completed steps</li>\n    <li><strong>Compensation failure:</strong> Retry with exponential backoff, eventually manual intervention</li>\n    <li><strong>Partial failure:</strong> Some participants succeed, others timeout</li>\n    <li><strong>Saga timeout:</strong> Long-running sagas may need to be abandoned</li>\n  </ul>\n  <p><strong>Best practices for resilient sagas:</strong></p>\n  <ul>\n    <li>Make compensations idempotent</li>\n    <li>Use timeouts and circuit breakers</li>\n    <li>Implement dead letter queues for failed steps</li>\n    <li>Provide manual intervention tools for stuck sagas</li>\n  </ul>\n</div>\n<div class=\"concept-section\">\n  <h3>Saga vs Two-Phase Commit</h3>\n  <div style=\"display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;\">\n    <div style=\"background: #e3f2fd; padding: 20px; border-radius: 10px;\">\n      <h4>Two-Phase Commit</h4>\n      <ul>\n        <li>‚úÖ ACID guarantees</li>\n        <li>‚úÖ Strong consistency</li>\n        <li>‚ùå Blocking protocol</li>\n        <li>‚ùå Poor fault tolerance</li>\n        <li><strong>Use:</strong> Single data center, reliable network</li>\n      </ul>\n    </div>\n    <div style=\"background: #f3e5f5; padding: 20px; border-radius: 10px;\">\n      <h4>Saga Pattern</h4>\n      <ul>\n        <li>‚úÖ High availability</li>\n        <li>‚úÖ Better performance</li>\n        <li>‚ùå Eventual consistency</li>\n        <li>‚ùå Complex compensation logic</li>\n        <li><strong>Use:</strong> Distributed systems, long-running processes</li>\n      </ul>\n    </div>\n  </div>\n</div>\n<div class=\"concept-section\">\n  <h3>Implementing Sagas with Events</h3>\n  <p>Event-driven systems are natural fit for sagas. Each saga step publishes success/failure events, and the next step (or compensation) reacts to those events.</p>\n  <div style=\"background: #f8f9fa; padding: 10px; font-family: monospace; margin: 10px 0;\">\n    // Saga state machine using events<br>\n    State: OrderCreated<br>\n    ‚Üí Event: ProcessPayment<br>\n    State: PaymentProcessing<br>\n    ‚Üí Event: PaymentSucceeded | PaymentFailed<br>\n    State: InventoryReserving | CompensatingPayment<br>\n    ‚Üí Event: ItemsReserved | PaymentCompensated<br>\n    State: ShippingScheduling | OrderCancelled\n  </div>\n</div>\n<div class=\"exercise\">\n  <h3>üõ†Ô∏è Design a Saga Implementation</h3>\n  <p><strong>Scenario:</strong> You're building a travel booking platform where users can book flights, hotels, and car rentals in a single transaction. The booking must be atomic‚Äîeither everything is booked or nothing is.</p>\n  <p><strong>Services involved:</strong></p>\n  <ul>\n    <li><strong>Payment Service:</strong> Charges customer's credit card</li>\n    <li><strong>Flight Service:</strong> Books airline seats (external API, may timeout)</li>\n    <li><strong>Hotel Service:</strong> Reserves hotel rooms (has overbooking risk)</li>\n    <li><strong>Car Service:</strong> Reserves rental car (limited availability)</li>\n  </ul>\n  <p><strong>Your task:</strong></p>\n  <ol>\n    <li>Choose choreography or orchestration and justify your decision</li>\n    <li>Design the happy path flow with events/commands</li>\n    <li>Design compensation flows for common failure scenarios:</li>\n    <ul>\n      <li>Flight booking fails after payment succeeds</li>\n      <li>Hotel is overbooked after flight and payment succeed</li>\n      <li>Car service times out after other bookings succeed</li>\n    </ul>\n    <li>Handle these edge cases:</li>\n    <ul>\n      <li>Payment compensation fails (refund doesn't work)</li>\n      <li>Flight API is down but eventually comes back</li>\n      <li>User cancels while booking is in progress</li>\n    </ul>\n  </ol>\n  <p><strong>Consider:</strong> How would you implement timeouts? What happens if the saga orchestrator crashes midway? How would you provide status updates to the user?</p>\n</div>"
    },
    {
      "id": 5,
      "title": "Production EDA: Scaling and Operations",
      "goals": [
        "Learn from real-world EDA implementations at Netflix, Uber, and LinkedIn",
        "Master event routing, partitioning, and backpressure handling strategies",
        "Understand monitoring, debugging, and migration approaches for event-driven systems"
      ],
      "content": "<div class=\"concept-section\">\n  <h3>Real-World EDA at Scale</h3>\n  <p>Let's examine how industry leaders implemented event-driven architecture to handle massive scale and complex business requirements.</p>\n</div>\n<div class=\"concept-section\">\n  <h3>Netflix: Event-Driven Video Streaming</h3>\n  <p>Netflix processes billions of events daily for personalization, content delivery, and operational monitoring.</p>\n  <ul>\n    <li><strong>Challenge:</strong> 200M+ users generating viewing events, requiring real-time recommendations</li>\n    <li><strong>Solution:</strong> Multi-tier event architecture with Kafka at the core</li>\n    <li><strong>Event types:</strong> Play/pause/seek events, A/B test events, device performance events</li>\n    <li><strong>Key insight:</strong> Separate event streams by SLA‚Äîreal-time vs batch processing</li>\n  </ul>\n  <p><strong>Architecture lessons:</strong></p>\n  <ul>\n    <li>Use event schemas with backward compatibility for gradual deployments</li>\n    <li>Implement circuit breakers to prevent cascading failures</li>\n    <li>Separate critical path events (billing) from analytics events</li>\n  </ul>\n  <p><a href=\"https://netflixtechblog.com/kafka-inside-keystone-pipeline-dd5aeabaf6bb\" target=\"_blank\" rel=\"noopener noreferrer\">Netflix Keystone Pipeline</a></p>\n</div>\n<div class=\"concept-section\">\n  <h3>Uber: Real-Time Location and Pricing</h3>\n  <p>Uber's event-driven architecture handles real-time location updates, dynamic pricing, and trip coordination.</p>\n  <ul>\n    <li><strong>Challenge:</strong> Sub-second location updates from millions of drivers and riders</li>\n    <li><strong>Solution:</strong> Event sourcing for trip state, streaming for location updates</li>\n    <li><strong>Scale:</strong> 100M+ location events per second during peak hours</li>\n    <li><strong>Key insight:</strong> Geographic partitioning for location-based events</li>\n  </ul>\n  <p><strong>Architecture lessons:</strong></p>\n  <ul>\n    <li>Partition events by geographic regions to reduce cross-region traffic</li>\n    <li>Use different consistency models for different event types</li>\n    <li>Implement sophisticated backpressure handling for mobile clients</li>\n  </ul>\n  <p><a href=\"https://eng.uber.com/reliable-reprocessing/\" target=\"_blank\" rel=\"noopener noreferrer\">Uber Event Reprocessing</a></p>\n</div>\n<div class=\"concept-section\">\n  <h3>LinkedIn: Professional Network Events</h3>\n  <p>LinkedIn uses event-driven architecture for feed generation, recommendations, and member interactions.</p>\n  <ul>\n    <li><strong>Challenge:</strong> Generate personalized feeds for 800M+ members in real-time</li>\n    <li><strong>Solution:</strong> Lambda architecture combining real-time and batch processing</li>\n    <li><strong>Key insight:</strong> Fan-out strategies based on member influence and connections</li>\n  </ul>\n  <p><strong>Architecture lessons:</strong></p>\n  <ul>\n    <li>Use member graph topology to optimize event routing</li>\n    <li>Implement smart fan-out (don't send celebrity updates to all followers immediately)</li>\n    <li>Cache frequently accessed member data to reduce event processing latency</li>\n  </ul>\n</div>\n<div class=\"concept-section\">\n  <h3>Event Routing and Partitioning Strategies</h3>\n  <div style=\"display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;\">\n    <div style=\"background: #e8f5e8; padding: 20px; border-radius: 10px;\">\n      <h4>Routing Strategies</h4>\n      <ul>\n        <li><strong>Topic-based:</strong> Route by event type</li>\n        <li><strong>Content-based:</strong> Route by event payload</li>\n        <li><strong>Geographic:</strong> Route by user/data location</li>\n        <li><strong>Load-based:</strong> Route to least busy consumers</li>\n      </ul>\n    </div>\n    <div style=\"background: #e3f2fd; padding: 20px; border-radius: 10px;\">\n      <h4>Partitioning Strategies</h4>\n      <ul>\n        <li><strong>User-based:</strong> Hash(user_id) % partitions</li>\n        <li><strong>Time-based:</strong> Partition by event timestamp</li>\n        <li><strong>Random:</strong> Distribute load evenly</li>\n        <li><strong>Custom:</strong> Business logic determines partition</li>\n      </ul>\n    </div>\n  </div>\n</div>\n<div class=\"concept-section\">\n  <h3>Handling Backpressure</h3>\n  <p>When consumers can't keep up with producers, backpressure strategies prevent system collapse:</p>\n  <ul>\n    <li><strong>Drop events:</strong> Sacrifice completeness for availability (suitable for metrics)</li>\n    <li><strong>Buffer events:</strong> Temporary storage with overflow handling</li>\n    <li><strong>Rate limiting:</strong> Throttle producers based on consumer capacity</li>\n    <li><strong>Load shedding:</strong> Prioritize critical events, drop less important ones</li>\n    <li><strong>Auto-scaling:</strong> Dynamically add consumer instances</li>\n  </ul>\n  <div style=\"background: #f8f9fa; padding: 10px; font-family: monospace; margin: 10px 0;\">\n    // Backpressure implementation example<br>\n    if (consumerLag > MAX_LAG) {<br>\n    &nbsp;&nbsp;if (event.priority == LOW) {<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;dropEvent(event);<br>\n    &nbsp;&nbsp;} else if (event.priority == HIGH) {<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;bufferEvent(event);<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;scaleConsumers();<br>\n    &nbsp;&nbsp;}<br>\n    }\n  </div>\n</div>\n<div class=\"concept-section\">\n  <h3>Monitoring Event-Driven Systems</h3>\n  <ul>\n    <li><strong>Event metrics:</strong> Throughput, latency, error rates per event type</li>\n    <li><strong>Consumer lag:</strong> How far behind consumers are from producers</li>\n    <li><strong>Dead letter queues:</strong> Track failed events and processing errors</li>\n    <li><strong>End-to-end tracing:</strong> Follow events through entire processing pipeline</li>\n    <li><strong>Business metrics:</strong> Track business KPIs affected by event processing</li>\n  </ul>\n  <p><strong>Key monitoring tools:</strong></p>\n  <ul>\n    <li>Kafka Manager, Kafdrop for Kafka cluster monitoring</li>\n    <li>Jaeger, Zipkin for distributed tracing</li>\n    <li>Prometheus + Grafana for metrics and alerting</li>\n    <li>ELK stack for event log analysis</li>\n  </ul>\n</div>\n<div class=\"concept-section\">\n  <h3>Debugging Event-Driven Systems</h3>\n  <div style=\"background: #fff3e0; padding: 20px; border-radius: 10px; margin: 20px 0;\">\n    <h4>‚ö†Ô∏è Common EDA Debugging Challenges</h4>\n    <ul>\n      <li><strong>Event ordering:</strong> Events processed out of sequence</li>\n      <li><strong>Lost events:</strong> Messages dropped due to failures</li>\n      <li><strong>Duplicate processing:</strong> Same event processed multiple times</li>\n      <li><strong>Poison messages:</strong> Malformed events causing consumer crashes</li>\n      <li><strong>Cascading failures:</strong> One slow consumer affecting entire pipeline</li>\n    </ul>\n  </div>\n  <p><strong>Debugging strategies:</strong></p>\n  <ul>\n    <li>Implement correlation IDs to trace events across services</li>\n    <li>Use event versioning to handle schema evolution</li>\n    <li>Build event replay capabilities for testing scenarios</li>\n    <li>Create event visualization tools for understanding flow</li>\n  </ul>\n</div>\n<div class=\"concept-section\">\n  <h3>Migration Strategies to EDA</h3>\n  <div style=\"display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;\">\n    <div style=\"background: #e8f5e8; padding: 20px; border-radius: 10px;\">\n      <h4>Strangler Fig Pattern</h4>\n      <ul>\n        <li>Gradually replace synchronous calls with events</li>\n        <li>Run both systems in parallel during transition</li>\n        <li>Route increasing percentage of traffic to new system</li>\n        <li>‚úÖ Low risk, incremental validation</li>\n      </ul>\n    </div>\n    <div style=\"background: #e3f2fd; padding: 20px; border-radius: 10px;\">\n      <h4>Event Storming Approach</h4>\n      <ul>\n        <li>Map existing business processes as event flows</li>\n        <li>Identify natural service boundaries</li>\n        <li>Design events that represent business outcomes</li>\n        <li>‚úÖ Domain-driven, business-aligned events</li>\n      </ul>\n    </div>\n  </div>\n</div>\n<div class=\"exercise\">\n  <h3>üõ†Ô∏è Design Production-Ready EDA</h3>\n  <p><strong>Scenario:</strong> You're migrating a monolithic e-commerce platform (1M daily orders, 10M page views) to event-driven architecture. Current pain points:</p>\n  <ul>\n    <li>Inventory updates cause website slowdowns during sales</li>\n    <li>Recommendation engine rebuilds take 6 hours, blocking other features</li>\n    <li>Order processing failures require manual intervention</li>\n    <li>A/B testing data takes 24 hours to become available</li>\n  </ul>\n  <p><strong>Your task:</strong> Design a production-ready EDA solution addressing:</p>\n  <ol>\n    <li><strong>Event Architecture:</strong></li>\n    <ul>\n      <li>What events would you capture and how would you partition them?</li>\n      <li>Which events need real-time processing vs batch processing?</li>\n      <li>How would you handle peak traffic (Black Friday = 10x normal load)?</li>\n    </ul>\n    <li><strong>Operational Excellence:</strong></li>\n    <ul>\n      <li>What metrics would you monitor and what would trigger alerts?</li>\n      <li>How would you handle poison messages and dead letter queues?</li>\n      <li>What's your backpressure strategy when recommendation engine can't keep up?</li>\n    </ul>\n    <li><strong>Migration Strategy:</strong></li>\n    <ul>\n      <li>Which functionality would you migrate first and why?</li>\n      <li>How would you validate that the new system works correctly?</li>\n      <li>What's your rollback plan if something goes wrong?</li>\n    </ul>\n  </ol>\n  <p><strong>Consider:</strong> How would you ensure order processing consistency during the migration? How would you handle the case where old and new systems both process the same order?</p>\n</div>\n<div class=\"concept-section\">\n  <h3>üéâ Event-Driven Architecture Mastery Complete!</h3>\n  <p>You've now mastered:</p>\n  <ul>\n    <li>‚úÖ Understanding when and why to adopt event-driven architecture</li>\n    <li>‚úÖ Distinguishing between event streaming and event sourcing patterns</li>\n    <li>‚úÖ Implementing CQRS with advanced event handling techniques</li>\n    <li>‚úÖ Designing distributed transactions using saga patterns</li>\n    <li>‚úÖ Learning from real-world implementations and operational best practices</li>\n  </ul>\n  <p><strong>Next steps:</strong> Practice implementing EDA in a small project, explore specific technologies like Kafka Streams or Apache Pulsar, or dive deeper into related topics like distributed consensus and eventual consistency patterns.</p>\n</div>"
    },
    {
      "id": 6,
      "title": "Event-Driven Architecture Knowledge Check",
      "goals": [
        "Test your understanding of EDA fundamentals and when to apply event-driven patterns",
        "Evaluate your knowledge of event streaming, event sourcing, and CQRS implementation strategies",
        "Assess your grasp of saga patterns, production challenges, and real-world solutions"
      ],
      "content": "<div class=\"concept-section\">\n  <h3>üß† Test Your Event-Driven Architecture Mastery</h3>\n  <p>Time to put your knowledge to the test! This quiz covers key concepts from all 5 lessons. Select all correct answers for each question, then click \"Reveal Answers\" to see how you did.</p>\n  <p><strong>Instructions:</strong> Multiple answers may be correct for each question. Check all that apply!</p>\n</div>\n\n<div class=\"quiz-container\" style=\"margin: 20px 0;\">\n  <div class=\"quiz-question\" style=\"background: #f8f9fa; padding: 20px; margin: 15px 0; border-radius: 10px; border-left: 4px solid #007bff;\">\n    <h4>Question 1: EDA Adoption Triggers (Lesson 1)</h4>\n    <p><strong>Which scenarios indicate that event-driven architecture would be beneficial?</strong></p>\n    <div class=\"quiz-options\">\n      <label><input type=\"checkbox\" data-question=\"1\" data-correct=\"true\"> Cascading failures occur when one service slows down the entire request chain</label><br>\n      <label><input type=\"checkbox\" data-question=\"1\" data-correct=\"false\"> You need simple CRUD operations on a single entity</label><br>\n      <label><input type=\"checkbox\" data-question=\"1\" data-correct=\"true\"> Services are tightly coupled and can't be deployed independently</label><br>\n      <label><input type=\"checkbox\" data-question=\"1\" data-correct=\"true\"> Peak traffic causes system-wide slowdowns due to synchronous processing</label><br>\n      <label><input type=\"checkbox\" data-question=\"1\" data-correct=\"false\"> Users need immediate, synchronous confirmation for all operations</label>\n    </div>\n  </div>\n\n  <div class=\"quiz-question\" style=\"background: #f8f9fa; padding: 20px; margin: 15px 0; border-radius: 10px; border-left: 4px solid #28a745;\">\n    <h4>Question 2: Event Streaming vs Event Sourcing (Lesson 2)</h4>\n    <p><strong>When should you choose event sourcing over event streaming?</strong></p>\n    <div class=\"quiz-options\">\n      <label><input type=\"checkbox\" data-question=\"2\" data-correct=\"false\"> You need to reduce storage costs and optimize for current state queries</label><br>\n      <label><input type=\"checkbox\" data-question=\"2\" data-correct=\"true\"> Complete audit trails are business-critical for compliance</label><br>\n      <label><input type=\"checkbox\" data-question=\"2\" data-correct=\"true\"> You need to query historical states (\"What was the balance on March 1st?\")</label><br>\n      <label><input type=\"checkbox\" data-question=\"2\" data-correct=\"true\"> Complex business rules change frequently and you need to replay scenarios</label><br>\n      <label><input type=\"checkbox\" data-question=\"2\" data-correct=\"false\"> Real-time integration between services is the primary goal</label>\n    </div>\n  </div>\n\n  <div class=\"quiz-question\" style=\"background: #f8f9fa; padding: 20px; margin: 15px 0; border-radius: 10px; border-left: 4px solid #ffc107;\">\n    <h4>Question 3: CQRS and Event Handling (Lesson 3)</h4>\n    <p><strong>What are the key benefits of implementing CQRS in event-driven systems?</strong></p>\n    <div class=\"quiz-options\">\n      <label><input type=\"checkbox\" data-question=\"3\" data-correct=\"true\"> Read and write operations can be scaled independently</label><br>\n      <label><input type=\"checkbox\" data-question=\"3\" data-correct=\"true\"> Multiple optimized read models can be created from the same events</label><br>\n      <label><input type=\"checkbox\" data-question=\"3\" data-correct=\"false\"> Strong consistency is guaranteed across all read models</label><br>\n      <label><input type=\"checkbox\" data-question=\"3\" data-correct=\"true\"> Read models can be rebuilt from events if corrupted</label><br>\n      <label><input type=\"checkbox\" data-question=\"3\" data-correct=\"true\"> Query performance improves with pre-computed read models</label>\n    </div>\n  </div>\n\n  <div class=\"quiz-question\" style=\"background: #f8f9fa; padding: 20px; margin: 15px 0; border-radius: 10px; border-left: 4px solid #dc3545;\">\n    <h4>Question 4: Event Ordering and Processing (Lesson 3)</h4>\n    <p><strong>Which strategies help ensure proper event ordering and exactly-once processing?</strong></p>\n    <div class=\"quiz-options\">\n      <label><input type=\"checkbox\" data-question=\"4\" data-correct=\"true\"> Partition events by entity ID to maintain order for related events</label><br>\n      <label><input type=\"checkbox\" data-question=\"4\" data-correct=\"true\"> Make event processing idempotent with deduplication logic</label><br>\n      <label><input type=\"checkbox\" data-question=\"4\" data-correct=\"false\"> Always use exactly-once delivery guarantees for all event types</label><br>\n      <label><input type=\"checkbox\" data-question=\"4\" data-correct=\"true\"> Include sequence numbers or vector clocks in events</label><br>\n      <label><input type=\"checkbox\" data-question=\"4\" data-correct=\"true\"> Design systems to be tolerant of out-of-order event arrival</label>\n    </div>\n  </div>\n\n  <div class=\"quiz-question\" style=\"background: #f8f9fa; padding: 20px; margin: 15px 0; border-radius: 10px; border-left: 4px solid #6f42c1;\">\n    <h4>Question 5: Saga Patterns (Lesson 4)</h4>\n    <p><strong>When should you choose choreography-based sagas over orchestration-based sagas?</strong></p>\n    <div class=\"quiz-options\">\n      <label><input type=\"checkbox\" data-question=\"5\" data-correct=\"true\"> You want loose coupling between services</label><br>\n      <label><input type=\"checkbox\" data-question=\"5\" data-correct=\"false\"> You need centralized monitoring and easy debugging</label><br>\n      <label><input type=\"checkbox\" data-question=\"5\" data-correct=\"true\"> High availability is more important than centralized control</label><br>\n      <label><input type=\"checkbox\" data-question=\"5\" data-correct=\"true\"> You expect to frequently add new participants to the saga</label><br>\n      <label><input type=\"checkbox\" data-question=\"5\" data-correct=\"false\"> Complex business rules need to be managed in one location</label>\n    </div>\n  </div>\n\n  <div class=\"quiz-question\" style=\"background: #f8f9fa; padding: 20px; margin: 15px 0; border-radius: 10px; border-left: 4px solid #20c997;\">\n    <h4>Question 6: Compensation Strategies (Lesson 4)</h4>\n    <p><strong>What are the characteristics of effective compensation actions in saga patterns?</strong></p>\n    <div class=\"quiz-options\">\n      <label><input type=\"checkbox\" data-question=\"6\" data-correct=\"true\"> Compensations must be idempotent and safe to retry</label><br>\n      <label><input type=\"checkbox\" data-question=\"6\" data-correct=\"true\"> Every saga step should have a corresponding compensation action</label><br>\n      <label><input type=\"checkbox\" data-question=\"6\" data-correct=\"false\"> Compensations must perfectly undo all effects of the original operation</label><br>\n      <label><input type=\"checkbox\" data-question=\"6\" data-correct=\"true\"> Business compensations (like refunds) are acceptable alternatives to perfect rollbacks</label><br>\n      <label><input type=\"checkbox\" data-question=\"6\" data-correct=\"true\"> Compensations should eventually succeed, even if they require manual intervention</label>\n    </div>\n  </div>\n\n  <div class=\"quiz-question\" style=\"background: #f8f9fa; padding: 20px; margin: 15px 0; border-radius: 10px; border-left: 4px solid #fd7e14;\">\n    <h4>Question 7: Real-World Implementation Lessons (Lesson 5)</h4>\n    <p><strong>What key lessons did companies learn from implementing EDA at scale?</strong></p>\n    <div class=\"quiz-options\">\n      <label><input type=\"checkbox\" data-question=\"7\" data-correct=\"true\"> Netflix: Separate event streams by SLA requirements (real-time vs batch)</label><br>\n      <label><input type=\"checkbox\" data-question=\"7\" data-correct=\"true\"> Uber: Geographic partitioning helps reduce cross-region event traffic</label><br>\n      <label><input type=\"checkbox\" data-question=\"7\" data-correct=\"true\"> LinkedIn: Smart fan-out strategies prevent celebrity user events from overwhelming the system</label><br>\n      <label><input type=\"checkbox\" data-question=\"7\" data-correct=\"false\"> All events should be processed with the same consistency and latency requirements</label><br>\n      <label><input type=\"checkbox\" data-question=\"7\" data-correct=\"true\"> Circuit breakers and backpressure handling are essential for system stability</label>\n    </div>\n  </div>\n\n  <div class=\"quiz-question\" style=\"background: #f8f9fa; padding: 20px; margin: 15px 0; border-radius: 10px; border-left: 4px solid #e83e8c;\">\n    <h4>Question 8: Production Operations (Lesson 5)</h4>\n    <p><strong>What are the key operational considerations for production event-driven systems?</strong></p>\n    <div class=\"quiz-options\">\n      <label><input type=\"checkbox\" data-question=\"8\" data-correct=\"true\"> Monitor consumer lag to detect processing bottlenecks</label><br>\n      <label><input type=\"checkbox\" data-question=\"8\" data-correct=\"true\"> Implement dead letter queues for failed event processing</label><br>\n      <label><input type=\"checkbox\" data-question=\"8\" data-correct=\"true\"> Use correlation IDs for end-to-end tracing across services</label><br>\n      <label><input type=\"checkbox\" data-question=\"8\" data-correct=\"false\"> Always process events in strict chronological order regardless of performance impact</label><br>\n      <label><input type=\"checkbox\" data-question=\"8\" data-correct=\"true\"> Build event replay capabilities for debugging and recovery scenarios</label>\n    </div>\n  </div>\n\n  <div style=\"text-align: center; margin: 30px 0;\">\n    <button id=\"revealBtn\" onclick=\"revealAnswers()\" style=\"background: #007bff; color: white; padding: 15px 30px; border: none; border-radius: 5px; font-size: 16px; cursor: pointer; box-shadow: 0 2px 4px rgba(0,0,0,0.1);\">üéØ Reveal Answers & Show Score</button>\n  </div>\n\n  <div id=\"results\" style=\"display: none; background: #e8f5e8; padding: 20px; border-radius: 10px; margin: 20px 0;\">\n    <h3>üìä Your Results</h3>\n    <div id=\"score-display\"></div>\n    <div id=\"feedback\"></div>\n    <br>\n    <button onclick=\"retakeQuiz()\" style=\"background: #28a745; color: white; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer;\">üîÑ Retake Quiz</button>\n  </div>\n</div>\n\n<script>\nfunction revealAnswers() {\n  const questions = document.querySelectorAll('.quiz-question');\n  let totalQuestions = questions.length;\n  let correctAnswers = 0;\n  let totalPossiblePoints = 0;\n  let earnedPoints = 0;\n  \n  questions.forEach((question, qIndex) => {\n    const questionNum = qIndex + 1;\n    const checkboxes = question.querySelectorAll('input[type=\"checkbox\"]');\n    let correctCount = 0;\n    let selectedCorrect = 0;\n    let selectedIncorrect = 0;\n    \n    checkboxes.forEach(checkbox => {\n      const isCorrect = checkbox.getAttribute('data-correct') === 'true';\n      const isSelected = checkbox.checked;\n      \n      if (isCorrect) {\n        correctCount++;\n        totalPossiblePoints++;\n        if (isSelected) {\n          selectedCorrect++;\n          earnedPoints++;\n          checkbox.parentElement.style.background = '#d4edda';\n          checkbox.parentElement.style.border = '1px solid #c3e6cb';\n          checkbox.parentElement.style.color = '#155724';\n        } else {\n          checkbox.parentElement.style.background = '#fff3cd';\n          checkbox.parentElement.style.border = '1px solid #ffeaa7';\n          checkbox.parentElement.style.color = '#856404';\n        }\n      } else {\n        if (isSelected) {\n          selectedIncorrect++;\n          checkbox.parentElement.style.background = '#f8d7da';\n          checkbox.parentElement.style.border = '1px solid #f5c6cb';\n          checkbox.parentElement.style.color = '#721c24';\n        }\n      }\n      \n      checkbox.disabled = true;\n    });\n    \n    if (selectedCorrect === correctCount && selectedIncorrect === 0) {\n      correctAnswers++;\n    }\n  });\n  \n  const scorePercentage = Math.round((earnedPoints / totalPossiblePoints) * 100);\n  const questionPercentage = Math.round((correctAnswers / totalQuestions) * 100);\n  \n  document.getElementById('score-display').innerHTML = `\n    <h4>Your Score: ${earnedPoints}/${totalPossiblePoints} points (${scorePercentage}%)</h4>\n    <p>Perfect Questions: ${correctAnswers}/${totalQuestions} (${questionPercentage}%)</p>\n  `;\n  \n  let feedback = '';\n  if (scorePercentage >= 90) {\n    feedback = '<p><strong>üéâ Excellent!</strong> You have mastered Event-Driven Architecture concepts. You\\'re ready to design and implement production-ready EDA systems.</p>';\n  } else if (scorePercentage >= 75) {\n    feedback = '<p><strong>üëç Good work!</strong> You have a solid understanding of EDA. Review the areas where you missed points and you\\'ll be ready for production implementations.</p>';\n  } else if (scorePercentage >= 60) {\n    feedback = '<p><strong>üìö Keep studying!</strong> You understand the basics but need more practice with advanced concepts like sagas and production operations.</p>\n</div>"
    }
  ]
}