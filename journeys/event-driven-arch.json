{
  "id": "event-driven-architecture",
 "title": "Event driven architecture",
    "totalLessons": 6,
    "available": true,
    "lessons": [
      {
        "id": 1,
        "title": "Why Event-Driven Architecture Transforms System Design",
        "goals": [
          "Understand the fundamental problems that event-driven architecture solves",
          "Compare synchronous vs asynchronous communication patterns",
          "Identify when event-driven patterns provide significant advantages over request-response"
        ],
        "content": "<div class=\"concept-section\">\n  <h3>The Communication Revolution in Distributed Systems</h3>\n  <p>Imagine a busy restaurant where every order requires the waiter to personally walk to the kitchen, wait for the chef to finish cooking, and then return to serve the customer. This is how traditional request-response systems work—everything is synchronous and tightly coupled. Now imagine the same restaurant with a ticket system: orders go to a queue, chefs pick them up when ready, and food appears at the pass when done. This is <strong>event-driven architecture</strong>.</p>\n  <p>Event-driven architecture (EDA) is a design pattern where components communicate by producing and consuming events rather than making direct calls to each other. An event represents something that happened in your system—\"User Registered\", \"Order Placed\", \"Payment Processed\".</p>\n</div>\n<div class=\"concept-section\">\n  <h3>The Problems EDA Solves</h3>\n  <ul>\n    <li><strong>Tight coupling:</strong> Services don't need to know about each other's existence or location</li>\n    <li><strong>Cascading failures:</strong> One service failure doesn't immediately break dependent services</li>\n    <li><strong>Scalability bottlenecks:</strong> Services can process events at their own pace</li>\n    <li><strong>Business process complexity:</strong> Multi-step workflows become manageable sequences of events</li>\n    <li><strong>Real-time requirements:</strong> Systems can react immediately to important business events</li>\n  </ul>\n</div>\n<div class=\"concept-section\">\n  <h3>Synchronous vs Asynchronous Communication</h3>\n  <div style=\"display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;\">\n    <div style=\"background: #fff3e0; padding: 20px; border-radius: 10px;\">\n      <h4>Synchronous (Request-Response)</h4>\n      <ul>\n        <li>✅ <strong>Immediate consistency:</strong> Know result right away</li>\n        <li>✅ <strong>Simple debugging:</strong> Clear call stack traces</li>\n        <li>✅ <strong>Transactional guarantees:</strong> ACID properties preserved</li>\n        <li>❌ <strong>Tight coupling:</strong> Services must be available simultaneously</li>\n        <li>❌ <strong>Cascading failures:</strong> One slow service affects everyone</li>\n        <li>❌ <strong>Scale limitations:</strong> Limited by slowest dependency</li>\n      </ul>\n    </div>\n    <div style=\"background: #e8f5e8; padding: 20px; border-radius: 10px;\">\n      <h4>Asynchronous (Event-Driven)</h4>\n      <ul>\n        <li>✅ <strong>Loose coupling:</strong> Services operate independently</li>\n        <li>✅ <strong>Resilient to failures:</strong> Events can be retried later</li>\n        <li>✅ <strong>Scalable:</strong> Each service scales at its own rate</li>\n        <li>❌ <strong>Eventual consistency:</strong> Results available \"eventually\"</li>\n        <li>❌ <strong>Complex debugging:</strong> Events flow through multiple services</li>\n        <li>❌ <strong>Message delivery concerns:</strong> Must handle duplicates, ordering</li>\n      </ul>\n    </div>\n  </div>\n</div>\n<div class=\"concept-section\">\n  <h3>When EDA Shines: Perfect Use Cases</h3>\n  <ul>\n    <li><strong>E-commerce order processing:</strong> Order → Payment → Inventory → Shipping → Notification</li>\n    <li><strong>User registration flows:</strong> Signup → Email verification → Account setup → Welcome campaign</li>\n    <li><strong>Financial transactions:</strong> Transfer → Fraud check → Settlement → Reporting → Compliance</li>\n    <li><strong>IoT data processing:</strong> Sensor reading → Validation → Storage → Analytics → Alerting</li>\n    <li><strong>Content management:</strong> Upload → Processing → Thumbnail generation → CDN distribution</li>\n  </ul>\n</div>\n<div class=\"concept-section\">\n  <h3>Warning Signs You Need Event-Driven Architecture</h3>\n  <ul>\n    <li>Services frequently timeout waiting for dependencies during peak traffic</li>\n    <li>Adding a new feature requires changes across multiple services</li>\n    <li>One slow service regularly brings down your entire user experience</li>\n    <li>You're implementing complex retry and circuit breaker patterns everywhere</li>\n    <li>Business processes involve long-running workflows with multiple approval steps</li>\n  </ul>\n</div>\n<div class=\"concept-section\">\n  <h3>The Architectural Shift</h3>\n  <p>EDA represents a fundamental shift from <strong>\"tell other services what to do\"</strong> to <strong>\"announce what happened and let services decide how to react\"</strong>. This shift enables:</p>\n  <ul>\n    <li>Services to evolve independently without breaking others</li>\n    <li>New features to be added by simply listening to existing events</li>\n    <li>Better fault tolerance through event replay and retry mechanisms</li>\n    <li>Improved observability through event logs and audit trails</li>\n  </ul>\n</div>\n<div class=\"exercise\">\n  <h3>🛠️ Identify EDA Opportunities</h3>\n  <p><strong>Scenario:</strong> You're building a social media platform with these current synchronous flows:</p>\n  <ol>\n    <li><strong>Post creation:</strong> User posts → Validate content → Store post → Update feeds → Send notifications → Update analytics</li>\n    <li><strong>User follow:</strong> User follows another → Update relationship → Rebuild feed → Send notification → Update recommendation engine</li>\n    <li><strong>Content moderation:</strong> Post reported → ML analysis → Human review → Take action → Notify users → Update metrics</li>\n  </ol>\n  <p><strong>Your task:</strong> For each flow, identify:</p>\n  <ul>\n    <li>Which steps could benefit from asynchronous processing</li>\n    <li>What events you would emit at each stage</li>\n    <li>Which failures are acceptable to handle \"eventually\" vs immediately</li>\n  </ul>\n  <p><strong>Consider:</strong> What happens if the notification service is down during peak posting hours? How would EDA help?</p>\n</div>"
      },
      {
        "id": 2,
        "title": "Event Sourcing vs Event Streaming: Two Powerful Patterns",
        "goals": [
          "Understand the difference between event sourcing and event streaming patterns",
          "Learn when to use event stores vs message brokers like Kafka",
          "Master the concept of events as the single source of truth"
        ],
        "content": "<div class=\"concept-section\">\n  <h3>Two Approaches to Event-Driven Design</h3>\n  <p>When people talk about \"event-driven architecture,\" they often mean one of two distinct patterns that serve different purposes. Think of event sourcing as keeping a detailed diary of everything that happened (\"I deposited $100 at 2pm\"), while event streaming is like a live news feed where services subscribe to categories they care about (\"Subscribe to all payment events\").</p>\n</div>\n<div class=\"concept-section\">\n  <h3>Event Sourcing: Events as Source of Truth</h3>\n  <p>Event sourcing stores every state change as an immutable event, then rebuilds current state by replaying these events. Instead of updating a user record directly, you store \"UserRegistered\", \"EmailChanged\", \"AccountSuspended\" events.</p>\n  <ul>\n    <li>✅ <strong>Complete audit trail:</strong> Know exactly what happened and when</li>\n    <li>✅ <strong>Time travel:</strong> Recreate system state at any point in history</li>\n    <li>✅ <strong>Bug recovery:</strong> Fix bugs by replaying events with corrected logic</li>\n    <li>✅ <strong>Natural event publishing:</strong> Events are already stored, easy to publish</li>\n    <li>❌ <strong>Query complexity:</strong> Need to rebuild state for every read</li>\n    <li>❌ <strong>Storage growth:</strong> Events accumulate over time</li>\n    <li>❌ <strong>Eventual consistency:</strong> Projections may lag behind events</li>\n  </ul>\n  <p><strong>Perfect for:</strong> Financial systems, compliance-heavy applications, systems needing detailed audit trails</p>\n</div>\n<div class=\"concept-section\">\n  <h3>Event Streaming: Real-Time Event Distribution</h3>\n  <p>Event streaming focuses on distributing events between services in real-time. Services publish events to streams (topics), and other services subscribe to react to those events.</p>\n  <ul>\n    <li>✅ <strong>Real-time processing:</strong> React to events as they happen</li>\n    <li>✅ <strong>Scalable distribution:</strong> Many consumers can process the same event stream</li>\n    <li>✅ <strong>Service decoupling:</strong> Publishers don't know about subscribers</li>\n    <li>✅ <strong>Fault tolerance:</strong> Events can be replayed if processing fails</li>\n    <li>❌ <strong>Message broker dependency:</strong> Adds infrastructure complexity</li>\n    <li>❌ <strong>Ordering challenges:</strong> Maintaining event order across partitions</li>\n    <li>❌ <strong>Schema evolution:</strong> Event format changes affect all consumers</li>\n  </ul>\n  <p><strong>Perfect for:</strong> Microservices communication, real-time analytics, IoT data processing</p>\n</div>\n<div class=\"concept-section\">\n  <h3>Event Store vs Message Broker Architecture</h3>\n  <div style=\"display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;\">\n    <div style=\"background: #e3f2fd; padding: 20px; border-radius: 10px;\">\n      <h4>Event Store (Event Sourcing)</h4>\n      <ul>\n        <li>Events stored permanently as database records</li>\n        <li>Optimized for append-only writes and historical queries</li>\n        <li>Examples: EventStore, PostgreSQL with custom tables</li>\n        <li>State rebuilt by replaying events from beginning</li>\n      </ul>\n    </div>\n    <div style=\"background: #f3e5f5; padding: 20px; border-radius: 10px;\">\n      <h4>Message Broker (Event Streaming)</h4>\n      <ul>\n        <li>Events flow through topics with configurable retention</li>\n        <li>Optimized for high-throughput publish/subscribe</li>\n        <li>Examples: Kafka, RabbitMQ, AWS SQS/SNS</li>\n        <li>Consumers process events from current position forward</li>\n      </ul>\n    </div>\n  </div>\n</div>\n<div class=\"concept-section\">\n  <h3>Hybrid Approach: Best of Both Worlds</h3>\n  <p>Many systems combine both patterns:</p>\n  <ol>\n    <li><strong>Event sourcing</strong> for critical business entities that need audit trails</li>\n    <li><strong>Event streaming</strong> to distribute those events to other services</li>\n    <li><strong>CQRS projections</strong> to create optimized read models</li>\n  </ol>\n  <div style=\"background: #f8f9fa; padding: 10px; font-family: monospace; margin: 10px 0;\">\n    Business Logic → Event Store → Event Stream → Multiple Consumers<br>\n    (Commands)      (Audit Trail)  (Real-time)    (Projections)\n  </div>\n</div>\n<div class=\"concept-section\">\n  <h3>Event Design Principles</h3>\n  <ul>\n    <li><strong>Events describe what happened, not what should happen:</strong> \"OrderPlaced\" not \"SendConfirmationEmail\"</li>\n    <li><strong>Include sufficient context:</strong> Event should contain all data consumers need</li>\n    <li><strong>Use past tense naming:</strong> Events represent completed actions</li>\n    <li><strong>Make events immutable:</strong> Never change an event once published</li>\n    <li><strong>Version your events:</strong> Plan for schema evolution from day one</li>\n  </ul>\n</div>\n<div class=\"concept-section\">\n  <h3>Technology Choices</h3>\n  <ul>\n    <li><strong>Event Sourcing:</strong> EventStore, Axon Framework, Akka Persistence, custom PostgreSQL</li>\n    <li><strong>Event Streaming:</strong> Apache Kafka, AWS Kinesis, Azure Event Hubs, Google Pub/Sub</li>\n    <li><strong>Lightweight options:</strong> RabbitMQ, AWS SQS/SNS for simpler use cases</li>\n  </ul>\n</div>\n<div class=\"exercise\">\n  <h3>🛠️ Choose Your Event Pattern</h3>\n  <p><strong>Scenario:</strong> You're designing three different systems:</p>\n  <ol>\n    <li><strong>Banking system:</strong> Account transactions, transfers, interest calculations. Regulatory compliance requires full audit trails.</li>\n    <li><strong>E-commerce platform:</strong> Inventory updates, order processing, recommendation engine updates. Need real-time coordination between 15+ microservices.</li>\n    <li><strong>Social media analytics:</strong> User interactions, content engagement, trending topics. Process millions of events per hour for real-time dashboards.</li>\n  </ol>\n  <p><strong>Your task:</strong> For each system, decide:</p>\n  <ul>\n    <li>Would you use event sourcing, event streaming, or both?</li>\n    <li>What technology stack would you choose?</li>\n    <li>Design 3-4 key events for each system with proper naming</li>\n    <li>Identify which events need permanent storage vs temporary streaming</li>\n  </ul>\n  <p><strong>Consider:</strong> How would your choices change if the banking system needed to handle 100K transactions/second?</p>\n</div>"
      },
      {
        "id": 3,
        "title": "CQRS: Separating Reads and Writes in Event-Driven Systems", 
        "goals": [
          "Understand Command Query Responsibility Segregation and its relationship to event-driven architecture",
          "Learn how to design separate command and query models for optimal performance",
          "Master the patterns for keeping read models synchronized with event streams"
        ],
        "content": "<div class=\"concept-section\">\n  <h3>The Read/Write Separation Revolution</h3>\n  <p>Imagine a library where the same person who's responsible for carefully cataloging and shelving new books (writes) also has to help people find books quickly (reads). During busy periods, either new books pile up uncataloged, or people wait forever to find what they need. CQRS (Command Query Responsibility Segregation) is like having specialized librarians: one team focuses on organizing new books, while another team maintains optimized catalogs for different types of searches.</p>\n  <p>CQRS separates the responsibility of handling commands (write operations) from queries (read operations), allowing each to be optimized for its specific purpose.</p>\n</div>\n<div class=\"concept-section\">\n  <h3>Why Traditional CRUD Breaks Down</h3>\n  <ul>\n    <li><strong>Conflicting optimization needs:</strong> Writes need consistency and validation; reads need speed and complex queries</li>\n    <li><strong>Schema compromises:</strong> Normalized schemas great for consistency, terrible for complex reporting</li>\n    <li><strong>Scalability bottlenecks:</strong> Read-heavy applications struggle with write-optimized databases</li>\n    <li><strong>Business complexity:</strong> Real business processes don't map cleanly to CRUD operations</li>\n  </ul>\n</div>\n<div class=\"concept-section\">\n  <h3>CQRS Core Components</h3>\n  <div style=\"display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;\">\n    <div style=\"background: #fff3e0; padding: 20px; border-radius: 10px;\">\n      <h4>Command Side (Writes)</h4>\n      <ul>\n        <li><strong>Commands:</strong> Intent to change state (\"PlaceOrder\", \"UpdateProfile\")</li>\n        <li><strong>Command Handlers:</strong> Business logic and validation</li>\n        <li><strong>Write Model:</strong> Optimized for consistency and business rules</li>\n        <li><strong>Events:</strong> What actually happened after command processing</li>\n      </ul>\n    </div>\n    <div style=\"background: #e8f5e8; padding: 20px; border-radius: 10px;\">\n      <h4>Query Side (Reads)</h4>\n      <ul>\n        <li><strong>Query Handlers:</strong> Retrieve data without business logic</li>\n        <li><strong>Read Models:</strong> Denormalized views optimized for specific queries</li>\n        <li><strong>Projections:</strong> Event handlers that maintain read models</li>\n        <li><strong>Multiple Views:</strong> Different optimized representations of the same data</li>\n      </ul>\n    </div>\n  </div>\n</div>\n<div class=\"concept-section\">\n  <h3>CQRS + Event Sourcing: The Perfect Partnership</h3>\n  <p>CQRS works beautifully with event sourcing because events become the bridge between command and query sides:</p>\n  <ol>\n    <li><strong>Command processed</strong> → Generates events → Stored in event store</li>\n    <li><strong>Events published</strong> → Consumed by projection handlers</li>\n    <li><strong>Read models updated</strong> → Optimized for specific query patterns</li>\n    <li><strong>Queries served</strong> → From fast, denormalized read models</li>\n  </ol>\n</div>\n<div class=\"concept-section\">\n  <h3>Read Model Patterns</h3>\n  <ul>\n    <li><strong>List projections:</strong> Product catalogs, user directories, order histories</li>\n    <li><strong>Aggregate projections:</strong> Dashboard summaries, reporting totals, analytics</li>\n    <li><strong>Search projections:</strong> Full-text search indexes, faceted search data</li>\n    <li><strong>Cached projections:</strong> Frequently accessed complex calculations</li>\n    <li><strong>Materialized views:</strong> Complex joins materialized for fast access</li>\n  </ul>\n</div>\n<div class=\"concept-section\">\n  <h3>Synchronization Strategies</h3>\n  <div style=\"background: #f8f9fa; padding: 10px; font-family: monospace; margin: 10px 0;\">\n    // Immediate projection update<br>\n    onEvent(\"OrderPlaced\") {<br>\n    &nbsp;&nbsp;updateOrderListProjection(event);<br>\n    &nbsp;&nbsp;updateCustomerOrderHistoryProjection(event);<br>\n    &nbsp;&nbsp;updateSalesAnalyticsProjection(event);<br>\n    }\n  </div>\n  <ul>\n    <li><strong>Synchronous projections:</strong> Update read models immediately when events are published</li>\n    <li><strong>Asynchronous projections:</strong> Process events in background for eventual consistency</li>\n    <li><strong>Batch projections:</strong> Update read models in scheduled batches for analytics</li>\n    <li><strong>On-demand projections:</strong> Build read models when first queried</li>\n  </ul>\n</div>\n<div class=\"concept-section\">\n  <h3>CQRS Implementation Patterns</h3>\n  <div style=\"display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;\">\n    <div style=\"background: #e3f2fd; padding: 20px; border-radius: 10px;\">\n      <h4>Simple CQRS</h4>\n      <ul>\n        <li>Same database, different models for reads and writes</li>\n        <li>Separate command and query handlers</li>\n        <li>✅ Easier to start with</li>\n        <li>❌ Limited scalability benefits</li>\n      </ul>\n    </div>\n    <div style=\"background: #f3e5f5; padding: 20px; border-radius: 10px;\">\n      <h4>Full CQRS</h4>\n      <ul>\n        <li>Separate databases for reads and writes</li>\n        <li>Event-driven synchronization</li>\n        <li>✅ Maximum scalability and flexibility</li>\n        <li>❌ Higher complexity and eventual consistency</li>\n      </ul>\n    </div>\n  </div>\n</div>\n<div class=\"concept-section\">\n  <h3>Common CQRS Pitfalls</h3>\n  <div style=\"background: #ffebee; padding: 20px; border-radius: 10px; margin: 20px 0;\">\n    <h4>⚠️ Avoid These Mistakes</h4>\n    <ul>\n      <li><strong>Over-engineering simple CRUD:</strong> Don't use CQRS for basic entity management</li>\n      <li><strong>Ignoring eventual consistency:</strong> UI must handle cases where read models are stale</li>\n      <li><strong>Complex query logic in projections:</strong> Keep projections simple, push complexity to query handlers</li>\n      <li><strong>Not versioning read models:</strong> Schema changes become deployment nightmares</li>\n      <li><strong>Single massive read model:</strong> Create focused projections for specific use cases</li>\n    </ul>\n  </div>\n</div>\n<div class=\"exercise\">\n  <h3>🛠️ Design a CQRS System</h3>\n  <p><strong>Scenario:</strong> You're building an e-commerce order management system with these requirements:</p>\n  <ul>\n    <li><strong>Commands:</strong> Place order, cancel order, update shipping address, process payment</li>\n    <li><strong>Queries:</strong> Customer order history, admin order dashboard, inventory reports, sales analytics</li>\n    <li><strong>Scale:</strong> 10K orders/day, 1M customers, complex reporting requirements</li>\n  </ul>\n  <p><strong>Your task:</strong> Design the CQRS implementation including:</p>\n  <ol>\n    <li><strong>Command model:</strong> What entities and business rules belong on the command side?</li>\n    <li><strong>Events:</strong> List the key events your system will generate</li>\n    <li><strong>Read models:</strong> Design 3 different projections for different query patterns</li>\n    <li><strong>Synchronization:</strong> Which projections need real-time updates vs eventual consistency?</li>\n  </ol>\n  <p><strong>Consider:</strong> How would you handle a customer wanting to see their order status immediately after placing it? What if the projection is temporarily behind?</p>\n  <p><em>Bonus: Design the database schema for one of your read models and explain why you chose that structure.</em></p>\n</div>"
      },
      {
        "id": 4,
        "title": "Saga Patterns: Managing Distributed Transactions with Events",
        "goals": [
          "Master the saga pattern for managing long-running distributed transactions",
          "Compare choreography-based vs orchestration-based saga implementations", 
          "Learn compensation strategies for handling failures in distributed workflows"
        ],
        "content": "<div class=\"concept-section\">\n  <h3>When Distributed Transactions Get Complex</h3>\n  <p>Imagine booking a vacation: you need to reserve flights, book hotels, rent a car, and arrange pet care. If any step fails after you've already booked others, you need to cancel everything you've already reserved. In traditional systems, you'd use a database transaction to make it \"all or nothing.\" But in distributed systems with multiple services, database transactions don't work across service boundaries.</p>\n  <p>The <strong>Saga pattern</strong> solves this by breaking large transactions into a sequence of smaller, local transactions, each with a compensating action that can undo its work if needed.</p>\n</div>\n<div class=\"concept-section\">\n  <h3>Why Traditional 2PC Doesn't Scale</h3>\n  <ul>\n    <li><strong>Blocking protocol:</strong> All services must wait for the slowest participant</li>\n    <li><strong>Single point of failure:</strong> Transaction coordinator failure blocks everything</li>\n    <li><strong>Resource locking:</strong> Resources locked for the entire transaction duration</li>\n    <li><strong>Network partition sensitivity:</strong> Network issues can cause indefinite blocking</li>\n    <li><strong>Performance degradation:</strong> Throughput decreases as participants increase</li>\n  </ul>\n</div>\n<div class=\"concept-section\">\n  <h3>Saga Pattern Fundamentals</h3>\n  <p>A saga is a sequence of local transactions where each transaction has a corresponding compensating transaction that can undo its effects:</p>\n  <ul>\n    <li><strong>Forward recovery:</strong> Continue the saga by retrying failed steps</li>\n    <li><strong>Backward recovery:</strong> Undo completed steps by executing compensating actions</li>\n    <li><strong>Semantic atomicity:</strong> Business-level consistency rather than technical ACID</li>\n    <li><strong>Eventual consistency:</strong> System reaches consistent state eventually</li>\n  </ul>\n</div>\n<div class=\"concept-section\">\n  <h3>Choreography-Based Sagas: Dance Without a Conductor</h3>\n  <p>In choreography, each service knows what to do when it receives specific events. No central coordinator—services react to events and publish their own events.</p>\n  <div style=\"background: #f8f9fa; padding: 10px; font-family: monospace; margin: 10px 0;\">\n    OrderService: OrderCreated → PaymentService: PaymentRequested<br>\n    PaymentService: PaymentSucceeded → InventoryService: ReserveItems<br>\n    InventoryService: ItemsReserved → ShippingService: CreateShipment<br>\n    ShippingService: ShipmentCreated → OrderService: OrderConfirmed\n  </div>\n  <ul>\n    <li>✅ <strong>No single point of failure:</strong> Distributed responsibility</li>\n    <li>✅ <strong>Loose coupling:</strong> Services only know about events, not other services</li>\n    <li>✅ <strong>High performance:</strong> No central bottleneck</li>\n    <li>❌ <strong>Complex monitoring:</strong> Hard to track saga progress</li>\n    <li>❌ <strong>Debugging challenges:</strong> Flow spans multiple services</li>\n    <li>❌ <strong>Circular dependencies:</strong> Services can create complex event cycles</li>\n  </ul>\n</div>\n<div class=\"concept-section\">\n  <h3>Orchestration-Based Sagas: Central Command</h3>\n  <p>An orchestrator service controls the saga execution, making decisions about which steps to execute next and handling compensations.</p>\n  <div style=\"background: #f8f9fa; padding: 10px; font-family: monospace; margin: 10px 0;\">\n    OrderSaga: CreateOrder → PaymentService: ProcessPayment<br>\n    OrderSaga: (payment success) → InventoryService: ReserveItems<br>\n    OrderSaga: (inventory success) → ShippingService: CreateShipment<br>\n    OrderSaga: (shipping success) → Complete saga\n  </div>\n  <ul>\n    <li>✅ <strong>Centralized logic:</strong> Business process clearly defined in one place</li>\n    <li>✅ <strong>Easy monitoring:</strong> Saga state tracked in orchestrator</li>\n    <li>✅ <strong>Complex flows:</strong> Handle conditional logic, loops, parallel steps</li>\n    <li>❌ <strong>Single point of failure:</strong> Orchestrator must be highly available</li>\n    <li>❌ <strong>Tight coupling:</strong> Orchestrator knows about all participating services</li>\n    <li>❌ <strong>Performance bottleneck:</strong> All decisions flow through orchestrator</li>\n  </ul>\n</div>\n<div class=\"concept-section\">\n  <h3>Compensation Strategies</h3>\n  <div style=\"display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;\">\n    <div style=\"background: #e8f5e8; padding: 20px; border-radius: 10px;\">\n      <h4>Reversible Actions</h4>\n      <ul>\n        <li><strong>Reserve inventory</strong> → Release inventory</li>\n        <li><strong>Hold payment</strong> → Release hold</li>\n        <li><strong>Create booking</strong> → Cancel booking</li>\n        <li>Perfect compensation possible</li>\n      </ul>\n    </div>\n    <div style=\"background: #fff3e0; padding: 20px; border-radius: 10px;\">\n      <h4>Irreversible Actions</h4>\n      <ul>\n        <li><strong>Send email</strong> → Send apology email</li>\n        <li><strong>Charge credit card</strong> → Issue refund</li>\n        <li><strong>Ship product</strong> → Create return label</li>\n        <li>Best-effort compensation</li>\n      </ul>\n    </div>\n  </div>\n</div>\n<div class=\"concept-section\">\n  <h3>Saga Implementation Patterns</h3>\n  <ul>\n    <li><strong>State machine approach:</strong> Model saga as explicit state transitions</li>\n    <li><strong>Event sourcing integration:</strong> Store saga events for audit and replay</li>\n    <li><strong>Timeout handling:</strong> Automatic compensation after timeout periods</li>\n    <li><strong>Retry mechanisms:</strong> Exponential backoff for transient failures</li>\n    <li><strong>Idempotency:</strong> Safe to retry any saga step multiple times</li>\n  </ul>\n</div>\n<div class=\"concept-section\">\n  <h3>When to Choose Each Pattern</h3>\n  <ul>\n    <li><strong>Use Choreography when:</strong> Simple linear workflows, services already well-decoupled, team autonomy is important</li>\n    <li><strong>Use Orchestration when:</strong> Complex business logic, need centralized monitoring, conditional workflows, regulatory compliance requirements</li>\n  </ul>\n</div>\n<div class=\"concept-section\">\n  <h3>Saga Failure Handling</h3>\n  <div style=\"background: #ffebee; padding: 20px; border-radius: 10px; margin: 20px 0;\">\n    <h4>⚠️ Common Failure Scenarios</h4>\n    <ul>\n      <li><strong>Partial failure:</strong> Some steps succeed, others fail—need selective compensation</li>\n      <li><strong>Compensation failure:</strong> What if the undo action also fails?</li>\n      <li><strong>Out-of-order events:</strong> Network delays cause events to arrive in wrong sequence</li>\n      <li><strong>Duplicate events:</strong> Retry mechanisms can cause the same step to execute twice</li>\n    </ul>\n  </div>\n</div>\n<div class=\"exercise\">\n  <h3>🛠️ Design a Saga Implementation</h3>\n  <p><strong>Scenario:</strong> Your travel booking platform needs to implement a \"Book Complete Trip\" saga with these steps:</p>\n  <ol>\n    <li><strong>Reserve flight seats</strong> (can be released if needed)</li>\n    <li><strong>Process payment</strong> (can be refunded, but takes 3-5 days)</li>\n    <li><strong>Book hotel rooms</strong> (cancellation possible until 24h before)</li>\n    <li><strong>Reserve rental car</strong> (free cancellation)</li>\n    <li><strong>Send confirmation email</strong> (irreversible)</li>\n  </ol>\n  <p><strong>Your task:</strong> Design both choreography and orchestration approaches:</p>\n  <ol>\n    <li><strong>Events and compensations:</strong> Define the success/failure events and compensation actions</li>\n    <li><strong>Failure scenarios:</strong> What happens if payment succeeds but hotel booking fails?</li>\n    <li><strong>Monitoring:</strong> How would you track saga progress in each approach?</li>\n    <li><strong>Choose approach:</strong> Which pattern would you recommend and why?</li>\n  </ol>\n  <p><strong>Consider:</strong> How would you handle a customer who wants to modify their booking while the original saga is still processing?</p>\n</div>"
      },
      {
        "id": 5,
        "title": "Event Ordering, Delivery Guarantees, and Exactly-Once Processing",
        "goals": [
          "Understand the challenges of event ordering in distributed systems",
          "Master different delivery guarantee patterns (at-most-once, at-least-once, exactly-once)",
          "Learn practical strategies for handling duplicate events and out-of-order processing"
        ],
        "content": "<div class=\"concept-section\">\n  <h3>The Ordering Challenge in Distributed Systems</h3>\n  <p>Imagine a bank where deposits and withdrawals from the same account could be processed in any order. A $100 deposit followed by a $50 withdrawal might be processed as withdrawal first, then deposit—potentially causing an overdraft. In distributed event-driven systems, this ordering challenge is fundamental because events can take different paths through the network and arrive out of sequence.</p>\n  <p>Event ordering becomes critical when the sequence of events affects the final outcome of business operations.</p>\n</div>\n<div class=\"concept-section\">\n  <h3>Types of Event Ordering</h3>\n  <ul>\n    <li><strong>Global ordering:</strong> All events across the entire system have a single, consistent order</li>\n    <li><strong>Partial ordering:</strong> Events within specific contexts (like per user or per entity) maintain order</li>\n    <li><strong>Causal ordering:</strong> Events that are causally related maintain their cause-and-effect sequence</li>\n    <li><strong>No ordering:</strong> Events can be processed in any order without affecting correctness</li>\n  </ul>\n</div>\n<div class=\"concept-section\">\n  <h3>Delivery Guarantee Patterns</h3>\n  <div style=\"display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; margin: 20px 0;\">\n    <div style=\"background: #ffebee; padding: 15px; border-radius: 10px;\">\n      <h4>At-Most-Once</h4>\n      <ul>\n        <li>Events delivered zero or one time</li>\n        <li>✅ No duplicates</li>\n        <li>❌ Possible message loss</li>\n        <li><strong>Use case:</strong> Metrics, logs</li>\n      </ul>\n    </div>\n    <div style=\"background: #fff3e0; padding: 15px; border-radius: 10px;\">\n      <h4>At-Least-Once</h4>\n      <ul>\n        <li>Events delivered one or more times</li>\n        <li>✅ No message loss</li>\n        <li>❌ Possible duplicates</li>\n        <li><strong>Use case:</strong> Most business events</li>\n      </ul>\n    </div>\n    <div style=\"background: #e8f5e8; padding: 15px; border-radius: 10px;\">\n      <h4>Exactly-Once</h4>\n      <ul>\n        <li>Events delivered exactly one time</li>\n        <li>✅ No loss, no duplicates</li>\n        <li>❌ Complex to implement</li>\n        <li><strong>Use case:</strong> Financial transactions</li>\n      </ul>\n    </div>\n  </div>\n</div>\n<div class=\"concept-section\">\n  <h3>Achieving Exactly-Once Processing</h3>\n  <p><strong>True exactly-once is impossible in distributed systems</strong>, but we can achieve exactly-once <em>semantics</em> through:</p>\n  <ul>\n    <li><strong>Idempotent operations:</strong> Safe to execute multiple times</li>\n    <li><strong>Deduplication:</strong> Track processed events to ignore duplicates</li>\n    <li><strong>Transactional outbox:</strong> Combine database writes with event publishing</li>\n    <li><strong>Message IDs:</strong> Unique identifiers to detect duplicates</li>\n  </ul>\n  <div style=\"background: #f8f9fa; padding: 10px; font-family: monospace; margin: 10px 0;\">\n    // Idempotent event handler example<br>\n    handleOrderPlaced(event) {<br>\n    &nbsp;&nbsp;if (processedEvents.contains(event.id)) return; // Skip duplicate<br>\n    &nbsp;&nbsp;<br>\n    &nbsp;&nbsp;// Process event atomically<br>\n    &nbsp;&nbsp;database.transaction(() => {<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;createOrder(event.orderData);<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;markEventProcessed(event.id);<br>\n    &nbsp;&nbsp;});<br>\n    }\n  </div>\n</div>\n<div class=\"concept-section\">\n  <h3>Event Ordering Strategies</h3>\n  <div style=\"display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;\">\n    <div style=\"background: #e3f2fd; padding: 20px; border-radius: 10px;\">\n      <h4>Partition-Based Ordering</h4>\n      <ul>\n        <li>Route related events to same partition/consumer</li>\n        <li>✅ Ordering within entity (user, account)</li>\n        <li>✅ Scalable across partitions</li>\n        <li>❌ No cross-partition ordering</li>\n        <li><strong>Example:</strong> All user events go to same partition</li>\n      </ul>\n    </div>\n    <div style=\"background: #f3e5f5; padding: 20px; border-radius: 10px;\">\n      <h4>Version-Based Ordering</h4>\n      <ul>\n        <li>Include version numbers or timestamps</li>\n        <li>✅ Handle out-of-order delivery</li>\n        <li>✅ Detect missing events</li>\n        <li>❌ Requires buffering and reordering</li>\n        <li><strong>Example:</strong> UserUpdated v1, v2, v3...</li>\n      </ul>\n    </div>\n  </div>\n</div>\n<div class=\"concept-section\">\n  <h3>Handling Out-of-Order Events</h3>\n  <ul>\n    <li><strong>Event buffering:</strong> Hold events until prerequisites arrive</li>\n    <li><strong>Version vectors:</strong> Track causal relationships between events</li>\n    <li><strong>Timestamp-based ordering:</strong> Use logical clocks for event sequencing</li>\n    <li><strong>State reconciliation:</strong> Detect and fix inconsistencies after processing</li>\n  </ul>\n</div>\n<div class=\"concept-section\">\n  <h3>Practical Implementation Patterns</h3>\n  <div style=\"background: #f8f9fa; padding: 10px; font-family: monospace; margin: 10px 0;\">\n    // Transactional Outbox Pattern<br>\n    database.transaction(() => {<br>\n    &nbsp;&nbsp;// Business logic<br>\n    &nbsp;&nbsp;updateAccount(accountId, newBalance);<br>\n    &nbsp;&nbsp;<br>\n    &nbsp;&nbsp;// Store event for publishing<br>\n    &nbsp;&nbsp;outboxTable.insert(new Event(\"AccountUpdated\", data));<br>\n    });<br>\n    <br>\n    // Separate process publishes events<br>\n    outboxPublisher.publishPendingEvents();\n  </div>\n</div>\n<div class=\"concept-section\">\n  <h3>Technology-Specific Guarantees</h3>\n  <ul>\n    <li><strong>Apache Kafka:</strong> At-least-once by default, exactly-once semantics with transactions</li>\n    <li><strong>AWS SQS:</strong> At-least-once delivery, FIFO queues for ordering</li>\n    <li><strong>RabbitMQ:</strong> Configurable delivery guarantees, publisher confirms</li>\n    <li><strong>Azure Service Bus:</strong> At-least-once delivery, sessions for ordering</li>\n  </ul>\n</div>\n<div class=\"concept-section\">\n  <h3>When to Prioritize What</h3>\n  <div style=\"background: #fff3e0; padding: 20px; border-radius: 10px; margin: 20px 0;\">\n    <h4>⚡ Performance vs Consistency Trade-offs</h4>\n    <ul>\n      <li><strong>High-frequency, low-stakes:</strong> At-most-once (analytics, metrics)</li>\n      <li><strong>Business-critical:</strong> At-least-once with idempotent handlers</li>\n      <li><strong>Financial operations:</strong> Exactly-once semantics, strict ordering</li>\n      <li><strong>User experience:</strong> Balance consistency with responsive UI</li>\n    </ul>\n  </div>\n</div>\n<div class=\"exercise\">\n  <h3>🛠️ Design Event Processing Guarantees</h3>\n  <p><strong>Scenario:</strong> Your social media platform handles these event streams:</p>\n  <ol>\n    <li><strong>User actions:</strong> Like, comment, share, follow (1M events/hour)</li>\n    <li><strong>Content updates:</strong> Post creation, editing, deletion (100K events/hour)</li>\n    <li><strong>Billing events:</strong> Subscription changes, payments, refunds (1K events/hour)</li>\n    <li><strong>Analytics events:</strong> Page views, engagement metrics (10M events/hour)</li>\n  </ol>\n  <p><strong>Your task:</strong> For each event type, design:</p>\n  <ul>\n    <li><strong>Delivery guarantee:</strong> Which pattern (at-most/at-least/exactly-once) and why?</li>\n    <li><strong>Ordering requirements:</strong> What ordering constraints are necessary?</li>\n    <li><strong>Duplicate handling:</strong> How will you handle duplicate events?</li>\n    <li><strong>Partition strategy:</strong> How will you ensure ordering where needed?</li>\n  </ul>\n  <p><strong>Consider:</strong> A user rapidly likes and unlikes the same post. How do you ensure the final state is correct regardless of event processing order?</p>\n  <p><em>Bonus: Design the database schema for tracking processed events to enable exactly-once processing.</em></p>\n</div>"
      },
      {
        "id": 6,
        "title": "Real-World Event-Driven Architecture: Case Studies and Best Practices",
        "goals": [
          "Learn from real-world EDA implementations at companies like Netflix, Uber, and Airbnb",
          "Understand the operational challenges and monitoring strategies for event-driven systems",
          "Develop a comprehensive framework for implementing EDA in your own systems"
        ],
        "content": "<div class=\"concept-section\">\n  <h3>Real-World Event-Driven Architecture Implementations</h3>\n  <p>Let's examine how major technology companies have successfully implemented event-driven architectures at massive scale, and the lessons learned from their experiences.</p>\n</div>\n<div class=\"concept-section\">\n  <h3>Netflix: Event-Driven Microservices at Global Scale</h3>\n  <p>Netflix processes billions of events daily across their microservices ecosystem:</p>\n  <ul>\n    <li><strong>Architecture:</strong> 1000+ microservices communicating via events</li>\n    <li><strong>Event streaming:</strong> Apache Kafka with custom tooling (Keystone pipeline)</li>\n    <li><strong>Use cases:</strong> User activity tracking, content recommendations, A/B testing, billing</li>\n    <li><strong>Key insight:</strong> Event schemas are contracts—treat them as APIs with versioning</li>\n    <li><strong>Lesson learned:</strong> Invest heavily in tooling for event discovery and lineage tracking</li>\n  </ul>\n  <p><a href=\"https://netflixtechblog.com/kafka-inside-keystone-pipeline-dd5aeabaf6bb\" target=\"_blank\" rel=\"noopener noreferrer\">Netflix Tech Blog - Kafka at Netflix</a></p>\n</div>\n<div class=\"concept-section\">\n  <h3>Uber: Event Sourcing for Trip Management</h3>\n  <p>Uber uses event sourcing to manage the complex state transitions of trips:</p>\n  <ul>\n    <li><strong>Domain:</strong> Trip lifecycle from request to completion</li>\n    <li><strong>Events:</strong> TripRequested → DriverMatched → TripStarted → TripCompleted</li>\n    <li><strong>Benefits:</strong> Complete audit trail, ability to replay events for debugging</li>\n    <li><strong>Challenge:</strong> Managing schema evolution across thousands of services</li>\n    <li><strong>Solution:</strong> Schema registry with backward/forward compatibility rules</li>\n  </ul>\n</div>\n<div class=\"concept-section\">\n  <h3>Airbnb: Event-Driven Data Platform</h3>\n  <p>Airbnb built their data platform around events to enable real-time analytics:</p>\n  <ul>\n    <li><strong>Architecture:</strong> Change data capture from databases → Kafka → Stream processing</li>\n    <li><strong>Use cases:</strong> Real-time pricing, fraud detection, operational dashboards</li>\n    <li><strong>Innovation:</strong> \"Minerva\" platform for managing event schemas and data quality</li>\n    <li><strong>Lesson learned:</strong> Data quality in event streams requires automated monitoring and validation</li>\n  </ul>\n</div>\n<div class=\"concept-section\">\n  <h3>Common Architecture Patterns Across Companies</h3>\n  <div style=\"display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;\">\n    <div style=\"background: #e8f5e8; padding: 20px; border-radius: 10px;\">\n      <h4>Event Streaming Layer</h4>\n      <ul>\n        <li>Apache Kafka for high-throughput event streaming</li>\n        <li>Schema registry for event contract management</li>\n        <li>Stream processing for real-time transformations</li>\n        <li>Dead letter queues for failed event handling</li>\n      </ul>\n    </div>\n    <div style=\"background: #e3f2fd; padding: 20px; border-radius: 10px;\">\n      <h4>Operational Infrastructure</h4>\n      <ul>\n        <li>Event catalog for discovery and documentation</li>\n        <li>Distributed tracing for cross-service debugging</li>\n        <li>Event replay capabilities for disaster recovery</li>\n        <li>Automated monitoring and alerting</li>\n      </ul>\n    </div>\n  </div>\n</div>\n<div class=\"concept-section\">\n  <h3>Operational Challenges and Solutions</h3>\n  <ul>\n    <li><strong>Event Schema Evolution:</strong> Use schema registry with compatibility rules, version events properly</li>\n    <li><strong>Event Discovery:</strong> Maintain event catalog with business context, not just technical details</li>\n    <li><strong>Debugging Distributed Flows:</strong> Implement correlation IDs and distributed tracing</li>\n    <li><strong>Event Replay:</strong> Design for replay from the beginning—events are immutable facts</li>\n    <li><strong>Monitoring:</strong> Track business metrics (orders processed) not just technical metrics (messages/sec)</li>\n  </ul>\n</div>\n<div class=\"concept-section\">\n  <h3>EDA Monitoring and Observability</h3>\n  <div style=\"background: #f8f9fa; padding: 10px; font-family: monospace; margin: 10px 0;\">\n    // Key metrics to monitor<br>\n    - Event production rate by topic<br>\n    - Consumer lag by consumer group<br>\n    - Event processing latency end-to-end<br>\n    - Failed event processing rate<br>\n    - Schema compatibility violations<br>\n    - Business KPIs derived from events\n  </div>\n</div>\n<div class=\"concept-section\">\n  <h3>Migration Strategies: From Monolith to Event-Driven</h3>\n  <ol>\n    <li><strong>Start with Database Change Data Capture (CDC)</strong> to extract events from existing systems</li>\n    <li><strong>Implement event publishing</strong> in new features while maintaining existing APIs</li>\n    <li><strong>Build event consumers</strong> for cross-cutting concerns (analytics, notifications)</li>\n    <li><strong>Gradually replace synchronous calls</strong> with event-driven interactions</li>\n    <li><strong>Extract bounded contexts</strong> into separate services connected by events</li>\n  </ol>\n</div>\n<div class=\"concept-section\">\n  <h3>Best Practices from the Field</h3>\n  <ul>\n    <li><strong>Event naming:</strong> Use business language, not technical terms (\"OrderPlaced\" not \"OrderTableInserted\")</li>\n    <li><strong>Event size:</strong> Include enough context to avoid additional lookups</li>\n    <li><strong>Backward compatibility:</strong> Add fields, don't change or remove existing ones</li>\n    <li><strong>Error handling:</strong> Design comprehensive retry and dead letter strategies</li>\n    <li><strong>Testing:</strong> Test event flows end-to-end, not just individual components</li>\n  </ul>\n</div>\n<div class=\"concept-section\">\n  <h3>When EDA Might Not Be the Right Choice</h3>\n  <div style=\"background: #ffebee; padding: 20px; border-radius: 10px; margin: 20px 0;\">\n    <h4>⚠️ Consider Alternatives When:</h4>\n    <ul>\n      <li>Simple CRUD applications with straightforward business logic</li>\n      <li>Small team that can't maintain the operational complexity</li>\n      <li>Strong consistency requirements that can't tolerate eventual consistency</li>\n      <li>Real-time requirements where event processing latency is unacceptable</li>\n      <li>Regulatory environments that require deterministic processing</li>\n    </ul>\n  </div>\n</div>\n<div class=\"concept-section\">\n  <h3>Implementation Framework: Your EDA Checklist</h3>\n  <div style=\"background: #e8f5e8; padding: 20px; border-radius: 10px; margin: 20px 0;\">\n    <h4>✅ Pre-Implementation</h4>\n    <ul>\n      <li>Map your business processes and identify natural event boundaries</li>\n      <li>Choose technology stack (Kafka, cloud services, etc.)</li>\n      <li>Design event schema strategy and governance</li>\n      <li>Plan monitoring and observability from day one</li>\n    </ul>\n    <h4>✅ During Implementation</h4>\n    <ul>\n      <li>Start small with one bounded context or use case</li>\n      <li>Implement comprehensive error handling and retry logic</li>\n      <li>Build tooling for event inspection and replay</li>\n      <li>Train team on debugging distributed event flows</li>\n    </ul>\n    <h4>✅ Post-Implementation</h4>\n    <ul>\n      <li>Monitor business metrics derived from events</li>\n      <li>Continuously review and optimize event schemas</li>\n      <li>Document event flows and business processes</li>\n      <li>Plan for disaster recovery and event replay scenarios</li>\n    </ul>\n  </div>\n</div>\n<div class=\"exercise\">\n  <h3>🛠️ Design Your EDA Implementation Strategy</h3>\n  <p><strong>Scenario:</strong> You're the lead architect for a growing e-commerce company (50 engineers, 1M orders/month) planning to migrate from a monolithic architecture to microservices using event-driven patterns.</p>\n  <p><strong>Current system challenges:</strong></p>\n  <ul>\n    <li>Deployment bottlenecks—all features deploy together</li>\n    <li>Database performance issues during peak traffic</li>\n    <li>Difficulty adding new integrations (email, SMS, analytics)</li>\n    <li>Long development cycles due to team coordination</li>\n  </ul>\n  <p><strong>Your task:</strong> Create a comprehensive EDA migration plan including:</p>\n  <ol>\n    <li><strong>Phase 1 (Months 1-3):</strong> What would you implement first and why?</li>\n    <li><strong>Event identification:</strong> List 8-10 key business events your system should publish</li>\n    <li><strong>Technology choices:</strong> Event streaming platform, schema management, monitoring tools</li>\n    <li><strong>Success metrics:</strong> How will you measure the success of your EDA implementation?</li>\n    <li><strong>Risk mitigation:</strong> What could go wrong and how will you handle it?</li>\n  </ol>\n  <p><strong>Consider:</strong> How will you maintain system reliability during the migration? What's your rollback strategy if event-driven approaches cause issues?</p>\n</div>\n<div class=\"concept-section\">\n  <h3>🎉 Event-Driven Architecture Mastery Complete!</h3>\n  <p>You've now mastered:</p>\n  <ul>\n    <li>✅ Understanding when and why to adopt event-driven architecture</li>\n    <li>✅ Distinguishing between event sourcing and event streaming patterns</li>\n    <li>✅ Implementing CQRS for optimal read/write separation</li>\n    <li>✅ Designing sagas for distributed transaction management</li>\n    <li>✅ Handling event ordering, delivery guarantees, and exactly-once processing</li>\n    <li>✅ Learning from real-world implementations and operational best practices</li>\n  </ul>\n  <p><strong>Next steps:</strong> Implement a small event-driven proof of concept in your current system, explore advanced patterns like event sourcing frameworks (Axon, EventStore), or dive deeper into stream processing with Apache Kafka Streams.</p>\n</div>"
      }
    ]
  }